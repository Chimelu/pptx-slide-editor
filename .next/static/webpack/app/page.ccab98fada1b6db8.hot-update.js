"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/pptxParser.ts":
/*!*********************************!*\
  !*** ./src/utils/pptxParser.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PPTXParser: function() { return /* binding */ PPTXParser; }\n/* harmony export */ });\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jszip */ \"(app-pages-browser)/./node_modules/jszip/dist/jszip.min.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_0__);\n\nclass PPTXParser {\n    async parseFile(file) {\n        try {\n            console.log(\"Starting PPTX parsing...\");\n            // Load the ZIP file\n            this.zip = await jszip__WEBPACK_IMPORTED_MODULE_0___default().loadAsync(file);\n            console.log(\"ZIP file loaded successfully\");\n            // List all files for debugging\n            const fileNames = Object.keys(this.zip.files);\n            console.log(\"Files in ZIP:\", fileNames);\n            // Parse the document\n            const slides = await this.readSlides();\n            const properties = await this.readPresentationProps();\n            console.log(\"Parsing completed successfully\");\n            return {\n                id: crypto.randomUUID(),\n                name: file.name.replace(\".pptx\", \"\"),\n                slides,\n                metadata: properties\n            };\n        } catch (error) {\n            console.error(\"Error parsing PPTX file:\", error);\n            throw error;\n        }\n    }\n    async readPresentationProps() {\n        try {\n            var _this_zip;\n            const coreProps = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(\"docProps/core.xml\");\n            if (coreProps) {\n                const content = await coreProps.async(\"text\");\n                const parser = new DOMParser();\n                const xml = parser.parseFromString(content, \"text/xml\");\n                const authorElement = xml.querySelector(\"dc\\\\:creator, creator\");\n                return {\n                    author: (authorElement === null || authorElement === void 0 ? void 0 : authorElement.textContent) || undefined\n                };\n            }\n        } catch (error) {\n            console.warn(\"Could not read presentation properties:\", error);\n        }\n        return {};\n    }\n    async readSlides() {\n        const slides = [];\n        try {\n            var _this_zip;\n            // Get slide count from presentation.xml\n            const presentation = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(\"ppt/presentation.xml\");\n            if (presentation) {\n                const content = await presentation.async(\"text\");\n                console.log(\"Presentation XML content:\", content.substring(0, 500) + \"...\");\n                const parser = new DOMParser();\n                const xml = parser.parseFromString(content, \"text/xml\");\n                // Try multiple approaches to find slides\n                let slideIds = xml.getElementsByTagName(\"sldId\");\n                console.log(\"Found \".concat(slideIds.length, \" slides using 'sldId' tag\"));\n                // If no slides found, try alternative approaches\n                if (slideIds.length === 0) {\n                    var _this_zip1;\n                    // Try looking for slides in the slides folder directly\n                    const slideFiles = Object.keys(((_this_zip1 = this.zip) === null || _this_zip1 === void 0 ? void 0 : _this_zip1.files) || {}).filter((name)=>name.startsWith(\"ppt/slides/slide\") && name.endsWith(\".xml\")).sort();\n                    console.log(\"Found slide files directly:\", slideFiles);\n                    if (slideFiles.length > 0) {\n                        // Create slides from the files we found\n                        for(let i = 0; i < slideFiles.length; i++){\n                            const slideFile = slideFiles[i];\n                            const slideNumber = i + 1;\n                            console.log(\"Processing slide file: \".concat(slideFile));\n                            const slide = await this.readSlideFromFile(slideFile, slideNumber);\n                            if (slide) {\n                                slides.push(slide);\n                                console.log(\"Successfully loaded slide \".concat(slideNumber, \" from file\"));\n                            }\n                        }\n                    }\n                } else {\n                    // Process slides using the traditional method\n                    for(let i = 0; i < slideIds.length; i++){\n                        const slideId = slideIds[i].getAttribute(\"r:id\");\n                        console.log(\"Processing slide \".concat(i + 1, \" with ID: \").concat(slideId));\n                        if (slideId) {\n                            const slide = await this.readSlide(slideId, i + 1);\n                            if (slide) {\n                                slides.push(slide);\n                                console.log(\"Successfully loaded slide \".concat(i + 1));\n                            } else {\n                                console.warn(\"Failed to load slide \".concat(i + 1));\n                            }\n                        }\n                    }\n                }\n            } else {\n                console.warn(\"Could not find presentation.xml\");\n            }\n        } catch (error) {\n            console.error(\"Error reading slides:\", error);\n            // Create a default slide if parsing fails\n            slides.push(this.createDefaultSlide());\n        }\n        console.log(\"Total slides loaded: \".concat(slides.length));\n        return slides.length > 0 ? slides : [\n            this.createDefaultSlide()\n        ];\n    }\n    async readSlide(slideId, slideNumber) {\n        try {\n            var _this_zip;\n            // Try to find the slide file directly first\n            let slideFile = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(\"ppt/slides/slide\".concat(slideNumber, \".xml\"));\n            // If not found, try to find it through relationships\n            if (!slideFile) {\n                var _this_zip1;\n                const slideRel = (_this_zip1 = this.zip) === null || _this_zip1 === void 0 ? void 0 : _this_zip1.file(\"ppt/slides/_rels/slide\".concat(slideNumber, \".xml.rels\"));\n                if (slideRel) {\n                    var _relXml_querySelector;\n                    const relContent = await slideRel.async(\"text\");\n                    const relParser = new DOMParser();\n                    const relXml = relParser.parseFromString(relContent, \"text/xml\");\n                    const slideTarget = (_relXml_querySelector = relXml.querySelector('Relationship[Id=\"'.concat(slideId, '\"]'))) === null || _relXml_querySelector === void 0 ? void 0 : _relXml_querySelector.getAttribute(\"Target\");\n                    if (slideTarget) {\n                        var _this_zip2;\n                        const slidePath = \"ppt/slides/\".concat(slideTarget.split(\"/\").pop());\n                        slideFile = (_this_zip2 = this.zip) === null || _this_zip2 === void 0 ? void 0 : _this_zip2.file(slidePath);\n                    }\n                }\n            }\n            // If still not found, try to find any slide file\n            if (!slideFile) {\n                var _this_zip3;\n                const slideFiles = Object.keys(((_this_zip3 = this.zip) === null || _this_zip3 === void 0 ? void 0 : _this_zip3.files) || {}).filter((name)=>name.startsWith(\"ppt/slides/slide\") && name.endsWith(\".xml\")).sort();\n                if (slideFiles.length > 0) {\n                    var _this_zip4;\n                    const targetSlide = slideFiles[slideNumber - 1] || slideFiles[0];\n                    slideFile = (_this_zip4 = this.zip) === null || _this_zip4 === void 0 ? void 0 : _this_zip4.file(targetSlide);\n                }\n            }\n            if (!slideFile) {\n                console.warn(\"Could not find slide file for slide \".concat(slideNumber));\n                return null;\n            }\n            const slideContent = await slideFile.async(\"text\");\n            const slideParser = new DOMParser();\n            const slideXml = slideParser.parseFromString(slideContent, \"text/xml\");\n            // Extract slide dimensions\n            const sldSz = slideXml.getElementsByTagName(\"sldSz\")[0];\n            const width = parseInt((sldSz === null || sldSz === void 0 ? void 0 : sldSz.getAttribute(\"cx\")) || \"9144000\") / 12700 // Convert EMUs to pixels\n            ;\n            const height = parseInt((sldSz === null || sldSz === void 0 ? void 0 : sldSz.getAttribute(\"cy\")) || \"6858000\") / 12700;\n            // Extract shapes\n            const objects = await this.extractShapes(slideXml, slideNumber);\n            return {\n                id: crypto.randomUUID(),\n                name: \"Slide \".concat(slideNumber),\n                width,\n                height,\n                objects\n            };\n        } catch (error) {\n            console.error(\"Error reading slide \".concat(slideNumber, \":\"), error);\n            return null;\n        }\n    }\n    async readSlideFromFile(slideFilePath, slideNumber) {\n        try {\n            var _this_zip;\n            const slideFile = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(slideFilePath);\n            if (!slideFile) {\n                console.warn(\"Could not find slide file: \".concat(slideFilePath));\n                return null;\n            }\n            const slideContent = await slideFile.async(\"text\");\n            console.log(\"Slide \".concat(slideNumber, \" XML content:\"), slideContent.substring(0, 1000) + \"...\");\n            const slideParser = new DOMParser();\n            const slideXml = slideParser.parseFromString(slideContent, \"text/xml\");\n            // Extract slide dimensions with better namespace handling\n            let sldSz = slideXml.getElementsByTagName(\"sldSz\")[0];\n            if (!sldSz) {\n                sldSz = slideXml.getElementsByTagName(\"p:sldSz\")[0];\n            }\n            let width = 800, height = 600 // Default dimensions\n            ;\n            if (sldSz) {\n                const cx = sldSz.getAttribute(\"cx\");\n                const cy = sldSz.getAttribute(\"cy\");\n                console.log(\"Slide \".concat(slideNumber, \" dimensions from XML:\"), {\n                    cx,\n                    cy\n                });\n                if (cx && cy) {\n                    // Convert EMUs to pixels\n                    const emuToPixel = 96 / 914400;\n                    width = parseInt(cx) * emuToPixel;\n                    height = parseInt(cy) * emuToPixel;\n                    console.log(\"Slide \".concat(slideNumber, \" converted dimensions:\"), {\n                        width,\n                        height\n                    });\n                }\n            } else {\n                console.warn(\"No sldSz found in slide \".concat(slideNumber, \", using defaults\"));\n            }\n            // Extract shapes\n            const objects = await this.extractShapes(slideXml, slideNumber);\n            return {\n                id: crypto.randomUUID(),\n                name: \"Slide \".concat(slideNumber),\n                width: Math.max(width, 800),\n                height: Math.max(height, 600),\n                objects\n            };\n        } catch (error) {\n            console.error(\"Error reading slide from file \".concat(slideFilePath, \":\"), error);\n            return null;\n        }\n    }\n    async extractShapes(slideXml, slideNumber) {\n        const objects = [];\n        try {\n            console.log(\"Extracting shapes from slide \".concat(slideNumber));\n            // Try multiple approaches to find shapes\n            // Approach 1: Look for spTree > sp (traditional structure)\n            // Use a more robust approach to handle namespaces\n            let spTree = this.findElementByTagName(slideXml, \"spTree\");\n            if (spTree) {\n                const textBoxes = this.findElementsByTagName(spTree, \"sp\");\n                console.log(\"Found \".concat(textBoxes.length, \" shape elements in spTree\"));\n                for(let i = 0; i < textBoxes.length; i++){\n                    const textBox = textBoxes[i];\n                    console.log(\"Processing shape \".concat(i + 1, \":\"), textBox.tagName, textBox.getAttribute(\"id\"), textBox.getAttribute(\"name\"));\n                    // Check if this is a placeholder\n                    const nvPr = this.findElementByTagName(textBox, \"nvPr\");\n                    const ph = nvPr ? this.findElementByTagName(nvPr, \"ph\") : null;\n                    if (ph) {\n                        const phType = ph.getAttribute(\"type\");\n                        console.log(\"Shape \".concat(i + 1, \" is a placeholder of type: \").concat(phType));\n                    }\n                    const shape = this.extractTextBox(textBox, slideNumber, i);\n                    if (shape) {\n                        objects.push(shape);\n                        console.log(\"Successfully extracted shape \".concat(i + 1, \":\"), shape.type, shape.content || \"no content\");\n                    } else {\n                        console.warn(\"Failed to extract shape \".concat(i + 1));\n                    }\n                }\n            } else {\n                console.warn(\"No spTree found in slide\");\n            }\n            // Approach 2: Look for shapes directly in the slide\n            if (objects.length === 0) {\n                console.log(\"Trying alternative shape extraction...\");\n                // Look for any sp elements anywhere in the slide\n                const allSpElements = this.findElementsByTagName(slideXml, \"sp\");\n                console.log(\"Found \".concat(allSpElements.length, \" sp elements in slide\"));\n                for(let i = 0; i < allSpElements.length; i++){\n                    const spElement = allSpElements[i];\n                    console.log(\"Processing sp element \".concat(i + 1, \":\"), spElement.tagName, spElement.getAttribute(\"id\"));\n                    const shape = this.extractTextBox(spElement, slideNumber, i);\n                    if (shape) {\n                        objects.push(shape);\n                        console.log(\"Successfully extracted sp element \".concat(i + 1, \":\"), shape.type, shape.content || \"no content\");\n                    }\n                }\n            }\n            // Approach 3: Look for text elements directly\n            if (objects.length === 0) {\n                console.log(\"Trying direct text extraction...\");\n                const textElements = this.findElementsByTagName(slideXml, \"t\");\n                console.log(\"Found \".concat(textElements.length, \" text elements directly in slide\"));\n                if (textElements.length > 0) {\n                    // Create a simple text object from the first text element\n                    const firstText = textElements[0];\n                    const textContent = firstText.textContent || \"Text\";\n                    console.log('Creating text object with content: \"'.concat(textContent, '\"'));\n                    const textObject = {\n                        id: crypto.randomUUID(),\n                        type: \"text\",\n                        transform: {\n                            left: 100,\n                            top: 100,\n                            width: 300,\n                            height: 100,\n                            angle: 0,\n                            scaleX: 1,\n                            scaleY: 1,\n                            flipX: false,\n                            flipY: false\n                        },\n                        style: {\n                            fontFamily: \"Arial\",\n                            fontSize: 18,\n                            fontWeight: \"normal\",\n                            fontStyle: \"normal\",\n                            textDecoration: \"none\",\n                            color: \"#000000\",\n                            textAlign: \"left\",\n                            lineHeight: 1.2\n                        },\n                        content: textContent\n                    };\n                    objects.push(textObject);\n                    console.log(\"Created fallback text object\");\n                }\n            }\n            // Extract images\n            const images = this.findElementsByTagName(slideXml, \"pic\");\n            console.log(\"Found \".concat(images.length, \" image elements\"));\n            for(let i = 0; i < images.length; i++){\n                const image = images[i];\n                const shape = this.extractImage(image, slideNumber, i);\n                if (shape) {\n                    objects.push(shape);\n                    console.log(\"Successfully extracted image \".concat(i + 1));\n                }\n            }\n            console.log(\"Total objects extracted: \".concat(objects.length));\n            console.log(\"Final objects:\", objects.map((obj)=>({\n                    type: obj.type,\n                    content: obj.content,\n                    transform: obj.transform\n                })));\n        } catch (error) {\n            console.error(\"Error extracting shapes:\", error);\n        }\n        return objects;\n    }\n    // Helper methods to handle XML namespaces\n    findElementByTagName(parent, tagName) {\n        // Try multiple approaches to find the element\n        let element = parent.getElementsByTagName(tagName)[0];\n        if (element) return element;\n        // If not found, try with common namespace prefixes\n        const prefixes = [\n            \"p:\",\n            \"a:\",\n            \"r:\",\n            \"\"\n        ];\n        for (const prefix of prefixes){\n            const fullTagName = prefix + tagName;\n            element = parent.getElementsByTagName(fullTagName)[0];\n            if (element) return element;\n        }\n        // Last resort: search by partial tag name\n        const allElements = parent.getElementsByTagName(\"*\");\n        for(let i = 0; i < allElements.length; i++){\n            const el = allElements[i];\n            if (el.tagName.endsWith(tagName) || el.tagName.includes(tagName)) {\n                return el;\n            }\n        }\n        return null;\n    }\n    findElementsByTagName(parent, tagName) {\n        // Try multiple approaches to find elements\n        let elements = Array.from(parent.getElementsByTagName(tagName));\n        if (elements.length > 0) return elements;\n        // If not found, try with common namespace prefixes\n        const prefixes = [\n            \"p:\",\n            \"a:\",\n            \"r:\",\n            \"\"\n        ];\n        for (const prefix of prefixes){\n            const fullTagName = prefix + tagName;\n            elements = Array.from(parent.getElementsByTagName(fullTagName));\n            if (elements.length > 0) return elements;\n        }\n        // Last resort: search by partial tag name\n        const allElements = parent.getElementsByTagName(\"*\");\n        const matchingElements = [];\n        for(let i = 0; i < allElements.length; i++){\n            const el = allElements[i];\n            if (el.tagName.endsWith(tagName) || el.tagName.includes(tagName)) {\n                matchingElements.push(el);\n            }\n        }\n        return matchingElements;\n    }\n    extractTextBox(textBox, slideNumber, index) {\n        try {\n            console.log(\"Extracting text box \".concat(index + 1, \" from slide \").concat(slideNumber));\n            console.log(\"Text box element:\", textBox.outerHTML.substring(0, 500) + \"...\");\n            const spPr = this.findElementByTagName(textBox, \"spPr\");\n            if (!spPr) {\n                console.warn(\"No spPr found in text box \".concat(index + 1));\n                return null;\n            }\n            // Check if this is actually a text shape or a different type\n            const txBody = this.findElementByTagName(textBox, \"txBody\");\n            const hasText = txBody && this.findElementsByTagName(txBody, \"t\").length > 0;\n            // Check if this is a placeholder or shape with text\n            const nvPr = this.findElementByTagName(textBox, \"nvPr\");\n            const ph = nvPr ? this.findElementByTagName(nvPr, \"ph\") : null;\n            const isPlaceholder = ph && ph.getAttribute(\"type\");\n            // Check the actual shape type from spPr\n            const prstGeom = spPr.getElementsByTagName(\"prstGeom\")[0] || spPr.getElementsByTagName(\"a:prstGeom\")[0];\n            const shapeType = prstGeom === null || prstGeom === void 0 ? void 0 : prstGeom.getAttribute(\"prst\");\n            console.log(\"Shape \".concat(index + 1, \" - hasText: \").concat(hasText, \", isPlaceholder: \").concat(isPlaceholder, \", shapeType: \").concat(shapeType));\n            // If this is a rectangle, ellipse, or other shape (not text), extract as basic shape\n            if (shapeType && [\n                \"rect\",\n                \"roundRect\",\n                \"ellipse\",\n                \"oval\",\n                \"line\"\n            ].includes(shapeType)) {\n                console.log(\"Shape \".concat(index + 1, \" is a \").concat(shapeType, \", treating as basic shape\"));\n                return this.extractBasicShape(textBox, slideNumber, index);\n            }\n            // If this has no text and is not a placeholder, treat as basic shape\n            if (!hasText && !isPlaceholder) {\n                console.log(\"Shape \".concat(index + 1, \" has no text and is not a placeholder, treating as basic shape\"));\n                return this.extractBasicShape(textBox, slideNumber, index);\n            }\n            const transform = this.extractTransform(spPr);\n            const textContent = this.extractTextContent(textBox);\n            const textStyle = this.extractTextStyle(textBox);\n            console.log('Extracted text box: content=\"'.concat(textContent, '\", transform='), transform);\n            return {\n                id: crypto.randomUUID(),\n                type: \"text\",\n                transform,\n                style: textStyle,\n                content: textContent\n            };\n        } catch (error) {\n            console.error(\"Error extracting text box:\", error);\n            return null;\n        }\n    }\n    extractImage(image, slideNumber, index) {\n        try {\n            const spPr = this.findElementByTagName(image, \"spPr\");\n            if (!spPr) return null;\n            const transform = this.extractTransform(spPr);\n            // For now, we'll create a placeholder image\n            // In a real implementation, you'd extract the actual image data\n            return {\n                id: crypto.randomUUID(),\n                type: \"image\",\n                transform,\n                style: {},\n                src: \"data:image/svg+xml;base64,\".concat(btoa('<svg width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" fill=\"#ccc\"/><text x=\"50\" y=\"50\" text-anchor=\"middle\" dy=\".3em\">Image</text></svg>'))\n            };\n        } catch (error) {\n            console.error(\"Error extracting image:\", error);\n            return null;\n        }\n    }\n    extractBasicShape(shape, slideNumber, index) {\n        try {\n            console.log(\"Extracting basic shape \".concat(index + 1, \" from slide \").concat(slideNumber));\n            const spPr = this.findElementByTagName(shape, \"spPr\");\n            if (!spPr) {\n                console.warn(\"No spPr found in basic shape \".concat(index + 1));\n                return null;\n            }\n            const transform = this.extractTransform(spPr);\n            // Get the actual shape type from the XML\n            let prstGeom = spPr.getElementsByTagName(\"prstGeom\")[0];\n            if (!prstGeom) {\n                prstGeom = spPr.getElementsByTagName(\"a:prstGeom\")[0];\n            }\n            let shapeType = \"rectangle\";\n            if (prstGeom) {\n                const prst = prstGeom.getAttribute(\"prst\");\n                console.log(\"Found shape type in XML: \".concat(prst));\n                switch(prst){\n                    case \"rect\":\n                    case \"roundRect\":\n                        shapeType = \"rectangle\";\n                        break;\n                    case \"ellipse\":\n                    case \"oval\":\n                        shapeType = \"ellipse\";\n                        break;\n                    case \"line\":\n                    case \"straightConnector1\":\n                        shapeType = \"line\";\n                        break;\n                    default:\n                        console.log(\"Unknown shape type: \".concat(prst, \", defaulting to rectangle\"));\n                        shapeType = \"rectangle\";\n                }\n            }\n            console.log(\"Extracted basic shape: type=\".concat(shapeType, \", transform=\"), transform);\n            // For basic shapes, we might still have some text content (like placeholders)\n            let content = \"\";\n            const txBody = this.findElementByTagName(shape, \"txBody\");\n            if (txBody) {\n                content = this.extractTextContent(shape);\n            }\n            // Check if this is a placeholder\n            const nvPr = this.findElementByTagName(shape, \"nvPr\");\n            const ph = nvPr ? this.findElementByTagName(nvPr, \"ph\") : null;\n            if (ph) {\n                const phType = ph.getAttribute(\"type\");\n                if (phType === \"title\") {\n                    content = \"Title Placeholder\";\n                } else if (phType === \"body\") {\n                    content = \"Body Placeholder\";\n                } else if (phType === \"pic\") {\n                    content = \"Picture Placeholder\";\n                } else {\n                    content = \"Content Placeholder\";\n                }\n            }\n            // Get shape name for better identification\n            const cNvPr = this.findElementByTagName(shape, \"cNvPr\");\n            const shapeName = (cNvPr === null || cNvPr === void 0 ? void 0 : cNvPr.getAttribute(\"name\")) || \"Shape \".concat(index + 1);\n            console.log(\"Shape name: \".concat(shapeName));\n            return {\n                id: crypto.randomUUID(),\n                type: shapeType,\n                transform,\n                style: {\n                    fill: shapeType === \"line\" ? \"transparent\" : \"#e5e7eb\",\n                    stroke: \"#6b7280\",\n                    strokeWidth: shapeType === \"line\" ? 2 : 1\n                },\n                content: content || undefined\n            };\n        } catch (error) {\n            console.error(\"Error extracting basic shape:\", error);\n            return null;\n        }\n    }\n    extractTransform(spPr) {\n        // Debug the spPr element structure\n        console.log(\"Extracting transform from spPr:\", spPr.outerHTML.substring(0, 500) + \"...\");\n        // Try to find xfrm element with better namespace handling\n        let xfrm = spPr.getElementsByTagName(\"xfrm\")[0];\n        if (!xfrm) {\n            // Try with namespace prefixes\n            xfrm = spPr.getElementsByTagName(\"a:xfrm\")[0];\n        }\n        if (!xfrm) {\n            // Try searching by partial tag name\n            const allElements = spPr.getElementsByTagName(\"*\");\n            for(let i = 0; i < allElements.length; i++){\n                const el = allElements[i];\n                if (el.tagName.includes(\"xfrm\")) {\n                    xfrm = el;\n                    break;\n                }\n            }\n        }\n        console.log(\"Found xfrm element:\", xfrm === null || xfrm === void 0 ? void 0 : xfrm.outerHTML);\n        if (xfrm) {\n            // Find offset, extent, and rotation with better namespace handling\n            let off = xfrm.getElementsByTagName(\"off\")[0];\n            if (!off) off = xfrm.getElementsByTagName(\"a:off\")[0];\n            let ext = xfrm.getElementsByTagName(\"ext\")[0];\n            if (!ext) ext = xfrm.getElementsByTagName(\"a:ext\")[0];\n            let rot = xfrm.getElementsByTagName(\"rot\")[0];\n            if (!rot) rot = xfrm.getElementsByTagName(\"a:rot\")[0];\n            console.log(\"Transform elements - off:\", off === null || off === void 0 ? void 0 : off.outerHTML, \"ext:\", ext === null || ext === void 0 ? void 0 : ext.outerHTML, \"rot:\", rot === null || rot === void 0 ? void 0 : rot.outerHTML);\n            // Convert EMUs to pixels with better scaling\n            // 1 EMU = 1/914400 inch, 1 inch = 96 pixels (standard DPI)\n            // So 1 EMU = 96/914400 = 0.000105 pixels\n            // For better visibility, we'll scale this up\n            const emuToPixel = 96 / 914400;\n            const scaleFactor = 1 // Adjust this to make shapes bigger/smaller\n            ;\n            const left = parseInt((off === null || off === void 0 ? void 0 : off.getAttribute(\"x\")) || \"0\") * emuToPixel * scaleFactor;\n            const top = parseInt((off === null || off === void 0 ? void 0 : off.getAttribute(\"y\")) || \"0\") * emuToPixel * scaleFactor;\n            const width = parseInt((ext === null || ext === void 0 ? void 0 : ext.getAttribute(\"cx\")) || \"1000000\") * emuToPixel * scaleFactor;\n            const height = parseInt((ext === null || ext === void 0 ? void 0 : ext.getAttribute(\"cy\")) || \"1000000\") * emuToPixel * scaleFactor;\n            const angle = parseInt((rot === null || rot === void 0 ? void 0 : rot.getAttribute(\"val\")) || \"0\") / 60000 // Convert 60kths to degrees\n            ;\n            const transform = {\n                left: Math.max(0, left),\n                top: Math.max(0, top),\n                width: Math.max(50, width),\n                height: Math.max(50, height),\n                angle,\n                scaleX: 1,\n                scaleY: 1,\n                flipX: false,\n                flipY: false\n            };\n            console.log(\"Extracted transform (EMU values):\", {\n                emuLeft: off === null || off === void 0 ? void 0 : off.getAttribute(\"x\"),\n                emuTop: off === null || off === void 0 ? void 0 : off.getAttribute(\"y\"),\n                emuWidth: ext === null || ext === void 0 ? void 0 : ext.getAttribute(\"cx\"),\n                emuHeight: ext === null || ext === void 0 ? void 0 : ext.getAttribute(\"cy\")\n            });\n            console.log(\"Converted transform (pixels):\", transform);\n            return transform;\n        }\n        console.warn(\"No xfrm found, using default transform\");\n        return {\n            left: 100,\n            top: 100,\n            width: 200,\n            height: 150,\n            angle: 0,\n            scaleX: 1,\n            scaleY: 1,\n            flipX: false,\n            flipY: false\n        };\n    }\n    extractTextContent(textBox) {\n        // Try multiple approaches to find text content\n        let content = \"\";\n        // First try: look for text in txBody > p > r > t\n        const txBody = this.findElementByTagName(textBox, \"txBody\");\n        if (txBody) {\n            const paragraphs = this.findElementsByTagName(txBody, \"p\");\n            console.log(\"Found \".concat(paragraphs.length, \" paragraphs in text box\"));\n            for(let i = 0; i < paragraphs.length; i++){\n                const paragraph = paragraphs[i];\n                const textRuns = this.findElementsByTagName(paragraph, \"r\");\n                console.log(\"Paragraph \".concat(i + 1, \" has \").concat(textRuns.length, \" text runs\"));\n                let paragraphText = \"\";\n                for(let j = 0; j < textRuns.length; j++){\n                    const textRun = textRuns[j];\n                    const textElement = this.findElementByTagName(textRun, \"t\");\n                    if (textElement && textElement.textContent) {\n                        paragraphText += textElement.textContent;\n                        console.log(\"Text run \".concat(j + 1, ': \"').concat(textElement.textContent, '\"'));\n                    }\n                }\n                // Add paragraph text to content\n                if (paragraphText) {\n                    if (content) content += \"\\n\" // Add line break between paragraphs\n                    ;\n                    content += paragraphText;\n                }\n            }\n        }\n        // Second try: look for text directly in the textBox\n        if (!content) {\n            const textElements = this.findElementsByTagName(textBox, \"t\");\n            console.log(\"Found \".concat(textElements.length, \" text elements directly in text box\"));\n            for(let i = 0; i < textElements.length; i++){\n                const element = textElements[i];\n                if (element.textContent) {\n                    if (content) content += \"\\n\";\n                    content += element.textContent;\n                    console.log(\"Direct text element \".concat(i + 1, ': \"').concat(element.textContent, '\"'));\n                }\n            }\n        }\n        // Third try: look for any text content in the element\n        if (!content) {\n            content = textBox.textContent || \"\";\n            console.log('Fallback text content: \"'.concat(content, '\"'));\n        }\n        console.log('Final extracted text content: \"'.concat(content, '\"'));\n        return content || \"Text Box\";\n    }\n    extractTextStyle(textBox) {\n        const defRPr = this.findElementByTagName(textBox, \"defRPr\");\n        if (defRPr) {\n            return {\n                fontFamily: defRPr.getAttribute(\"typeface\") || \"Arial\",\n                fontSize: parseInt(defRPr.getAttribute(\"sz\") || \"1800\") / 100,\n                fontWeight: defRPr.getAttribute(\"b\") === \"1\" ? \"bold\" : \"normal\",\n                fontStyle: defRPr.getAttribute(\"i\") === \"1\" ? \"italic\" : \"normal\",\n                textDecoration: defRPr.getAttribute(\"u\") === \"1\" ? \"underline\" : \"none\",\n                color: this.extractColor(defRPr),\n                textAlign: \"left\",\n                lineHeight: 1.2\n            };\n        }\n        return {\n            fontFamily: \"Arial\",\n            fontSize: 18,\n            fontWeight: \"normal\",\n            fontStyle: \"normal\",\n            textDecoration: \"none\",\n            color: \"#000000\",\n            textAlign: \"left\",\n            lineHeight: 1.2\n        };\n    }\n    extractColor(defRPr) {\n        const solidFill = this.findElementByTagName(defRPr, \"solidFill\");\n        if (solidFill) {\n            const srgbClr = this.findElementByTagName(solidFill, \"srgbClr\");\n            if (srgbClr) {\n                const val = srgbClr.getAttribute(\"val\");\n                if (val) {\n                    return \"#\".concat(val);\n                }\n            }\n        }\n        return \"#000000\";\n    }\n    determineShapeType(spPr) {\n        // Try to find prstGeom element with better namespace handling\n        let prstGeom = spPr.getElementsByTagName(\"prstGeom\")[0];\n        if (!prstGeom) {\n            prstGeom = spPr.getElementsByTagName(\"a:prstGeom\")[0];\n        }\n        if (prstGeom) {\n            const prst = prstGeom.getAttribute(\"prst\");\n            console.log(\"Found shape type: \".concat(prst));\n            switch(prst){\n                case \"rect\":\n                case \"roundRect\":\n                    return \"rectangle\";\n                case \"ellipse\":\n                case \"oval\":\n                    return \"ellipse\";\n                case \"line\":\n                case \"straightConnector1\":\n                    return \"line\";\n                default:\n                    console.log(\"Unknown shape type: \".concat(prst, \", defaulting to rectangle\"));\n                    return \"rectangle\";\n            }\n        }\n        // If no prstGeom found, try to determine from other properties\n        console.log(\"No prstGeom found, defaulting to rectangle\");\n        return \"rectangle\";\n    }\n    createDefaultSlide() {\n        return {\n            id: crypto.randomUUID(),\n            name: \"Slide 1\",\n            width: 960,\n            height: 540,\n            objects: [\n                {\n                    id: crypto.randomUUID(),\n                    type: \"text\",\n                    transform: {\n                        left: 100,\n                        top: 100,\n                        width: 300,\n                        height: 100,\n                        angle: 0,\n                        scaleX: 1,\n                        scaleY: 1,\n                        flipX: false,\n                        flipY: false\n                    },\n                    style: {\n                        fontFamily: \"Arial\",\n                        fontSize: 24,\n                        fontWeight: \"bold\",\n                        color: \"#000000\",\n                        textAlign: \"left\"\n                    },\n                    content: \"Welcome to PPTX Editor\"\n                }\n            ]\n        };\n    }\n    constructor(){\n        this.zip = null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9wcHR4UGFyc2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QjtBQUdsQixNQUFNQztJQUdYLE1BQU1DLFVBQVVDLElBQVUsRUFBeUI7UUFDakQsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFFWixvQkFBb0I7WUFDcEIsSUFBSSxDQUFDQyxHQUFHLEdBQUcsTUFBTU4sc0RBQWUsQ0FBQ0c7WUFDakNDLFFBQVFDLEdBQUcsQ0FBQztZQUVaLCtCQUErQjtZQUMvQixNQUFNRyxZQUFZQyxPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDSixHQUFHLENBQUNLLEtBQUs7WUFDNUNQLFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUJHO1lBRTdCLHFCQUFxQjtZQUNyQixNQUFNSSxTQUFTLE1BQU0sSUFBSSxDQUFDQyxVQUFVO1lBQ3BDLE1BQU1DLGFBQWEsTUFBTSxJQUFJLENBQUNDLHFCQUFxQjtZQUVuRFgsUUFBUUMsR0FBRyxDQUFDO1lBRVosT0FBTztnQkFDTFcsSUFBSUMsT0FBT0MsVUFBVTtnQkFDckJDLE1BQU1oQixLQUFLZ0IsSUFBSSxDQUFDQyxPQUFPLENBQUMsU0FBUztnQkFDakNSO2dCQUNBUyxVQUFVUDtZQUNaO1FBQ0YsRUFBRSxPQUFPUSxPQUFPO1lBQ2RsQixRQUFRa0IsS0FBSyxDQUFDLDRCQUE0QkE7WUFDMUMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsTUFBY1Asd0JBQXNEO1FBQ2xFLElBQUk7Z0JBQ2dCO1lBQWxCLE1BQU1RLGFBQVksZ0JBQUksQ0FBQ2pCLEdBQUcsY0FBUiwwQ0FBVUgsSUFBSSxDQUFDO1lBQ2pDLElBQUlvQixXQUFXO2dCQUNiLE1BQU1DLFVBQVUsTUFBTUQsVUFBVUUsS0FBSyxDQUFDO2dCQUN0QyxNQUFNQyxTQUFTLElBQUlDO2dCQUNuQixNQUFNQyxNQUFNRixPQUFPRyxlQUFlLENBQUNMLFNBQVM7Z0JBRTVDLE1BQU1NLGdCQUFnQkYsSUFBSUcsYUFBYSxDQUFDO2dC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QkFDckJ5RSxNQUFNO29CQUNOTSxXQUFXO3dCQUNUQyxNQUFNO3dCQUNOQyxLQUFLO3dCQUNMOUIsT0FBTzt3QkFDUEUsUUFBUTt3QkFDUjZCLE9BQU87d0JBQ1BDLFFBQVE7d0JBQ1JDLFFBQVE7d0JBQ1JDLE9BQU87d0JBQ1BDLE9BQU87b0JBQ1Q7b0JBQ0FDLE9BQU87d0JBQ0xDLFlBQVk7d0JBQ1pDLFVBQVU7d0JBQ1ZDLFlBQVk7d0JBQ1pHLE9BQU87d0JBQ1BDLFdBQVc7b0JBQ2I7b0JBQ0F4RixTQUFTO2dCQUNYO2FBQ0Q7UUFDSDtJQUNGOzthQWgwQlFsQixNQUFvQjs7QUFpMEI5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvcHB0eFBhcnNlci50cz9lMThmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBKU1ppcCBmcm9tICdqc3ppcCdcclxuaW1wb3J0IHsgUFBUWERvY3VtZW50LCBTbGlkZSwgU2hhcGVPYmplY3QsIFRyYW5zZm9ybSwgVGV4dFN0eWxlIH0gZnJvbSAnQC90eXBlcy9wcHR4J1xyXG5cclxuZXhwb3J0IGNsYXNzIFBQVFhQYXJzZXIge1xyXG4gIHByaXZhdGUgemlwOiBKU1ppcCB8IG51bGwgPSBudWxsXHJcblxyXG4gIGFzeW5jIHBhcnNlRmlsZShmaWxlOiBGaWxlKTogUHJvbWlzZTxQUFRYRG9jdW1lbnQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBQUFRYIHBhcnNpbmcuLi4nKVxyXG4gICAgICBcclxuICAgICAgLy8gTG9hZCB0aGUgWklQIGZpbGVcclxuICAgICAgdGhpcy56aXAgPSBhd2FpdCBKU1ppcC5sb2FkQXN5bmMoZmlsZSlcclxuICAgICAgY29uc29sZS5sb2coJ1pJUCBmaWxlIGxvYWRlZCBzdWNjZXNzZnVsbHknKVxyXG4gICAgICBcclxuICAgICAgLy8gTGlzdCBhbGwgZmlsZXMgZm9yIGRlYnVnZ2luZ1xyXG4gICAgICBjb25zdCBmaWxlTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnppcC5maWxlcylcclxuICAgICAgY29uc29sZS5sb2coJ0ZpbGVzIGluIFpJUDonLCBmaWxlTmFtZXMpXHJcbiAgICAgIFxyXG4gICAgICAvLyBQYXJzZSB0aGUgZG9jdW1lbnRcclxuICAgICAgY29uc3Qgc2xpZGVzID0gYXdhaXQgdGhpcy5yZWFkU2xpZGVzKClcclxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGF3YWl0IHRoaXMucmVhZFByZXNlbnRhdGlvblByb3BzKClcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdQYXJzaW5nIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgICBuYW1lOiBmaWxlLm5hbWUucmVwbGFjZSgnLnBwdHgnLCAnJyksXHJcbiAgICAgICAgc2xpZGVzLFxyXG4gICAgICAgIG1ldGFkYXRhOiBwcm9wZXJ0aWVzLFxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIFBQVFggZmlsZTonLCBlcnJvcilcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmVhZFByZXNlbnRhdGlvblByb3BzKCk6IFByb21pc2U8eyBhdXRob3I/OiBzdHJpbmcgfT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY29yZVByb3BzID0gdGhpcy56aXA/LmZpbGUoJ2RvY1Byb3BzL2NvcmUueG1sJylcclxuICAgICAgaWYgKGNvcmVQcm9wcykge1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBjb3JlUHJvcHMuYXN5bmMoJ3RleHQnKVxyXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKVxyXG4gICAgICAgIGNvbnN0IHhtbCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoY29udGVudCwgJ3RleHQveG1sJylcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBhdXRob3JFbGVtZW50ID0geG1sLnF1ZXJ5U2VsZWN0b3IoJ2RjXFxcXDpjcmVhdG9yLCBjcmVhdG9yJylcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgYXV0aG9yOiBhdXRob3JFbGVtZW50Py50ZXh0Q29udGVudCB8fCB1bmRlZmluZWRcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IHJlYWQgcHJlc2VudGF0aW9uIHByb3BlcnRpZXM6JywgZXJyb3IpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB7fVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyByZWFkU2xpZGVzKCk6IFByb21pc2U8U2xpZGVbXT4ge1xyXG4gICAgY29uc3Qgc2xpZGVzOiBTbGlkZVtdID0gW11cclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IHNsaWRlIGNvdW50IGZyb20gcHJlc2VudGF0aW9uLnhtbFxyXG4gICAgICBjb25zdCBwcmVzZW50YXRpb24gPSB0aGlzLnppcD8uZmlsZSgncHB0L3ByZXNlbnRhdGlvbi54bWwnKVxyXG4gICAgICBpZiAocHJlc2VudGF0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHByZXNlbnRhdGlvbi5hc3luYygndGV4dCcpXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1ByZXNlbnRhdGlvbiBYTUwgY29udGVudDonLCBjb250ZW50LnN1YnN0cmluZygwLCA1MDApICsgJy4uLicpXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpXHJcbiAgICAgICAgY29uc3QgeG1sID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhjb250ZW50LCAndGV4dC94bWwnKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRyeSBtdWx0aXBsZSBhcHByb2FjaGVzIHRvIGZpbmQgc2xpZGVzXHJcbiAgICAgICAgbGV0IHNsaWRlSWRzID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzbGRJZCcpXHJcbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7c2xpZGVJZHMubGVuZ3RofSBzbGlkZXMgdXNpbmcgJ3NsZElkJyB0YWdgKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIG5vIHNsaWRlcyBmb3VuZCwgdHJ5IGFsdGVybmF0aXZlIGFwcHJvYWNoZXNcclxuICAgICAgICBpZiAoc2xpZGVJZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAvLyBUcnkgbG9va2luZyBmb3Igc2xpZGVzIGluIHRoZSBzbGlkZXMgZm9sZGVyIGRpcmVjdGx5XHJcbiAgICAgICAgICBjb25zdCBzbGlkZUZpbGVzID0gT2JqZWN0LmtleXModGhpcy56aXA/LmZpbGVzIHx8IHt9KVxyXG4gICAgICAgICAgICAuZmlsdGVyKG5hbWUgPT4gbmFtZS5zdGFydHNXaXRoKCdwcHQvc2xpZGVzL3NsaWRlJykgJiYgbmFtZS5lbmRzV2l0aCgnLnhtbCcpKVxyXG4gICAgICAgICAgICAuc29ydCgpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBzbGlkZSBmaWxlcyBkaXJlY3RseTonLCBzbGlkZUZpbGVzKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoc2xpZGVGaWxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzbGlkZXMgZnJvbSB0aGUgZmlsZXMgd2UgZm91bmRcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZUZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc2xpZGVGaWxlID0gc2xpZGVGaWxlc1tpXVxyXG4gICAgICAgICAgICAgIGNvbnN0IHNsaWRlTnVtYmVyID0gaSArIDFcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBzbGlkZSBmaWxlOiAke3NsaWRlRmlsZX1gKVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGNvbnN0IHNsaWRlID0gYXdhaXQgdGhpcy5yZWFkU2xpZGVGcm9tRmlsZShzbGlkZUZpbGUsIHNsaWRlTnVtYmVyKVxyXG4gICAgICAgICAgICAgIGlmIChzbGlkZSkge1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzLnB1c2goc2xpZGUpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGxvYWRlZCBzbGlkZSAke3NsaWRlTnVtYmVyfSBmcm9tIGZpbGVgKVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBQcm9jZXNzIHNsaWRlcyB1c2luZyB0aGUgdHJhZGl0aW9uYWwgbWV0aG9kXHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlSWQgPSBzbGlkZUlkc1tpXS5nZXRBdHRyaWJ1dGUoJ3I6aWQnKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBzbGlkZSAke2kgKyAxfSB3aXRoIElEOiAke3NsaWRlSWR9YClcclxuICAgICAgICAgICAgaWYgKHNsaWRlSWQpIHtcclxuICAgICAgICAgICAgICBjb25zdCBzbGlkZSA9IGF3YWl0IHRoaXMucmVhZFNsaWRlKHNsaWRlSWQsIGkgKyAxKVxyXG4gICAgICAgICAgICAgIGlmIChzbGlkZSkge1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzLnB1c2goc2xpZGUpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGxvYWRlZCBzbGlkZSAke2kgKyAxfWApXHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGxvYWQgc2xpZGUgJHtpICsgMX1gKVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmaW5kIHByZXNlbnRhdGlvbi54bWwnKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIHNsaWRlczonLCBlcnJvcilcclxuICAgICAgLy8gQ3JlYXRlIGEgZGVmYXVsdCBzbGlkZSBpZiBwYXJzaW5nIGZhaWxzXHJcbiAgICAgIHNsaWRlcy5wdXNoKHRoaXMuY3JlYXRlRGVmYXVsdFNsaWRlKCkpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBUb3RhbCBzbGlkZXMgbG9hZGVkOiAke3NsaWRlcy5sZW5ndGh9YClcclxuICAgIHJldHVybiBzbGlkZXMubGVuZ3RoID4gMCA/IHNsaWRlcyA6IFt0aGlzLmNyZWF0ZURlZmF1bHRTbGlkZSgpXVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyByZWFkU2xpZGUoc2xpZGVJZDogc3RyaW5nLCBzbGlkZU51bWJlcjogbnVtYmVyKTogUHJvbWlzZTxTbGlkZSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFRyeSB0byBmaW5kIHRoZSBzbGlkZSBmaWxlIGRpcmVjdGx5IGZpcnN0XHJcbiAgICAgIGxldCBzbGlkZUZpbGUgPSB0aGlzLnppcD8uZmlsZShgcHB0L3NsaWRlcy9zbGlkZSR7c2xpZGVOdW1iZXJ9LnhtbGApXHJcbiAgICAgIFxyXG4gICAgICAvLyBJZiBub3QgZm91bmQsIHRyeSB0byBmaW5kIGl0IHRocm91Z2ggcmVsYXRpb25zaGlwc1xyXG4gICAgICBpZiAoIXNsaWRlRmlsZSkge1xyXG4gICAgICAgIGNvbnN0IHNsaWRlUmVsID0gdGhpcy56aXA/LmZpbGUoYHBwdC9zbGlkZXMvX3JlbHMvc2xpZGUke3NsaWRlTnVtYmVyfS54bWwucmVsc2ApXHJcbiAgICAgICAgaWYgKHNsaWRlUmVsKSB7XHJcbiAgICAgICAgICBjb25zdCByZWxDb250ZW50ID0gYXdhaXQgc2xpZGVSZWwuYXN5bmMoJ3RleHQnKVxyXG4gICAgICAgICAgY29uc3QgcmVsUGFyc2VyID0gbmV3IERPTVBhcnNlcigpXHJcbiAgICAgICAgICBjb25zdCByZWxYbWwgPSByZWxQYXJzZXIucGFyc2VGcm9tU3RyaW5nKHJlbENvbnRlbnQsICd0ZXh0L3htbCcpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IHNsaWRlVGFyZ2V0ID0gcmVsWG1sLnF1ZXJ5U2VsZWN0b3IoYFJlbGF0aW9uc2hpcFtJZD1cIiR7c2xpZGVJZH1cIl1gKT8uZ2V0QXR0cmlidXRlKCdUYXJnZXQnKVxyXG4gICAgICAgICAgaWYgKHNsaWRlVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlUGF0aCA9IGBwcHQvc2xpZGVzLyR7c2xpZGVUYXJnZXQuc3BsaXQoJy8nKS5wb3AoKX1gXHJcbiAgICAgICAgICAgIHNsaWRlRmlsZSA9IHRoaXMuemlwPy5maWxlKHNsaWRlUGF0aClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIElmIHN0aWxsIG5vdCBmb3VuZCwgdHJ5IHRvIGZpbmQgYW55IHNsaWRlIGZpbGVcclxuICAgICAgaWYgKCFzbGlkZUZpbGUpIHtcclxuICAgICAgICBjb25zdCBzbGlkZUZpbGVzID0gT2JqZWN0LmtleXModGhpcy56aXA/LmZpbGVzIHx8IHt9KVxyXG4gICAgICAgICAgLmZpbHRlcihuYW1lID0+IG5hbWUuc3RhcnRzV2l0aCgncHB0L3NsaWRlcy9zbGlkZScpICYmIG5hbWUuZW5kc1dpdGgoJy54bWwnKSlcclxuICAgICAgICAgIC5zb3J0KClcclxuICAgICAgICBcclxuICAgICAgICBpZiAoc2xpZGVGaWxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCB0YXJnZXRTbGlkZSA9IHNsaWRlRmlsZXNbc2xpZGVOdW1iZXIgLSAxXSB8fCBzbGlkZUZpbGVzWzBdXHJcbiAgICAgICAgICBzbGlkZUZpbGUgPSB0aGlzLnppcD8uZmlsZSh0YXJnZXRTbGlkZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmICghc2xpZGVGaWxlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBzbGlkZSBmaWxlIGZvciBzbGlkZSAke3NsaWRlTnVtYmVyfWApXHJcbiAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3Qgc2xpZGVDb250ZW50ID0gYXdhaXQgc2xpZGVGaWxlLmFzeW5jKCd0ZXh0JylcclxuICAgICAgY29uc3Qgc2xpZGVQYXJzZXIgPSBuZXcgRE9NUGFyc2VyKClcclxuICAgICAgY29uc3Qgc2xpZGVYbWwgPSBzbGlkZVBhcnNlci5wYXJzZUZyb21TdHJpbmcoc2xpZGVDb250ZW50LCAndGV4dC94bWwnKVxyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBzbGlkZSBkaW1lbnNpb25zXHJcbiAgICAgIGNvbnN0IHNsZFN6ID0gc2xpZGVYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NsZFN6JylbMF1cclxuICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChzbGRTej8uZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICc5MTQ0MDAwJykgLyAxMjcwMCAvLyBDb252ZXJ0IEVNVXMgdG8gcGl4ZWxzXHJcbiAgICAgIGNvbnN0IGhlaWdodCA9IHBhcnNlSW50KHNsZFN6Py5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgJzY4NTgwMDAnKSAvIDEyNzAwXHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IHNoYXBlc1xyXG4gICAgICBjb25zdCBvYmplY3RzID0gYXdhaXQgdGhpcy5leHRyYWN0U2hhcGVzKHNsaWRlWG1sLCBzbGlkZU51bWJlcilcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgICAgICAgbmFtZTogYFNsaWRlICR7c2xpZGVOdW1iZXJ9YCxcclxuICAgICAgICB3aWR0aCxcclxuICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgb2JqZWN0cyxcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVhZGluZyBzbGlkZSAke3NsaWRlTnVtYmVyfTpgLCBlcnJvcilcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmVhZFNsaWRlRnJvbUZpbGUoc2xpZGVGaWxlUGF0aDogc3RyaW5nLCBzbGlkZU51bWJlcjogbnVtYmVyKTogUHJvbWlzZTxTbGlkZSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHNsaWRlRmlsZSA9IHRoaXMuemlwPy5maWxlKHNsaWRlRmlsZVBhdGgpXHJcbiAgICAgIGlmICghc2xpZGVGaWxlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBzbGlkZSBmaWxlOiAke3NsaWRlRmlsZVBhdGh9YClcclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzbGlkZUNvbnRlbnQgPSBhd2FpdCBzbGlkZUZpbGUuYXN5bmMoJ3RleHQnKVxyXG4gICAgICBjb25zb2xlLmxvZyhgU2xpZGUgJHtzbGlkZU51bWJlcn0gWE1MIGNvbnRlbnQ6YCwgc2xpZGVDb250ZW50LnN1YnN0cmluZygwLCAxMDAwKSArICcuLi4nKVxyXG4gICAgICBcclxuICAgICAgY29uc3Qgc2xpZGVQYXJzZXIgPSBuZXcgRE9NUGFyc2VyKClcclxuICAgICAgY29uc3Qgc2xpZGVYbWwgPSBzbGlkZVBhcnNlci5wYXJzZUZyb21TdHJpbmcoc2xpZGVDb250ZW50LCAndGV4dC94bWwnKVxyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBzbGlkZSBkaW1lbnNpb25zIHdpdGggYmV0dGVyIG5hbWVzcGFjZSBoYW5kbGluZ1xyXG4gICAgICBsZXQgc2xkU3ogPSBzbGlkZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2xkU3onKVswXVxyXG4gICAgICBpZiAoIXNsZFN6KSB7XHJcbiAgICAgICAgc2xkU3ogPSBzbGlkZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncDpzbGRTeicpWzBdXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGxldCB3aWR0aCA9IDgwMCwgaGVpZ2h0ID0gNjAwIC8vIERlZmF1bHQgZGltZW5zaW9uc1xyXG4gICAgICBpZiAoc2xkU3opIHtcclxuICAgICAgICBjb25zdCBjeCA9IHNsZFN6LmdldEF0dHJpYnV0ZSgnY3gnKVxyXG4gICAgICAgIGNvbnN0IGN5ID0gc2xkU3ouZ2V0QXR0cmlidXRlKCdjeScpXHJcbiAgICAgICAgY29uc29sZS5sb2coYFNsaWRlICR7c2xpZGVOdW1iZXJ9IGRpbWVuc2lvbnMgZnJvbSBYTUw6YCwgeyBjeCwgY3kgfSlcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY3ggJiYgY3kpIHtcclxuICAgICAgICAgIC8vIENvbnZlcnQgRU1VcyB0byBwaXhlbHNcclxuICAgICAgICAgIGNvbnN0IGVtdVRvUGl4ZWwgPSA5NiAvIDkxNDQwMFxyXG4gICAgICAgICAgd2lkdGggPSBwYXJzZUludChjeCkgKiBlbXVUb1BpeGVsXHJcbiAgICAgICAgICBoZWlnaHQgPSBwYXJzZUludChjeSkgKiBlbXVUb1BpeGVsXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2xpZGUgJHtzbGlkZU51bWJlcn0gY29udmVydGVkIGRpbWVuc2lvbnM6YCwgeyB3aWR0aCwgaGVpZ2h0IH0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gc2xkU3ogZm91bmQgaW4gc2xpZGUgJHtzbGlkZU51bWJlcn0sIHVzaW5nIGRlZmF1bHRzYClcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBzaGFwZXNcclxuICAgICAgY29uc3Qgb2JqZWN0cyA9IGF3YWl0IHRoaXMuZXh0cmFjdFNoYXBlcyhzbGlkZVhtbCwgc2xpZGVOdW1iZXIpXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gICAgICAgIG5hbWU6IGBTbGlkZSAke3NsaWRlTnVtYmVyfWAsXHJcbiAgICAgICAgd2lkdGg6IE1hdGgubWF4KHdpZHRoLCA4MDApLCAvLyBNaW5pbXVtIHdpZHRoXHJcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChoZWlnaHQsIDYwMCksIC8vIE1pbmltdW0gaGVpZ2h0XHJcbiAgICAgICAgb2JqZWN0cyxcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVhZGluZyBzbGlkZSBmcm9tIGZpbGUgJHtzbGlkZUZpbGVQYXRofTpgLCBlcnJvcilcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZXh0cmFjdFNoYXBlcyhzbGlkZVhtbDogRG9jdW1lbnQsIHNsaWRlTnVtYmVyOiBudW1iZXIpOiBQcm9taXNlPFNoYXBlT2JqZWN0W10+IHtcclxuICAgIGNvbnN0IG9iamVjdHM6IFNoYXBlT2JqZWN0W10gPSBbXVxyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGluZyBzaGFwZXMgZnJvbSBzbGlkZSAke3NsaWRlTnVtYmVyfWApXHJcbiAgICAgIFxyXG4gICAgICAvLyBUcnkgbXVsdGlwbGUgYXBwcm9hY2hlcyB0byBmaW5kIHNoYXBlc1xyXG4gICAgICBcclxuICAgICAgLy8gQXBwcm9hY2ggMTogTG9vayBmb3Igc3BUcmVlID4gc3AgKHRyYWRpdGlvbmFsIHN0cnVjdHVyZSlcclxuICAgICAgLy8gVXNlIGEgbW9yZSByb2J1c3QgYXBwcm9hY2ggdG8gaGFuZGxlIG5hbWVzcGFjZXNcclxuICAgICAgbGV0IHNwVHJlZSA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUoc2xpZGVYbWwsICdzcFRyZWUnKVxyXG4gICAgICBpZiAoc3BUcmVlKSB7XHJcbiAgICAgICAgY29uc3QgdGV4dEJveGVzID0gdGhpcy5maW5kRWxlbWVudHNCeVRhZ05hbWUoc3BUcmVlLCAnc3AnKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke3RleHRCb3hlcy5sZW5ndGh9IHNoYXBlIGVsZW1lbnRzIGluIHNwVHJlZWApXHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Qm94ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGNvbnN0IHRleHRCb3ggPSB0ZXh0Qm94ZXNbaV1cclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIHNoYXBlICR7aSArIDF9OmAsIHRleHRCb3gudGFnTmFtZSwgdGV4dEJveC5nZXRBdHRyaWJ1dGUoJ2lkJyksIHRleHRCb3guZ2V0QXR0cmlidXRlKCduYW1lJykpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgY29uc3QgbnZQciA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUodGV4dEJveCwgJ252UHInKVxyXG4gICAgICAgICAgY29uc3QgcGggPSBudlByID8gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShudlByLCAncGgnKSA6IG51bGxcclxuICAgICAgICAgIGlmIChwaCkge1xyXG4gICAgICAgICAgICBjb25zdCBwaFR5cGUgPSBwaC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgU2hhcGUgJHtpICsgMX0gaXMgYSBwbGFjZWhvbGRlciBvZiB0eXBlOiAke3BoVHlwZX1gKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuZXh0cmFjdFRleHRCb3godGV4dEJveCwgc2xpZGVOdW1iZXIsIGkpXHJcbiAgICAgICAgICBpZiAoc2hhcGUpIHtcclxuICAgICAgICAgICAgb2JqZWN0cy5wdXNoKHNoYXBlKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGV4dHJhY3RlZCBzaGFwZSAke2kgKyAxfTpgLCBzaGFwZS50eXBlLCBzaGFwZS5jb250ZW50IHx8ICdubyBjb250ZW50JylcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGV4dHJhY3Qgc2hhcGUgJHtpICsgMX1gKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ05vIHNwVHJlZSBmb3VuZCBpbiBzbGlkZScpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEFwcHJvYWNoIDI6IExvb2sgZm9yIHNoYXBlcyBkaXJlY3RseSBpbiB0aGUgc2xpZGVcclxuICAgICAgaWYgKG9iamVjdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1RyeWluZyBhbHRlcm5hdGl2ZSBzaGFwZSBleHRyYWN0aW9uLi4uJylcclxuICAgICAgICBcclxuICAgICAgICAvLyBMb29rIGZvciBhbnkgc3AgZWxlbWVudHMgYW55d2hlcmUgaW4gdGhlIHNsaWRlXHJcbiAgICAgICAgY29uc3QgYWxsU3BFbGVtZW50cyA9IHRoaXMuZmluZEVsZW1lbnRzQnlUYWdOYW1lKHNsaWRlWG1sLCAnc3AnKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2FsbFNwRWxlbWVudHMubGVuZ3RofSBzcCBlbGVtZW50cyBpbiBzbGlkZWApXHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxTcEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBzcEVsZW1lbnQgPSBhbGxTcEVsZW1lbnRzW2ldXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBzcCBlbGVtZW50ICR7aSArIDF9OmAsIHNwRWxlbWVudC50YWdOYW1lLCBzcEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuZXh0cmFjdFRleHRCb3goc3BFbGVtZW50LCBzbGlkZU51bWJlciwgaSlcclxuICAgICAgICAgIGlmIChzaGFwZSkge1xyXG4gICAgICAgICAgICBvYmplY3RzLnB1c2goc2hhcGUpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgZXh0cmFjdGVkIHNwIGVsZW1lbnQgJHtpICsgMX06YCwgc2hhcGUudHlwZSwgc2hhcGUuY29udGVudCB8fCAnbm8gY29udGVudCcpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBBcHByb2FjaCAzOiBMb29rIGZvciB0ZXh0IGVsZW1lbnRzIGRpcmVjdGx5XHJcbiAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUcnlpbmcgZGlyZWN0IHRleHQgZXh0cmFjdGlvbi4uLicpXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgdGV4dEVsZW1lbnRzID0gdGhpcy5maW5kRWxlbWVudHNCeVRhZ05hbWUoc2xpZGVYbWwsICd0JylcclxuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHt0ZXh0RWxlbWVudHMubGVuZ3RofSB0ZXh0IGVsZW1lbnRzIGRpcmVjdGx5IGluIHNsaWRlYClcclxuICAgICAgICBcclxuICAgICAgICBpZiAodGV4dEVsZW1lbnRzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIC8vIENyZWF0ZSBhIHNpbXBsZSB0ZXh0IG9iamVjdCBmcm9tIHRoZSBmaXJzdCB0ZXh0IGVsZW1lbnRcclxuICAgICAgICAgIGNvbnN0IGZpcnN0VGV4dCA9IHRleHRFbGVtZW50c1swXVxyXG4gICAgICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSBmaXJzdFRleHQudGV4dENvbnRlbnQgfHwgJ1RleHQnXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgQ3JlYXRpbmcgdGV4dCBvYmplY3Qgd2l0aCBjb250ZW50OiBcIiR7dGV4dENvbnRlbnR9XCJgKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCB0ZXh0T2JqZWN0OiBTaGFwZU9iamVjdCA9IHtcclxuICAgICAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcclxuICAgICAgICAgICAgdHJhbnNmb3JtOiB7XHJcbiAgICAgICAgICAgICAgbGVmdDogMTAwLFxyXG4gICAgICAgICAgICAgIHRvcDogMTAwLFxyXG4gICAgICAgICAgICAgIHdpZHRoOiAzMDAsXHJcbiAgICAgICAgICAgICAgaGVpZ2h0OiAxMDAsXHJcbiAgICAgICAgICAgICAgYW5nbGU6IDAsXHJcbiAgICAgICAgICAgICAgc2NhbGVYOiAxLFxyXG4gICAgICAgICAgICAgIHNjYWxlWTogMSxcclxuICAgICAgICAgICAgICBmbGlwWDogZmFsc2UsXHJcbiAgICAgICAgICAgICAgZmxpcFk6IGZhbHNlLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXHJcbiAgICAgICAgICAgICAgZm9udFNpemU6IDE4LFxyXG4gICAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxyXG4gICAgICAgICAgICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsXHJcbiAgICAgICAgICAgICAgdGV4dERlY29yYXRpb246ICdub25lJyxcclxuICAgICAgICAgICAgICBjb2xvcjogJyMwMDAwMDAnLFxyXG4gICAgICAgICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxyXG4gICAgICAgICAgICAgIGxpbmVIZWlnaHQ6IDEuMixcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgY29udGVudDogdGV4dENvbnRlbnQsXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIG9iamVjdHMucHVzaCh0ZXh0T2JqZWN0KVxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ0NyZWF0ZWQgZmFsbGJhY2sgdGV4dCBvYmplY3QnKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBpbWFnZXNcclxuICAgICAgY29uc3QgaW1hZ2VzID0gdGhpcy5maW5kRWxlbWVudHNCeVRhZ05hbWUoc2xpZGVYbWwsICdwaWMnKVxyXG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtpbWFnZXMubGVuZ3RofSBpbWFnZSBlbGVtZW50c2ApXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW1hZ2VzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSBpbWFnZXNbaV1cclxuICAgICAgICBjb25zdCBzaGFwZSA9IHRoaXMuZXh0cmFjdEltYWdlKGltYWdlLCBzbGlkZU51bWJlciwgaSlcclxuICAgICAgICBpZiAoc2hhcGUpIHtcclxuICAgICAgICAgIG9iamVjdHMucHVzaChzaGFwZSlcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgZXh0cmFjdGVkIGltYWdlICR7aSArIDF9YClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBUb3RhbCBvYmplY3RzIGV4dHJhY3RlZDogJHtvYmplY3RzLmxlbmd0aH1gKVxyXG4gICAgICBjb25zb2xlLmxvZygnRmluYWwgb2JqZWN0czonLCBvYmplY3RzLm1hcChvYmogPT4gKHsgdHlwZTogb2JqLnR5cGUsIGNvbnRlbnQ6IG9iai5jb250ZW50LCB0cmFuc2Zvcm06IG9iai50cmFuc2Zvcm0gfSkpKVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZXh0cmFjdGluZyBzaGFwZXM6JywgZXJyb3IpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBvYmplY3RzXHJcbiAgfVxyXG5cclxuICAvLyBIZWxwZXIgbWV0aG9kcyB0byBoYW5kbGUgWE1MIG5hbWVzcGFjZXNcclxuICBwcml2YXRlIGZpbmRFbGVtZW50QnlUYWdOYW1lKHBhcmVudDogRWxlbWVudCB8IERvY3VtZW50LCB0YWdOYW1lOiBzdHJpbmcpOiBFbGVtZW50IHwgbnVsbCB7XHJcbiAgICAvLyBUcnkgbXVsdGlwbGUgYXBwcm9hY2hlcyB0byBmaW5kIHRoZSBlbGVtZW50XHJcbiAgICBsZXQgZWxlbWVudCA9IHBhcmVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKVswXVxyXG4gICAgaWYgKGVsZW1lbnQpIHJldHVybiBlbGVtZW50XHJcbiAgICBcclxuICAgIC8vIElmIG5vdCBmb3VuZCwgdHJ5IHdpdGggY29tbW9uIG5hbWVzcGFjZSBwcmVmaXhlc1xyXG4gICAgY29uc3QgcHJlZml4ZXMgPSBbJ3A6JywgJ2E6JywgJ3I6JywgJyddXHJcbiAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xyXG4gICAgICBjb25zdCBmdWxsVGFnTmFtZSA9IHByZWZpeCArIHRhZ05hbWVcclxuICAgICAgZWxlbWVudCA9IHBhcmVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShmdWxsVGFnTmFtZSlbMF1cclxuICAgICAgaWYgKGVsZW1lbnQpIHJldHVybiBlbGVtZW50XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIExhc3QgcmVzb3J0OiBzZWFyY2ggYnkgcGFydGlhbCB0YWcgbmFtZVxyXG4gICAgY29uc3QgYWxsRWxlbWVudHMgPSBwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBlbCA9IGFsbEVsZW1lbnRzW2ldXHJcbiAgICAgIGlmIChlbC50YWdOYW1lLmVuZHNXaXRoKHRhZ05hbWUpIHx8IGVsLnRhZ05hbWUuaW5jbHVkZXModGFnTmFtZSkpIHtcclxuICAgICAgICByZXR1cm4gZWxcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBmaW5kRWxlbWVudHNCeVRhZ05hbWUocGFyZW50OiBFbGVtZW50IHwgRG9jdW1lbnQsIHRhZ05hbWU6IHN0cmluZyk6IEVsZW1lbnRbXSB7XHJcbiAgICAvLyBUcnkgbXVsdGlwbGUgYXBwcm9hY2hlcyB0byBmaW5kIGVsZW1lbnRzXHJcbiAgICBsZXQgZWxlbWVudHMgPSBBcnJheS5mcm9tKHBhcmVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSh0YWdOYW1lKSlcclxuICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSByZXR1cm4gZWxlbWVudHNcclxuICAgIFxyXG4gICAgLy8gSWYgbm90IGZvdW5kLCB0cnkgd2l0aCBjb21tb24gbmFtZXNwYWNlIHByZWZpeGVzXHJcbiAgICBjb25zdCBwcmVmaXhlcyA9IFsncDonLCAnYTonLCAncjonLCAnJ11cclxuICAgIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XHJcbiAgICAgIGNvbnN0IGZ1bGxUYWdOYW1lID0gcHJlZml4ICsgdGFnTmFtZVxyXG4gICAgICBlbGVtZW50cyA9IEFycmF5LmZyb20ocGFyZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKGZ1bGxUYWdOYW1lKSlcclxuICAgICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHJldHVybiBlbGVtZW50c1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBMYXN0IHJlc29ydDogc2VhcmNoIGJ5IHBhcnRpYWwgdGFnIG5hbWVcclxuICAgIGNvbnN0IGFsbEVsZW1lbnRzID0gcGFyZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJylcclxuICAgIGNvbnN0IG1hdGNoaW5nRWxlbWVudHM6IEVsZW1lbnRbXSA9IFtdXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGVsID0gYWxsRWxlbWVudHNbaV1cclxuICAgICAgaWYgKGVsLnRhZ05hbWUuZW5kc1dpdGgodGFnTmFtZSkgfHwgZWwudGFnTmFtZS5pbmNsdWRlcyh0YWdOYW1lKSkge1xyXG4gICAgICAgIG1hdGNoaW5nRWxlbWVudHMucHVzaChlbClcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gbWF0Y2hpbmdFbGVtZW50c1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBleHRyYWN0VGV4dEJveCh0ZXh0Qm94OiBFbGVtZW50LCBzbGlkZU51bWJlcjogbnVtYmVyLCBpbmRleDogbnVtYmVyKTogU2hhcGVPYmplY3QgfCBudWxsIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBFeHRyYWN0aW5nIHRleHQgYm94ICR7aW5kZXggKyAxfSBmcm9tIHNsaWRlICR7c2xpZGVOdW1iZXJ9YClcclxuICAgICAgY29uc29sZS5sb2coJ1RleHQgYm94IGVsZW1lbnQ6JywgdGV4dEJveC5vdXRlckhUTUwuc3Vic3RyaW5nKDAsIDUwMCkgKyAnLi4uJylcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHNwUHIgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHRleHRCb3gsICdzcFByJylcclxuICAgICAgaWYgKCFzcFByKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBObyBzcFByIGZvdW5kIGluIHRleHQgYm94ICR7aW5kZXggKyAxfWApXHJcbiAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhY3R1YWxseSBhIHRleHQgc2hhcGUgb3IgYSBkaWZmZXJlbnQgdHlwZVxyXG4gICAgICBjb25zdCB0eEJvZHkgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHRleHRCb3gsICd0eEJvZHknKVxyXG4gICAgICBjb25zdCBoYXNUZXh0ID0gdHhCb2R5ICYmIHRoaXMuZmluZEVsZW1lbnRzQnlUYWdOYW1lKHR4Qm9keSwgJ3QnKS5sZW5ndGggPiAwXHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcGxhY2Vob2xkZXIgb3Igc2hhcGUgd2l0aCB0ZXh0XHJcbiAgICAgIGNvbnN0IG52UHIgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHRleHRCb3gsICdudlByJylcclxuICAgICAgY29uc3QgcGggPSBudlByID8gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShudlByLCAncGgnKSA6IG51bGxcclxuICAgICAgY29uc3QgaXNQbGFjZWhvbGRlciA9IHBoICYmIHBoLmdldEF0dHJpYnV0ZSgndHlwZScpXHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayB0aGUgYWN0dWFsIHNoYXBlIHR5cGUgZnJvbSBzcFByXHJcbiAgICAgIGNvbnN0IHByc3RHZW9tID0gc3BQci5nZXRFbGVtZW50c0J5VGFnTmFtZSgncHJzdEdlb20nKVswXSB8fCBzcFByLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhOnByc3RHZW9tJylbMF1cclxuICAgICAgY29uc3Qgc2hhcGVUeXBlID0gcHJzdEdlb20/LmdldEF0dHJpYnV0ZSgncHJzdCcpXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhgU2hhcGUgJHtpbmRleCArIDF9IC0gaGFzVGV4dDogJHtoYXNUZXh0fSwgaXNQbGFjZWhvbGRlcjogJHtpc1BsYWNlaG9sZGVyfSwgc2hhcGVUeXBlOiAke3NoYXBlVHlwZX1gKVxyXG4gICAgICBcclxuICAgICAgLy8gSWYgdGhpcyBpcyBhIHJlY3RhbmdsZSwgZWxsaXBzZSwgb3Igb3RoZXIgc2hhcGUgKG5vdCB0ZXh0KSwgZXh0cmFjdCBhcyBiYXNpYyBzaGFwZVxyXG4gICAgICBpZiAoc2hhcGVUeXBlICYmIFsncmVjdCcsICdyb3VuZFJlY3QnLCAnZWxsaXBzZScsICdvdmFsJywgJ2xpbmUnXS5pbmNsdWRlcyhzaGFwZVR5cGUpKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coYFNoYXBlICR7aW5kZXggKyAxfSBpcyBhICR7c2hhcGVUeXBlfSwgdHJlYXRpbmcgYXMgYmFzaWMgc2hhcGVgKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RCYXNpY1NoYXBlKHRleHRCb3gsIHNsaWRlTnVtYmVyLCBpbmRleClcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gSWYgdGhpcyBoYXMgbm8gdGV4dCBhbmQgaXMgbm90IGEgcGxhY2Vob2xkZXIsIHRyZWF0IGFzIGJhc2ljIHNoYXBlXHJcbiAgICAgIGlmICghaGFzVGV4dCAmJiAhaXNQbGFjZWhvbGRlcikge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBTaGFwZSAke2luZGV4ICsgMX0gaGFzIG5vIHRleHQgYW5kIGlzIG5vdCBhIHBsYWNlaG9sZGVyLCB0cmVhdGluZyBhcyBiYXNpYyBzaGFwZWApXHJcbiAgICAgICAgcmV0dXJuIHRoaXMuZXh0cmFjdEJhc2ljU2hhcGUodGV4dEJveCwgc2xpZGVOdW1iZXIsIGluZGV4KVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLmV4dHJhY3RUcmFuc2Zvcm0oc3BQcilcclxuICAgICAgY29uc3QgdGV4dENvbnRlbnQgPSB0aGlzLmV4dHJhY3RUZXh0Q29udGVudCh0ZXh0Qm94KVxyXG4gICAgICBjb25zdCB0ZXh0U3R5bGUgPSB0aGlzLmV4dHJhY3RUZXh0U3R5bGUodGV4dEJveClcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBFeHRyYWN0ZWQgdGV4dCBib3g6IGNvbnRlbnQ9XCIke3RleHRDb250ZW50fVwiLCB0cmFuc2Zvcm09YCwgdHJhbnNmb3JtKVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgICB0eXBlOiAndGV4dCcsXHJcbiAgICAgICAgdHJhbnNmb3JtLFxyXG4gICAgICAgIHN0eWxlOiB0ZXh0U3R5bGUsXHJcbiAgICAgICAgY29udGVudDogdGV4dENvbnRlbnQsXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGV4dHJhY3RpbmcgdGV4dCBib3g6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGV4dHJhY3RJbWFnZShpbWFnZTogRWxlbWVudCwgc2xpZGVOdW1iZXI6IG51bWJlciwgaW5kZXg6IG51bWJlcik6IFNoYXBlT2JqZWN0IHwgbnVsbCB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzcFByID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShpbWFnZSwgJ3NwUHInKVxyXG4gICAgICBpZiAoIXNwUHIpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLmV4dHJhY3RUcmFuc2Zvcm0oc3BQcilcclxuICAgICAgXHJcbiAgICAgIC8vIEZvciBub3csIHdlJ2xsIGNyZWF0ZSBhIHBsYWNlaG9sZGVyIGltYWdlXHJcbiAgICAgIC8vIEluIGEgcmVhbCBpbXBsZW1lbnRhdGlvbiwgeW91J2QgZXh0cmFjdCB0aGUgYWN0dWFsIGltYWdlIGRhdGFcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgICB0eXBlOiAnaW1hZ2UnLFxyXG4gICAgICAgIHRyYW5zZm9ybSxcclxuICAgICAgICBzdHlsZToge30sXHJcbiAgICAgICAgc3JjOiBgZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCwke2J0b2EoJzxzdmcgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCI+PHJlY3Qgd2lkdGg9XCIxMDBcIiBoZWlnaHQ9XCIxMDBcIiBmaWxsPVwiI2NjY1wiLz48dGV4dCB4PVwiNTBcIiB5PVwiNTBcIiB0ZXh0LWFuY2hvcj1cIm1pZGRsZVwiIGR5PVwiLjNlbVwiPkltYWdlPC90ZXh0Pjwvc3ZnPicpfWAsXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGV4dHJhY3RpbmcgaW1hZ2U6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGV4dHJhY3RCYXNpY1NoYXBlKHNoYXBlOiBFbGVtZW50LCBzbGlkZU51bWJlcjogbnVtYmVyLCBpbmRleDogbnVtYmVyKTogU2hhcGVPYmplY3QgfCBudWxsIHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKGBFeHRyYWN0aW5nIGJhc2ljIHNoYXBlICR7aW5kZXggKyAxfSBmcm9tIHNsaWRlICR7c2xpZGVOdW1iZXJ9YClcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHNwUHIgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHNoYXBlLCAnc3BQcicpXHJcbiAgICAgIGlmICghc3BQcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gc3BQciBmb3VuZCBpbiBiYXNpYyBzaGFwZSAke2luZGV4ICsgMX1gKVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHRoaXMuZXh0cmFjdFRyYW5zZm9ybShzcFByKVxyXG4gICAgICBcclxuICAgICAgLy8gR2V0IHRoZSBhY3R1YWwgc2hhcGUgdHlwZSBmcm9tIHRoZSBYTUxcclxuICAgICAgbGV0IHByc3RHZW9tID0gc3BQci5nZXRFbGVtZW50c0J5VGFnTmFtZSgncHJzdEdlb20nKVswXVxyXG4gICAgICBpZiAoIXByc3RHZW9tKSB7XHJcbiAgICAgICAgcHJzdEdlb20gPSBzcFByLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhOnByc3RHZW9tJylbMF1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgbGV0IHNoYXBlVHlwZTogJ3JlY3RhbmdsZScgfCAnZWxsaXBzZScgfCAnbGluZScgPSAncmVjdGFuZ2xlJ1xyXG4gICAgICBpZiAocHJzdEdlb20pIHtcclxuICAgICAgICBjb25zdCBwcnN0ID0gcHJzdEdlb20uZ2V0QXR0cmlidXRlKCdwcnN0JylcclxuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgc2hhcGUgdHlwZSBpbiBYTUw6ICR7cHJzdH1gKVxyXG4gICAgICAgIFxyXG4gICAgICAgIHN3aXRjaCAocHJzdCkge1xyXG4gICAgICAgICAgY2FzZSAncmVjdCc6XHJcbiAgICAgICAgICBjYXNlICdyb3VuZFJlY3QnOlxyXG4gICAgICAgICAgICBzaGFwZVR5cGUgPSAncmVjdGFuZ2xlJ1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSAnZWxsaXBzZSc6XHJcbiAgICAgICAgICBjYXNlICdvdmFsJzpcclxuICAgICAgICAgICAgc2hhcGVUeXBlID0gJ2VsbGlwc2UnXHJcbiAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICBjYXNlICdsaW5lJzpcclxuICAgICAgICAgIGNhc2UgJ3N0cmFpZ2h0Q29ubmVjdG9yMSc6XHJcbiAgICAgICAgICAgIHNoYXBlVHlwZSA9ICdsaW5lJ1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFVua25vd24gc2hhcGUgdHlwZTogJHtwcnN0fSwgZGVmYXVsdGluZyB0byByZWN0YW5nbGVgKVxyXG4gICAgICAgICAgICBzaGFwZVR5cGUgPSAncmVjdGFuZ2xlJ1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYEV4dHJhY3RlZCBiYXNpYyBzaGFwZTogdHlwZT0ke3NoYXBlVHlwZX0sIHRyYW5zZm9ybT1gLCB0cmFuc2Zvcm0pXHJcbiAgICAgIFxyXG4gICAgICAvLyBGb3IgYmFzaWMgc2hhcGVzLCB3ZSBtaWdodCBzdGlsbCBoYXZlIHNvbWUgdGV4dCBjb250ZW50IChsaWtlIHBsYWNlaG9sZGVycylcclxuICAgICAgbGV0IGNvbnRlbnQgPSAnJ1xyXG4gICAgICBjb25zdCB0eEJvZHkgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHNoYXBlLCAndHhCb2R5JylcclxuICAgICAgaWYgKHR4Qm9keSkge1xyXG4gICAgICAgIGNvbnRlbnQgPSB0aGlzLmV4dHJhY3RUZXh0Q29udGVudChzaGFwZSlcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHBsYWNlaG9sZGVyXHJcbiAgICAgIGNvbnN0IG52UHIgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHNoYXBlLCAnbnZQcicpXHJcbiAgICAgIGNvbnN0IHBoID0gbnZQciA/IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUobnZQciwgJ3BoJykgOiBudWxsXHJcbiAgICAgIGlmIChwaCkge1xyXG4gICAgICAgIGNvbnN0IHBoVHlwZSA9IHBoLmdldEF0dHJpYnV0ZSgndHlwZScpXHJcbiAgICAgICAgaWYgKHBoVHlwZSA9PT0gJ3RpdGxlJykge1xyXG4gICAgICAgICAgY29udGVudCA9ICdUaXRsZSBQbGFjZWhvbGRlcidcclxuICAgICAgICB9IGVsc2UgaWYgKHBoVHlwZSA9PT0gJ2JvZHknKSB7XHJcbiAgICAgICAgICBjb250ZW50ID0gJ0JvZHkgUGxhY2Vob2xkZXInXHJcbiAgICAgICAgfSBlbHNlIGlmIChwaFR5cGUgPT09ICdwaWMnKSB7XHJcbiAgICAgICAgICBjb250ZW50ID0gJ1BpY3R1cmUgUGxhY2Vob2xkZXInXHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIGNvbnRlbnQgPSAnQ29udGVudCBQbGFjZWhvbGRlcidcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEdldCBzaGFwZSBuYW1lIGZvciBiZXR0ZXIgaWRlbnRpZmljYXRpb25cclxuICAgICAgY29uc3QgY052UHIgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHNoYXBlLCAnY052UHInKVxyXG4gICAgICBjb25zdCBzaGFwZU5hbWUgPSBjTnZQcj8uZ2V0QXR0cmlidXRlKCduYW1lJykgfHwgYFNoYXBlICR7aW5kZXggKyAxfWBcclxuICAgICAgY29uc29sZS5sb2coYFNoYXBlIG5hbWU6ICR7c2hhcGVOYW1lfWApXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gICAgICAgIHR5cGU6IHNoYXBlVHlwZSxcclxuICAgICAgICB0cmFuc2Zvcm0sXHJcbiAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgIGZpbGw6IHNoYXBlVHlwZSA9PT0gJ2xpbmUnID8gJ3RyYW5zcGFyZW50JyA6ICcjZTVlN2ViJywgLy8gRGVmYXVsdCBsaWdodCBncmF5IGZpbGwgZm9yIHNoYXBlc1xyXG4gICAgICAgICAgc3Ryb2tlOiAnIzZiNzI4MCcsIC8vIERlZmF1bHQgYm9yZGVyIGNvbG9yXHJcbiAgICAgICAgICBzdHJva2VXaWR0aDogc2hhcGVUeXBlID09PSAnbGluZScgPyAyIDogMSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGNvbnRlbnQ6IGNvbnRlbnQgfHwgdW5kZWZpbmVkLCAvLyBPbmx5IGluY2x1ZGUgY29udGVudCBpZiBpdCBleGlzdHNcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZXh0cmFjdGluZyBiYXNpYyBzaGFwZTonLCBlcnJvcilcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZXh0cmFjdFRyYW5zZm9ybShzcFByOiBFbGVtZW50KTogVHJhbnNmb3JtIHtcclxuICAgIC8vIERlYnVnIHRoZSBzcFByIGVsZW1lbnQgc3RydWN0dXJlXHJcbiAgICBjb25zb2xlLmxvZygnRXh0cmFjdGluZyB0cmFuc2Zvcm0gZnJvbSBzcFByOicsIHNwUHIub3V0ZXJIVE1MLnN1YnN0cmluZygwLCA1MDApICsgJy4uLicpXHJcbiAgICBcclxuICAgIC8vIFRyeSB0byBmaW5kIHhmcm0gZWxlbWVudCB3aXRoIGJldHRlciBuYW1lc3BhY2UgaGFuZGxpbmdcclxuICAgIGxldCB4ZnJtID0gc3BQci5nZXRFbGVtZW50c0J5VGFnTmFtZSgneGZybScpWzBdXHJcbiAgICBpZiAoIXhmcm0pIHtcclxuICAgICAgLy8gVHJ5IHdpdGggbmFtZXNwYWNlIHByZWZpeGVzXHJcbiAgICAgIHhmcm0gPSBzcFByLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhOnhmcm0nKVswXVxyXG4gICAgfVxyXG4gICAgaWYgKCF4ZnJtKSB7XHJcbiAgICAgIC8vIFRyeSBzZWFyY2hpbmcgYnkgcGFydGlhbCB0YWcgbmFtZVxyXG4gICAgICBjb25zdCBhbGxFbGVtZW50cyA9IHNwUHIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZWwgPSBhbGxFbGVtZW50c1tpXVxyXG4gICAgICAgIGlmIChlbC50YWdOYW1lLmluY2x1ZGVzKCd4ZnJtJykpIHtcclxuICAgICAgICAgIHhmcm0gPSBlbFxyXG4gICAgICAgICAgYnJlYWtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ0ZvdW5kIHhmcm0gZWxlbWVudDonLCB4ZnJtPy5vdXRlckhUTUwpXHJcbiAgICBcclxuICAgIGlmICh4ZnJtKSB7XHJcbiAgICAgIC8vIEZpbmQgb2Zmc2V0LCBleHRlbnQsIGFuZCByb3RhdGlvbiB3aXRoIGJldHRlciBuYW1lc3BhY2UgaGFuZGxpbmdcclxuICAgICAgbGV0IG9mZiA9IHhmcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ29mZicpWzBdXHJcbiAgICAgIGlmICghb2ZmKSBvZmYgPSB4ZnJtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhOm9mZicpWzBdXHJcbiAgICAgIFxyXG4gICAgICBsZXQgZXh0ID0geGZybS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZXh0JylbMF1cclxuICAgICAgaWYgKCFleHQpIGV4dCA9IHhmcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2E6ZXh0JylbMF1cclxuICAgICAgXHJcbiAgICAgIGxldCByb3QgPSB4ZnJtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdyb3QnKVswXVxyXG4gICAgICBpZiAoIXJvdCkgcm90ID0geGZybS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYTpyb3QnKVswXVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ1RyYW5zZm9ybSBlbGVtZW50cyAtIG9mZjonLCBvZmY/Lm91dGVySFRNTCwgJ2V4dDonLCBleHQ/Lm91dGVySFRNTCwgJ3JvdDonLCByb3Q/Lm91dGVySFRNTClcclxuICAgICAgXHJcbiAgICAgIC8vIENvbnZlcnQgRU1VcyB0byBwaXhlbHMgd2l0aCBiZXR0ZXIgc2NhbGluZ1xyXG4gICAgICAvLyAxIEVNVSA9IDEvOTE0NDAwIGluY2gsIDEgaW5jaCA9IDk2IHBpeGVscyAoc3RhbmRhcmQgRFBJKVxyXG4gICAgICAvLyBTbyAxIEVNVSA9IDk2LzkxNDQwMCA9IDAuMDAwMTA1IHBpeGVsc1xyXG4gICAgICAvLyBGb3IgYmV0dGVyIHZpc2liaWxpdHksIHdlJ2xsIHNjYWxlIHRoaXMgdXBcclxuICAgICAgY29uc3QgZW11VG9QaXhlbCA9IDk2IC8gOTE0NDAwXHJcbiAgICAgIGNvbnN0IHNjYWxlRmFjdG9yID0gMSAvLyBBZGp1c3QgdGhpcyB0byBtYWtlIHNoYXBlcyBiaWdnZXIvc21hbGxlclxyXG4gICAgICBcclxuICAgICAgY29uc3QgbGVmdCA9IHBhcnNlSW50KG9mZj8uZ2V0QXR0cmlidXRlKCd4JykgfHwgJzAnKSAqIGVtdVRvUGl4ZWwgKiBzY2FsZUZhY3RvclxyXG4gICAgICBjb25zdCB0b3AgPSBwYXJzZUludChvZmY/LmdldEF0dHJpYnV0ZSgneScpIHx8ICcwJykgKiBlbXVUb1BpeGVsICogc2NhbGVGYWN0b3JcclxuICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChleHQ/LmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAnMTAwMDAwMCcpICogZW11VG9QaXhlbCAqIHNjYWxlRmFjdG9yXHJcbiAgICAgIGNvbnN0IGhlaWdodCA9IHBhcnNlSW50KGV4dD8uZ2V0QXR0cmlidXRlKCdjeScpIHx8ICcxMDAwMDAwJykgKiBlbXVUb1BpeGVsICogc2NhbGVGYWN0b3JcclxuICAgICAgY29uc3QgYW5nbGUgPSBwYXJzZUludChyb3Q/LmdldEF0dHJpYnV0ZSgndmFsJykgfHwgJzAnKSAvIDYwMDAwIC8vIENvbnZlcnQgNjBrdGhzIHRvIGRlZ3JlZXNcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IHtcclxuICAgICAgICBsZWZ0OiBNYXRoLm1heCgwLCBsZWZ0KSxcclxuICAgICAgICB0b3A6IE1hdGgubWF4KDAsIHRvcCksXHJcbiAgICAgICAgd2lkdGg6IE1hdGgubWF4KDUwLCB3aWR0aCksIC8vIE1pbmltdW0gd2lkdGggb2YgNTBweFxyXG4gICAgICAgIGhlaWdodDogTWF0aC5tYXgoNTAsIGhlaWdodCksIC8vIE1pbmltdW0gaGVpZ2h0IG9mIDUwcHhcclxuICAgICAgICBhbmdsZSxcclxuICAgICAgICBzY2FsZVg6IDEsXHJcbiAgICAgICAgc2NhbGVZOiAxLFxyXG4gICAgICAgIGZsaXBYOiBmYWxzZSxcclxuICAgICAgICBmbGlwWTogZmFsc2UsXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0ZWQgdHJhbnNmb3JtIChFTVUgdmFsdWVzKTonLCB7XHJcbiAgICAgICAgZW11TGVmdDogb2ZmPy5nZXRBdHRyaWJ1dGUoJ3gnKSxcclxuICAgICAgICBlbXVUb3A6IG9mZj8uZ2V0QXR0cmlidXRlKCd5JyksXHJcbiAgICAgICAgZW11V2lkdGg6IGV4dD8uZ2V0QXR0cmlidXRlKCdjeCcpLFxyXG4gICAgICAgIGVtdUhlaWdodDogZXh0Py5nZXRBdHRyaWJ1dGUoJ2N5JylcclxuICAgICAgfSlcclxuICAgICAgY29uc29sZS5sb2coJ0NvbnZlcnRlZCB0cmFuc2Zvcm0gKHBpeGVscyk6JywgdHJhbnNmb3JtKVxyXG4gICAgICByZXR1cm4gdHJhbnNmb3JtXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUud2FybignTm8geGZybSBmb3VuZCwgdXNpbmcgZGVmYXVsdCB0cmFuc2Zvcm0nKVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgbGVmdDogMTAwLFxyXG4gICAgICB0b3A6IDEwMCxcclxuICAgICAgd2lkdGg6IDIwMCxcclxuICAgICAgaGVpZ2h0OiAxNTAsXHJcbiAgICAgIGFuZ2xlOiAwLFxyXG4gICAgICBzY2FsZVg6IDEsXHJcbiAgICAgIHNjYWxlWTogMSxcclxuICAgICAgZmxpcFg6IGZhbHNlLFxyXG4gICAgICBmbGlwWTogZmFsc2UsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGV4dHJhY3RUZXh0Q29udGVudCh0ZXh0Qm94OiBFbGVtZW50KTogc3RyaW5nIHtcclxuICAgIC8vIFRyeSBtdWx0aXBsZSBhcHByb2FjaGVzIHRvIGZpbmQgdGV4dCBjb250ZW50XHJcbiAgICBsZXQgY29udGVudCA9ICcnXHJcbiAgICBcclxuICAgIC8vIEZpcnN0IHRyeTogbG9vayBmb3IgdGV4dCBpbiB0eEJvZHkgPiBwID4gciA+IHRcclxuICAgIGNvbnN0IHR4Qm9keSA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUodGV4dEJveCwgJ3R4Qm9keScpXHJcbiAgICBpZiAodHhCb2R5KSB7XHJcbiAgICAgIGNvbnN0IHBhcmFncmFwaHMgPSB0aGlzLmZpbmRFbGVtZW50c0J5VGFnTmFtZSh0eEJvZHksICdwJylcclxuICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7cGFyYWdyYXBocy5sZW5ndGh9IHBhcmFncmFwaHMgaW4gdGV4dCBib3hgKVxyXG4gICAgICBcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhZ3JhcGhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gcGFyYWdyYXBoc1tpXVxyXG4gICAgICAgIGNvbnN0IHRleHRSdW5zID0gdGhpcy5maW5kRWxlbWVudHNCeVRhZ05hbWUocGFyYWdyYXBoLCAncicpXHJcbiAgICAgICAgY29uc29sZS5sb2coYFBhcmFncmFwaCAke2kgKyAxfSBoYXMgJHt0ZXh0UnVucy5sZW5ndGh9IHRleHQgcnVuc2ApXHJcbiAgICAgICAgXHJcbiAgICAgICAgbGV0IHBhcmFncmFwaFRleHQgPSAnJ1xyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGV4dFJ1bnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIGNvbnN0IHRleHRSdW4gPSB0ZXh0UnVuc1tqXVxyXG4gICAgICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHRleHRSdW4sICd0JylcclxuICAgICAgICAgIGlmICh0ZXh0RWxlbWVudCAmJiB0ZXh0RWxlbWVudC50ZXh0Q29udGVudCkge1xyXG4gICAgICAgICAgICBwYXJhZ3JhcGhUZXh0ICs9IHRleHRFbGVtZW50LnRleHRDb250ZW50XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBUZXh0IHJ1biAke2ogKyAxfTogXCIke3RleHRFbGVtZW50LnRleHRDb250ZW50fVwiYClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQWRkIHBhcmFncmFwaCB0ZXh0IHRvIGNvbnRlbnRcclxuICAgICAgICBpZiAocGFyYWdyYXBoVGV4dCkge1xyXG4gICAgICAgICAgaWYgKGNvbnRlbnQpIGNvbnRlbnQgKz0gJ1xcbicgLy8gQWRkIGxpbmUgYnJlYWsgYmV0d2VlbiBwYXJhZ3JhcGhzXHJcbiAgICAgICAgICBjb250ZW50ICs9IHBhcmFncmFwaFRleHRcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gU2Vjb25kIHRyeTogbG9vayBmb3IgdGV4dCBkaXJlY3RseSBpbiB0aGUgdGV4dEJveFxyXG4gICAgaWYgKCFjb250ZW50KSB7XHJcbiAgICAgIGNvbnN0IHRleHRFbGVtZW50cyA9IHRoaXMuZmluZEVsZW1lbnRzQnlUYWdOYW1lKHRleHRCb3gsICd0JylcclxuICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7dGV4dEVsZW1lbnRzLmxlbmd0aH0gdGV4dCBlbGVtZW50cyBkaXJlY3RseSBpbiB0ZXh0IGJveGApXHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRleHRFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGVsZW1lbnQgPSB0ZXh0RWxlbWVudHNbaV1cclxuICAgICAgICBpZiAoZWxlbWVudC50ZXh0Q29udGVudCkge1xyXG4gICAgICAgICAgaWYgKGNvbnRlbnQpIGNvbnRlbnQgKz0gJ1xcbidcclxuICAgICAgICAgIGNvbnRlbnQgKz0gZWxlbWVudC50ZXh0Q29udGVudFxyXG4gICAgICAgICAgY29uc29sZS5sb2coYERpcmVjdCB0ZXh0IGVsZW1lbnQgJHtpICsgMX06IFwiJHtlbGVtZW50LnRleHRDb250ZW50fVwiYClcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVGhpcmQgdHJ5OiBsb29rIGZvciBhbnkgdGV4dCBjb250ZW50IGluIHRoZSBlbGVtZW50XHJcbiAgICBpZiAoIWNvbnRlbnQpIHtcclxuICAgICAgY29udGVudCA9IHRleHRCb3gudGV4dENvbnRlbnQgfHwgJydcclxuICAgICAgY29uc29sZS5sb2coYEZhbGxiYWNrIHRleHQgY29udGVudDogXCIke2NvbnRlbnR9XCJgKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhgRmluYWwgZXh0cmFjdGVkIHRleHQgY29udGVudDogXCIke2NvbnRlbnR9XCJgKVxyXG4gICAgcmV0dXJuIGNvbnRlbnQgfHwgJ1RleHQgQm94J1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBleHRyYWN0VGV4dFN0eWxlKHRleHRCb3g6IEVsZW1lbnQpOiBQYXJ0aWFsPFRleHRTdHlsZT4ge1xyXG4gICAgY29uc3QgZGVmUlByID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZSh0ZXh0Qm94LCAnZGVmUlByJylcclxuICAgIFxyXG4gICAgaWYgKGRlZlJQcikge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGZvbnRGYW1pbHk6IGRlZlJQci5nZXRBdHRyaWJ1dGUoJ3R5cGVmYWNlJykgfHwgJ0FyaWFsJyxcclxuICAgICAgICBmb250U2l6ZTogcGFyc2VJbnQoZGVmUlByLmdldEF0dHJpYnV0ZSgnc3onKSB8fCAnMTgwMCcpIC8gMTAwLCAvLyBDb252ZXJ0IDEwMHRocyB0byBwb2ludHNcclxuICAgICAgICBmb250V2VpZ2h0OiBkZWZSUHIuZ2V0QXR0cmlidXRlKCdiJykgPT09ICcxJyA/ICdib2xkJyA6ICdub3JtYWwnLFxyXG4gICAgICAgIGZvbnRTdHlsZTogZGVmUlByLmdldEF0dHJpYnV0ZSgnaScpID09PSAnMScgPyAnaXRhbGljJyA6ICdub3JtYWwnLFxyXG4gICAgICAgIHRleHREZWNvcmF0aW9uOiBkZWZSUHIuZ2V0QXR0cmlidXRlKCd1JykgPT09ICcxJyA/ICd1bmRlcmxpbmUnIDogJ25vbmUnLFxyXG4gICAgICAgIGNvbG9yOiB0aGlzLmV4dHJhY3RDb2xvcihkZWZSUHIpLFxyXG4gICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxyXG4gICAgICAgIGxpbmVIZWlnaHQ6IDEuMixcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxyXG4gICAgICBmb250U2l6ZTogMTgsXHJcbiAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxyXG4gICAgICBmb250U3R5bGU6ICdub3JtYWwnLFxyXG4gICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxyXG4gICAgICBjb2xvcjogJyMwMDAwMDAnLFxyXG4gICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcclxuICAgICAgbGluZUhlaWdodDogMS4yLFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBleHRyYWN0Q29sb3IoZGVmUlByOiBFbGVtZW50KTogc3RyaW5nIHtcclxuICAgIGNvbnN0IHNvbGlkRmlsbCA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUoZGVmUlByLCAnc29saWRGaWxsJylcclxuICAgIGlmIChzb2xpZEZpbGwpIHtcclxuICAgICAgY29uc3Qgc3JnYkNsciA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUoc29saWRGaWxsLCAnc3JnYkNscicpXHJcbiAgICAgIGlmIChzcmdiQ2xyKSB7XHJcbiAgICAgICAgY29uc3QgdmFsID0gc3JnYkNsci5nZXRBdHRyaWJ1dGUoJ3ZhbCcpXHJcbiAgICAgICAgaWYgKHZhbCkge1xyXG4gICAgICAgICAgcmV0dXJuIGAjJHt2YWx9YFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuICcjMDAwMDAwJ1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBkZXRlcm1pbmVTaGFwZVR5cGUoc3BQcjogRWxlbWVudCk6ICdyZWN0YW5nbGUnIHwgJ2VsbGlwc2UnIHwgJ2xpbmUnIHtcclxuICAgIC8vIFRyeSB0byBmaW5kIHByc3RHZW9tIGVsZW1lbnQgd2l0aCBiZXR0ZXIgbmFtZXNwYWNlIGhhbmRsaW5nXHJcbiAgICBsZXQgcHJzdEdlb20gPSBzcFByLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdwcnN0R2VvbScpWzBdXHJcbiAgICBpZiAoIXByc3RHZW9tKSB7XHJcbiAgICAgIHByc3RHZW9tID0gc3BQci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYTpwcnN0R2VvbScpWzBdXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmIChwcnN0R2VvbSkge1xyXG4gICAgICBjb25zdCBwcnN0ID0gcHJzdEdlb20uZ2V0QXR0cmlidXRlKCdwcnN0JylcclxuICAgICAgY29uc29sZS5sb2coYEZvdW5kIHNoYXBlIHR5cGU6ICR7cHJzdH1gKVxyXG4gICAgICBcclxuICAgICAgc3dpdGNoIChwcnN0KSB7XHJcbiAgICAgICAgY2FzZSAncmVjdCc6XHJcbiAgICAgICAgY2FzZSAncm91bmRSZWN0JzpcclxuICAgICAgICAgIHJldHVybiAncmVjdGFuZ2xlJ1xyXG4gICAgICAgIGNhc2UgJ2VsbGlwc2UnOlxyXG4gICAgICAgIGNhc2UgJ292YWwnOlxyXG4gICAgICAgICAgcmV0dXJuICdlbGxpcHNlJ1xyXG4gICAgICAgIGNhc2UgJ2xpbmUnOlxyXG4gICAgICAgIGNhc2UgJ3N0cmFpZ2h0Q29ubmVjdG9yMSc6XHJcbiAgICAgICAgICByZXR1cm4gJ2xpbmUnXHJcbiAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBVbmtub3duIHNoYXBlIHR5cGU6ICR7cHJzdH0sIGRlZmF1bHRpbmcgdG8gcmVjdGFuZ2xlYClcclxuICAgICAgICAgIHJldHVybiAncmVjdGFuZ2xlJ1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIElmIG5vIHByc3RHZW9tIGZvdW5kLCB0cnkgdG8gZGV0ZXJtaW5lIGZyb20gb3RoZXIgcHJvcGVydGllc1xyXG4gICAgY29uc29sZS5sb2coJ05vIHByc3RHZW9tIGZvdW5kLCBkZWZhdWx0aW5nIHRvIHJlY3RhbmdsZScpXHJcbiAgICByZXR1cm4gJ3JlY3RhbmdsZSdcclxuICB9XHJcblxyXG4gIHByaXZhdGUgY3JlYXRlRGVmYXVsdFNsaWRlKCk6IFNsaWRlIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gICAgICBuYW1lOiAnU2xpZGUgMScsXHJcbiAgICAgIHdpZHRoOiA5NjAsXHJcbiAgICAgIGhlaWdodDogNTQwLFxyXG4gICAgICBvYmplY3RzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgICAgICAgICB0eXBlOiAndGV4dCcsXHJcbiAgICAgICAgICB0cmFuc2Zvcm06IHtcclxuICAgICAgICAgICAgbGVmdDogMTAwLFxyXG4gICAgICAgICAgICB0b3A6IDEwMCxcclxuICAgICAgICAgICAgd2lkdGg6IDMwMCxcclxuICAgICAgICAgICAgaGVpZ2h0OiAxMDAsXHJcbiAgICAgICAgICAgIGFuZ2xlOiAwLFxyXG4gICAgICAgICAgICBzY2FsZVg6IDEsXHJcbiAgICAgICAgICAgIHNjYWxlWTogMSxcclxuICAgICAgICAgICAgZmxpcFg6IGZhbHNlLFxyXG4gICAgICAgICAgICBmbGlwWTogZmFsc2UsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcclxuICAgICAgICAgICAgZm9udFNpemU6IDI0LFxyXG4gICAgICAgICAgICBmb250V2VpZ2h0OiAnYm9sZCcsXHJcbiAgICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIGNvbnRlbnQ6ICdXZWxjb21lIHRvIFBQVFggRWRpdG9yJyxcclxuICAgICAgICB9XHJcbiAgICAgIF0sXHJcbiAgICB9XHJcbiAgfVxyXG59XHJcblxyXG4iXSwibmFtZXMiOlsiSlNaaXAiLCJQUFRYUGFyc2VyIiwicGFyc2VGaWxlIiwiZmlsZSIsImNvbnNvbGUiLCJsb2ciLCJ6aXAiLCJsb2FkQXN5bmMiLCJmaWxlTmFtZXMiLCJPYmplY3QiLCJrZXlzIiwiZmlsZXMiLCJzbGlkZXMiLCJyZWFkU2xpZGVzIiwicHJvcGVydGllcyIsInJlYWRQcmVzZW50YXRpb25Qcm9wcyIsImlkIiwiY3J5cHRvIiwicmFuZG9tVVVJRCIsIm5hbWUiLCJyZXBsYWNlIiwibWV0YWRhdGEiLCJlcnJvciIsImNvcmVQcm9wcyIsImNvbnRlbnQiLCJhc3luYyIsInBhcnNlciIsIkRPTVBhcnNlciIsInhtbCIsInBhcnNlRnJvbVN0cmluZyIsImF1dGhvckVsZW1lbnQiLCJxdWVyeVNlbGVjdG9yIiwiYXV0aG9yIiwidGV4dENvbnRlbnQiLCJ1bmRlZmluZWQiLCJ3YXJuIiwicHJlc2VudGF0aW9uIiwic3Vic3RyaW5nIiwic2xpZGVJZHMiLCJnZXRFbGVtZW50c0J5VGFnTmFtZSIsImxlbmd0aCIsInNsaWRlRmlsZXMiLCJmaWx0ZXIiLCJzdGFydHNXaXRoIiwiZW5kc1dpdGgiLCJzb3J0IiwiaSIsInNsaWRlRmlsZSIsInNsaWRlTnVtYmVyIiwic2xpZGUiLCJyZWFkU2xpZGVGcm9tRmlsZSIsInB1c2giLCJzbGlkZUlkIiwiZ2V0QXR0cmlidXRlIiwicmVhZFNsaWRlIiwiY3JlYXRlRGVmYXVsdFNsaWRlIiwic2xpZGVSZWwiLCJyZWxYbWwiLCJyZWxDb250ZW50IiwicmVsUGFyc2VyIiwic2xpZGVUYXJnZXQiLCJzbGlkZVBhdGgiLCJzcGxpdCIsInBvcCIsInRhcmdldFNsaWRlIiwic2xpZGVDb250ZW50Iiwic2xpZGVQYXJzZXIiLCJzbGlkZVhtbCIsInNsZFN6Iiwid2lkdGgiLCJwYXJzZUludCIsImhlaWdodCIsIm9iamVjdHMiLCJleHRyYWN0U2hhcGVzIiwic2xpZGVGaWxlUGF0aCIsImN4IiwiY3kiLCJlbXVUb1BpeGVsIiwiTWF0aCIsIm1heCIsInNwVHJlZSIsImZpbmRFbGVtZW50QnlUYWdOYW1lIiwidGV4dEJveGVzIiwiZmluZEVsZW1lbnRzQnlUYWdOYW1lIiwidGV4dEJveCIsInRhZ05hbWUiLCJudlByIiwicGgiLCJwaFR5cGUiLCJzaGFwZSIsImV4dHJhY3RUZXh0Qm94IiwidHlwZSIsImFsbFNwRWxlbWVudHMiLCJzcEVsZW1lbnQiLCJ0ZXh0RWxlbWVudHMiLCJmaXJzdFRleHQiLCJ0ZXh0T2JqZWN0IiwidHJhbnNmb3JtIiwibGVmdCIsInRvcCIsImFuZ2xlIiwic2NhbGVYIiwic2NhbGVZIiwiZmxpcFgiLCJmbGlwWSIsInN0eWxlIiwiZm9udEZhbWlseSIsImZvbnRTaXplIiwiZm9udFdlaWdodCIsImZvbnRTdHlsZSIsInRleHREZWNvcmF0aW9uIiwiY29sb3IiLCJ0ZXh0QWxpZ24iLCJsaW5lSGVpZ2h0IiwiaW1hZ2VzIiwiaW1hZ2UiLCJleHRyYWN0SW1hZ2UiLCJtYXAiLCJvYmoiLCJwYXJlbnQiLCJlbGVtZW50IiwicHJlZml4ZXMiLCJwcmVmaXgiLCJmdWxsVGFnTmFtZSIsImFsbEVsZW1lbnRzIiwiZWwiLCJpbmNsdWRlcyIsImVsZW1lbnRzIiwiQXJyYXkiLCJmcm9tIiwibWF0Y2hpbmdFbGVtZW50cyIsImluZGV4Iiwib3V0ZXJIVE1MIiwic3BQciIsInR4Qm9keSIsImhhc1RleHQiLCJpc1BsYWNlaG9sZGVyIiwicHJzdEdlb20iLCJzaGFwZVR5cGUiLCJleHRyYWN0QmFzaWNTaGFwZSIsImV4dHJhY3RUcmFuc2Zvcm0iLCJleHRyYWN0VGV4dENvbnRlbnQiLCJ0ZXh0U3R5bGUiLCJleHRyYWN0VGV4dFN0eWxlIiwic3JjIiwiYnRvYSIsInByc3QiLCJjTnZQciIsInNoYXBlTmFtZSIsImZpbGwiLCJzdHJva2UiLCJzdHJva2VXaWR0aCIsInhmcm0iLCJvZmYiLCJleHQiLCJyb3QiLCJzY2FsZUZhY3RvciIsImVtdUxlZnQiLCJlbXVUb3AiLCJlbXVXaWR0aCIsImVtdUhlaWdodCIsInBhcmFncmFwaHMiLCJwYXJhZ3JhcGgiLCJ0ZXh0UnVucyIsInBhcmFncmFwaFRleHQiLCJqIiwidGV4dFJ1biIsInRleHRFbGVtZW50IiwiZGVmUlByIiwiZXh0cmFjdENvbG9yIiwic29saWRGaWxsIiwic3JnYkNsciIsInZhbCIsImRldGVybWluZVNoYXBlVHlwZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/pptxParser.ts\n"));

/***/ })

});