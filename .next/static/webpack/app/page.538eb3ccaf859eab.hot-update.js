"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/pptxParser.ts":
/*!*********************************!*\
  !*** ./src/utils/pptxParser.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PPTXParser: function() { return /* binding */ PPTXParser; }\n/* harmony export */ });\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jszip */ \"(app-pages-browser)/./node_modules/jszip/dist/jszip.min.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_0__);\n\nclass PPTXParser {\n    async parseFile(file) {\n        try {\n            console.log(\"Starting PPTX parsing...\");\n            // Load the ZIP file\n            this.zip = await jszip__WEBPACK_IMPORTED_MODULE_0___default().loadAsync(file);\n            console.log(\"ZIP file loaded successfully\");\n            // List all files for debugging\n            const fileNames = Object.keys(this.zip.files);\n            console.log(\"Files in ZIP:\", fileNames);\n            // Parse the document\n            const slides = await this.readSlides();\n            const properties = await this.readPresentationProps();\n            console.log(\"Parsing completed successfully\");\n            return {\n                id: crypto.randomUUID(),\n                name: file.name.replace(\".pptx\", \"\"),\n                slides,\n                metadata: properties\n            };\n        } catch (error) {\n            console.error(\"Error parsing PPTX file:\", error);\n            throw error;\n        }\n    }\n    async readPresentationProps() {\n        try {\n            var _this_zip;\n            const coreProps = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(\"docProps/core.xml\");\n            if (coreProps) {\n                const content = await coreProps.async(\"text\");\n                const parser = new DOMParser();\n                const xml = parser.parseFromString(content, \"text/xml\");\n                const authorElement = xml.querySelector(\"dc\\\\:creator, creator\");\n                return {\n                    author: (authorElement === null || authorElement === void 0 ? void 0 : authorElement.textContent) || undefined\n                };\n            }\n        } catch (error) {\n            console.warn(\"Could not read presentation properties:\", error);\n        }\n        return {};\n    }\n    async readSlides() {\n        const slides = [];\n        try {\n            var _this_zip;\n            // Get slide count from presentation.xml\n            const presentation = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(\"ppt/presentation.xml\");\n            if (presentation) {\n                const content = await presentation.async(\"text\");\n                console.log(\"Presentation XML content:\", content.substring(0, 500) + \"...\");\n                const parser = new DOMParser();\n                const xml = parser.parseFromString(content, \"text/xml\");\n                // Try multiple approaches to find slides\n                let slideIds = xml.getElementsByTagName(\"sldId\");\n                console.log(\"Found \".concat(slideIds.length, \" slides using 'sldId' tag\"));\n                // If no slides found, try alternative approaches\n                if (slideIds.length === 0) {\n                    var _this_zip1;\n                    // Try looking for slides in the slides folder directly\n                    const slideFiles = Object.keys(((_this_zip1 = this.zip) === null || _this_zip1 === void 0 ? void 0 : _this_zip1.files) || {}).filter((name)=>name.startsWith(\"ppt/slides/slide\") && name.endsWith(\".xml\")).sort();\n                    console.log(\"Found slide files directly:\", slideFiles);\n                    if (slideFiles.length > 0) {\n                        // Create slides from the files we found\n                        for(let i = 0; i < slideFiles.length; i++){\n                            const slideFile = slideFiles[i];\n                            const slideNumber = i + 1;\n                            console.log(\"Processing slide file: \".concat(slideFile));\n                            const slide = await this.readSlideFromFile(slideFile, slideNumber);\n                            if (slide) {\n                                slides.push(slide);\n                                console.log(\"Successfully loaded slide \".concat(slideNumber, \" from file\"));\n                            }\n                        }\n                    }\n                } else {\n                    // Process slides using the traditional method\n                    for(let i = 0; i < slideIds.length; i++){\n                        const slideId = slideIds[i].getAttribute(\"r:id\");\n                        console.log(\"Processing slide \".concat(i + 1, \" with ID: \").concat(slideId));\n                        if (slideId) {\n                            const slide = await this.readSlide(slideId, i + 1);\n                            if (slide) {\n                                slides.push(slide);\n                                console.log(\"Successfully loaded slide \".concat(i + 1));\n                            } else {\n                                console.warn(\"Failed to load slide \".concat(i + 1));\n                            }\n                        }\n                    }\n                }\n            } else {\n                console.warn(\"Could not find presentation.xml\");\n            }\n        } catch (error) {\n            console.error(\"Error reading slides:\", error);\n            // Create a default slide if parsing fails\n            slides.push(this.createDefaultSlide());\n        }\n        console.log(\"Total slides loaded: \".concat(slides.length));\n        return slides.length > 0 ? slides : [\n            this.createDefaultSlide()\n        ];\n    }\n    async readSlide(slideId, slideNumber) {\n        try {\n            var _this_zip;\n            // Try to find the slide file directly first\n            let slideFile = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(\"ppt/slides/slide\".concat(slideNumber, \".xml\"));\n            // If not found, try to find it through relationships\n            if (!slideFile) {\n                var _this_zip1;\n                const slideRel = (_this_zip1 = this.zip) === null || _this_zip1 === void 0 ? void 0 : _this_zip1.file(\"ppt/slides/_rels/slide\".concat(slideNumber, \".xml.rels\"));\n                if (slideRel) {\n                    var _relXml_querySelector;\n                    const relContent = await slideRel.async(\"text\");\n                    const relParser = new DOMParser();\n                    const relXml = relParser.parseFromString(relContent, \"text/xml\");\n                    const slideTarget = (_relXml_querySelector = relXml.querySelector('Relationship[Id=\"'.concat(slideId, '\"]'))) === null || _relXml_querySelector === void 0 ? void 0 : _relXml_querySelector.getAttribute(\"Target\");\n                    if (slideTarget) {\n                        var _this_zip2;\n                        const slidePath = \"ppt/slides/\".concat(slideTarget.split(\"/\").pop());\n                        slideFile = (_this_zip2 = this.zip) === null || _this_zip2 === void 0 ? void 0 : _this_zip2.file(slidePath);\n                    }\n                }\n            }\n            // If still not found, try to find any slide file\n            if (!slideFile) {\n                var _this_zip3;\n                const slideFiles = Object.keys(((_this_zip3 = this.zip) === null || _this_zip3 === void 0 ? void 0 : _this_zip3.files) || {}).filter((name)=>name.startsWith(\"ppt/slides/slide\") && name.endsWith(\".xml\")).sort();\n                if (slideFiles.length > 0) {\n                    var _this_zip4;\n                    const targetSlide = slideFiles[slideNumber - 1] || slideFiles[0];\n                    slideFile = (_this_zip4 = this.zip) === null || _this_zip4 === void 0 ? void 0 : _this_zip4.file(targetSlide);\n                }\n            }\n            if (!slideFile) {\n                console.warn(\"Could not find slide file for slide \".concat(slideNumber));\n                return null;\n            }\n            const slideContent = await slideFile.async(\"text\");\n            const slideParser = new DOMParser();\n            const slideXml = slideParser.parseFromString(slideContent, \"text/xml\");\n            // Extract slide dimensions\n            const sldSz = slideXml.getElementsByTagName(\"sldSz\")[0];\n            const width = parseInt((sldSz === null || sldSz === void 0 ? void 0 : sldSz.getAttribute(\"cx\")) || \"9144000\") / 12700 // Convert EMUs to pixels\n            ;\n            const height = parseInt((sldSz === null || sldSz === void 0 ? void 0 : sldSz.getAttribute(\"cy\")) || \"6858000\") / 12700;\n            // Extract shapes\n            const objects = await this.extractShapes(slideXml, slideNumber);\n            return {\n                id: crypto.randomUUID(),\n                name: \"Slide \".concat(slideNumber),\n                width,\n                height,\n                objects\n            };\n        } catch (error) {\n            console.error(\"Error reading slide \".concat(slideNumber, \":\"), error);\n            return null;\n        }\n    }\n    async readSlideFromFile(slideFilePath, slideNumber) {\n        try {\n            var _this_zip;\n            const slideFile = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(slideFilePath);\n            if (!slideFile) {\n                console.warn(\"Could not find slide file: \".concat(slideFilePath));\n                return null;\n            }\n            const slideContent = await slideFile.async(\"text\");\n            console.log(\"Slide \".concat(slideNumber, \" XML content:\"), slideContent.substring(0, 1000) + \"...\");\n            const slideParser = new DOMParser();\n            const slideXml = slideParser.parseFromString(slideContent, \"text/xml\");\n            // Extract slide dimensions with better namespace handling\n            let sldSz = slideXml.getElementsByTagName(\"sldSz\")[0];\n            if (!sldSz) {\n                sldSz = slideXml.getElementsByTagName(\"p:sldSz\")[0];\n            }\n            let width = 800, height = 600 // Default dimensions\n            ;\n            if (sldSz) {\n                const cx = sldSz.getAttribute(\"cx\");\n                const cy = sldSz.getAttribute(\"cy\");\n                console.log(\"Slide \".concat(slideNumber, \" dimensions from XML:\"), {\n                    cx,\n                    cy\n                });\n                if (cx && cy) {\n                    // Convert EMUs to pixels\n                    const emuToPixel = 96 / 914400;\n                    width = parseInt(cx) * emuToPixel;\n                    height = parseInt(cy) * emuToPixel;\n                    console.log(\"Slide \".concat(slideNumber, \" converted dimensions:\"), {\n                        width,\n                        height\n                    });\n                }\n            } else {\n                console.warn(\"No sldSz found in slide \".concat(slideNumber, \", using defaults\"));\n            }\n            // Extract shapes\n            const objects = await this.extractShapes(slideXml, slideNumber);\n            return {\n                id: crypto.randomUUID(),\n                name: \"Slide \".concat(slideNumber),\n                width: Math.max(width, 800),\n                height: Math.max(height, 600),\n                objects\n            };\n        } catch (error) {\n            console.error(\"Error reading slide from file \".concat(slideFilePath, \":\"), error);\n            return null;\n        }\n    }\n    async extractShapes(slideXml, slideNumber) {\n        const objects = [];\n        try {\n            console.log(\"Extracting shapes from slide \".concat(slideNumber));\n            // Try multiple approaches to find shapes\n            // Approach 1: Look for spTree > sp (traditional structure)\n            // Use a more robust approach to handle namespaces\n            let spTree = this.findElementByTagName(slideXml, \"spTree\");\n            if (spTree) {\n                const textBoxes = this.findElementsByTagName(spTree, \"sp\");\n                console.log(\"Found \".concat(textBoxes.length, \" shape elements in spTree\"));\n                for(let i = 0; i < textBoxes.length; i++){\n                    const textBox = textBoxes[i];\n                    console.log(\"Processing shape \".concat(i + 1, \":\"), textBox.tagName, textBox.getAttribute(\"id\"), textBox.getAttribute(\"name\"));\n                    // Check if this is a placeholder\n                    const nvPr = this.findElementByTagName(textBox, \"nvPr\");\n                    const ph = nvPr ? this.findElementByTagName(nvPr, \"ph\") : null;\n                    if (ph) {\n                        const phType = ph.getAttribute(\"type\");\n                        console.log(\"Shape \".concat(i + 1, \" is a placeholder of type: \").concat(phType));\n                    }\n                    // Check if this is a grouped shape\n                    const grpSp = this.findElementByTagName(textBox, \"grpSp\");\n                    if (grpSp) {\n                        console.log(\"Shape \".concat(i + 1, \" is a grouped shape, extracting group\"));\n                        const groupObject = this.extractGroupedShape(grpSp, slideNumber, i);\n                        if (groupObject) {\n                            var _groupObject_children;\n                            objects.push(groupObject);\n                            console.log(\"Successfully extracted grouped shape \".concat(i + 1, \" with \").concat(((_groupObject_children = groupObject.children) === null || _groupObject_children === void 0 ? void 0 : _groupObject_children.length) || 0, \" children\"));\n                        }\n                        continue;\n                    }\n                    // Check if this is a text shape\n                    const txBody = this.findElementByTagName(textBox, \"txBody\");\n                    const hasText = txBody && this.findElementsByTagName(txBody, \"t\").length > 0;\n                    if (hasText) {\n                        // For text shapes, extract individual text elements instead of the main shape\n                        console.log(\"Shape \".concat(i + 1, \" has text, extracting individual text elements\"));\n                        const textObjects = this.extractIndividualTextElements(textBox, slideNumber, i);\n                        objects.push(...textObjects);\n                        console.log(\"Extracted \".concat(textObjects.length, \" text objects from shape \").concat(i + 1));\n                    } else {\n                        // For non-text shapes, extract as basic shape\n                        console.log(\"Shape \".concat(i + 1, \" has no text, extracting as basic shape\"));\n                        const shape = this.extractBasicShape(textBox, slideNumber, i);\n                        if (shape) {\n                            objects.push(shape);\n                            console.log(\"Successfully extracted basic shape \".concat(i + 1, \":\"), shape.type);\n                        }\n                    }\n                }\n            } else {\n                console.warn(\"No spTree found in slide\");\n            }\n            // Approach 2: Look for shapes directly in the slide\n            if (objects.length === 0) {\n                console.log(\"Trying alternative shape extraction...\");\n                // Look for any sp elements anywhere in the slide\n                const allSpElements = this.findElementsByTagName(slideXml, \"sp\");\n                console.log(\"Found \".concat(allSpElements.length, \" sp elements in slide\"));\n                for(let i = 0; i < allSpElements.length; i++){\n                    const spElement = allSpElements[i];\n                    console.log(\"Processing sp element \".concat(i + 1, \":\"), spElement.tagName, spElement.getAttribute(\"id\"));\n                    // Check for grouped shapes first\n                    const grpSp = this.findElementByTagName(spElement, \"grpSp\");\n                    if (grpSp) {\n                        console.log(\"SP element \".concat(i + 1, \" is a grouped shape\"));\n                        const groupObject = this.extractGroupedShape(grpSp, slideNumber, i);\n                        if (groupObject) {\n                            objects.push(groupObject);\n                        }\n                        continue;\n                    }\n                    const txBody = this.findElementByTagName(spElement, \"txBody\");\n                    const hasText = txBody && this.findElementsByTagName(txBody, \"t\").length > 0;\n                    if (hasText) {\n                        const textObjects = this.extractIndividualTextElements(spElement, slideNumber, i);\n                        objects.push(...textObjects);\n                    } else {\n                        const shape = this.extractBasicShape(spElement, slideNumber, i);\n                        if (shape) {\n                            objects.push(shape);\n                        }\n                    }\n                }\n            }\n            // Approach 3: Look for text elements directly\n            if (objects.length === 0) {\n                console.log(\"Trying direct text extraction...\");\n                const textElements = this.findElementsByTagName(slideXml, \"t\");\n                console.log(\"Found \".concat(textElements.length, \" text elements directly in slide\"));\n                if (textElements.length > 0) {\n                    // Create a simple text object from the first text element\n                    const firstText = textElements[0];\n                    const textContent = firstText.textContent || \"Text\";\n                    console.log('Creating text object with content: \"'.concat(textContent, '\"'));\n                    const textObject = {\n                        id: crypto.randomUUID(),\n                        type: \"text\",\n                        transform: {\n                            left: 100,\n                            top: 100,\n                            width: 300,\n                            height: 100,\n                            angle: 0,\n                            scaleX: 1,\n                            scaleY: 1,\n                            flipX: false,\n                            flipY: false\n                        },\n                        style: {\n                            fontFamily: \"Arial\",\n                            fontSize: 18,\n                            fontWeight: \"normal\",\n                            fontStyle: \"normal\",\n                            textDecoration: \"none\",\n                            color: \"#000000\",\n                            textAlign: \"left\",\n                            lineHeight: 1.2\n                        },\n                        content: textContent\n                    };\n                    objects.push(textObject);\n                    console.log(\"Created fallback text object\");\n                }\n            }\n            // Extract images\n            const images = this.findElementsByTagName(slideXml, \"pic\");\n            console.log(\"Found \".concat(images.length, \" image elements\"));\n            for(let i = 0; i < images.length; i++){\n                const image = images[i];\n                const shape = await this.extractImage(image, slideNumber, i);\n                if (shape) {\n                    objects.push(shape);\n                    console.log(\"Successfully extracted image \".concat(i + 1));\n                }\n            }\n            console.log(\"Total objects extracted: \".concat(objects.length));\n            console.log(\"Final objects:\", objects.map((obj)=>({\n                    type: obj.type,\n                    content: obj.content,\n                    transform: obj.transform\n                })));\n        } catch (error) {\n            console.error(\"Error extracting shapes:\", error);\n        }\n        return objects;\n    }\n    // Helper methods to handle XML namespaces\n    findElementByTagName(parent, tagName) {\n        // Try multiple approaches to find the element\n        let element = parent.getElementsByTagName(tagName)[0];\n        if (element) return element;\n        // If not found, try with common namespace prefixes\n        const prefixes = [\n            \"p:\",\n            \"a:\",\n            \"r:\",\n            \"\"\n        ];\n        for (const prefix of prefixes){\n            const fullTagName = prefix + tagName;\n            element = parent.getElementsByTagName(fullTagName)[0];\n            if (element) return element;\n        }\n        // Last resort: search by partial tag name\n        const allElements = parent.getElementsByTagName(\"*\");\n        for(let i = 0; i < allElements.length; i++){\n            const el = allElements[i];\n            if (el.tagName.endsWith(tagName) || el.tagName.includes(tagName)) {\n                return el;\n            }\n        }\n        return null;\n    }\n    findElementsByTagName(parent, tagName) {\n        // Try multiple approaches to find elements\n        let elements = Array.from(parent.getElementsByTagName(tagName));\n        if (elements.length > 0) return elements;\n        // If not found, try with common namespace prefixes\n        const prefixes = [\n            \"p:\",\n            \"a:\",\n            \"r:\",\n            \"\"\n        ];\n        for (const prefix of prefixes){\n            const fullTagName = prefix + tagName;\n            elements = Array.from(parent.getElementsByTagName(fullTagName));\n            if (elements.length > 0) return elements;\n        }\n        // Last resort: search by partial tag name\n        const allElements = parent.getElementsByTagName(\"*\");\n        const matchingElements = [];\n        for(let i = 0; i < allElements.length; i++){\n            const el = allElements[i];\n            if (el.tagName.endsWith(tagName) || el.tagName.includes(tagName)) {\n                matchingElements.push(el);\n            }\n        }\n        return matchingElements;\n    }\n    async extractImage(image, slideNumber, index) {\n        try {\n            console.log(\"Extracting actual image \".concat(index, \" from slide \").concat(slideNumber));\n            const spPr = this.findElementByTagName(image, \"spPr\");\n            if (!spPr) return null;\n            const transform = this.extractTransform(spPr);\n            // Extract the actual image data from the PPTX\n            const blipFill = this.findElementByTagName(image, \"blipFill\");\n            if (blipFill) {\n                const blip = this.findElementByTagName(blipFill, \"blip\");\n                if (blip) {\n                    const embed = blip.getAttribute(\"r:embed\");\n                    const link = blip.getAttribute(\"r:link\");\n                    console.log(\"Image \".concat(index, \" has embed: \").concat(embed, \", link: \").concat(link));\n                    if (embed || link) {\n                        // Try to find the actual image file\n                        const imageId = embed || link;\n                        const imageFile = await this.findImageFile(imageId);\n                        if (imageFile) {\n                            console.log(\"Found actual image file: \".concat(imageFile.name));\n                            // Convert image to data URL\n                            const imageData = await imageFile.async(\"base64\");\n                            const mimeType = this.getMimeType(imageFile.name);\n                            const dataUrl = \"data:\".concat(mimeType, \";base64,\").concat(imageData);\n                            return {\n                                id: crypto.randomUUID(),\n                                type: \"image\",\n                                transform,\n                                style: {},\n                                src: dataUrl\n                            };\n                        }\n                    }\n                }\n            }\n            // If we can't extract the actual image, create a better placeholder\n            console.warn(\"Could not extract actual image data for image \".concat(index, \", creating placeholder\"));\n            return {\n                id: crypto.randomUUID(),\n                type: \"image\",\n                transform,\n                style: {},\n                src: \"data:image/svg+xml;base64,\".concat(btoa('<svg width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" fill=\"#ccc\"/><text x=\"50\" y=\"50\" text-anchor=\"middle\" dy=\".3em\" font-size=\"12\">Image</text></svg>'))\n            };\n        } catch (error) {\n            console.error(\"Error extracting image \".concat(index, \":\"), error);\n            return null;\n        }\n    }\n    async findImageFile(imageId) {\n        try {\n            var _this_zip, _this_zip1;\n            // First try to find the relationship file\n            const relsFile = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(\"ppt/_rels/presentation.xml.rels\");\n            if (relsFile) {\n                const relsContent = await relsFile.async(\"text\");\n                const relsParser = new DOMParser();\n                const relsXml = relsParser.parseFromString(relsContent, \"text/xml\");\n                const relationship = relsXml.querySelector('Relationship[Id=\"'.concat(imageId, '\"]'));\n                if (relationship) {\n                    const target = relationship.getAttribute(\"Target\");\n                    if (target) {\n                        var _this_zip2;\n                        // Convert relative path to absolute\n                        const imagePath = target.startsWith(\"/\") ? target.slice(1) : \"ppt/\".concat(target);\n                        const imageFile = (_this_zip2 = this.zip) === null || _this_zip2 === void 0 ? void 0 : _this_zip2.file(imagePath);\n                        if (imageFile) {\n                            console.log(\"Found image file via relationships: \".concat(imagePath));\n                            return imageFile;\n                        }\n                    }\n                }\n            }\n            // Try common image paths\n            const commonPaths = [\n                \"ppt/media/image\".concat(imageId, \".png\"),\n                \"ppt/media/image\".concat(imageId, \".jpg\"),\n                \"ppt/media/image\".concat(imageId, \".jpeg\"),\n                \"ppt/media/image\".concat(imageId, \".gif\"),\n                \"ppt/media/image\".concat(imageId, \".bmp\")\n            ];\n            for (const path of commonPaths){\n                var _this_zip3;\n                const imageFile = (_this_zip3 = this.zip) === null || _this_zip3 === void 0 ? void 0 : _this_zip3.file(path);\n                if (imageFile) {\n                    console.log(\"Found image file via common path: \".concat(path));\n                    return imageFile;\n                }\n            }\n            // Search through all files for images\n            const allFiles = Object.keys(((_this_zip1 = this.zip) === null || _this_zip1 === void 0 ? void 0 : _this_zip1.files) || {});\n            const imageFiles = allFiles.filter((name)=>name.includes(\"media\") && (name.endsWith(\".png\") || name.endsWith(\".jpg\") || name.endsWith(\".jpeg\") || name.endsWith(\".gif\") || name.endsWith(\".bmp\")));\n            console.log(\"Found \".concat(imageFiles.length, \" image files in media folder:\"), imageFiles);\n            // Try to find the image by ID in the filename\n            for (const imagePath of imageFiles){\n                if (imagePath.includes(imageId) || imagePath.includes(\"image\".concat(imageId))) {\n                    var _this_zip4;\n                    const imageFile = (_this_zip4 = this.zip) === null || _this_zip4 === void 0 ? void 0 : _this_zip4.file(imagePath);\n                    if (imageFile) {\n                        console.log(\"Found image file by ID search: \".concat(imagePath));\n                        return imageFile;\n                    }\n                }\n            }\n            return null;\n        } catch (error) {\n            console.error(\"Error finding image file:\", error);\n            return null;\n        }\n    }\n    getMimeType(filename) {\n        var _filename_split_pop;\n        const ext = (_filename_split_pop = filename.split(\".\").pop()) === null || _filename_split_pop === void 0 ? void 0 : _filename_split_pop.toLowerCase();\n        switch(ext){\n            case \"png\":\n                return \"image/png\";\n            case \"jpg\":\n            case \"jpeg\":\n                return \"image/jpeg\";\n            case \"gif\":\n                return \"image/gif\";\n            case \"bmp\":\n                return \"image/bmp\";\n            case \"svg\":\n                return \"image/svg+xml\";\n            default:\n                return \"image/png\";\n        }\n    }\n    async extractGroupedShape(grpSp, slideNumber, index) {\n        try {\n            console.log(\"Extracting grouped shape \".concat(index, \" from slide \").concat(slideNumber));\n            // Extract the group's transform\n            const grpSpPr = this.findElementByTagName(grpSp, \"grpSpPr\");\n            const transform = grpSpPr ? this.extractTransform(grpSpPr) : {\n                left: 0,\n                top: 0,\n                width: 400,\n                height: 300,\n                angle: 0,\n                scaleX: 1,\n                scaleY: 1,\n                flipX: false,\n                flipY: false\n            };\n            // Extract child shapes from the group\n            const children = [];\n            // Look for sp elements within the group\n            const childSpElements = this.findElementsByTagName(grpSp, \"sp\");\n            console.log(\"Found \".concat(childSpElements.length, \" child shapes in group \").concat(index));\n            for(let i = 0; i < childSpElements.length; i++){\n                const childSp = childSpElements[i];\n                console.log(\"Processing child shape \".concat(i + 1, \" in group \").concat(index));\n                // Check if child has text\n                const txBody = this.findElementByTagName(childSp, \"txBody\");\n                const hasText = txBody && this.findElementsByTagName(txBody, \"t\").length > 0;\n                if (hasText) {\n                    // Extract text objects from child\n                    const textObjects = this.extractIndividualTextElements(childSp, slideNumber, i);\n                    children.push(...textObjects);\n                } else {\n                    // Extract as basic shape\n                    const childShape = this.extractBasicShape(childSp, slideNumber, i);\n                    if (childShape) {\n                        children.push(childShape);\n                    }\n                }\n            }\n            // Look for pic elements within the group\n            const childPicElements = this.findElementsByTagName(grpSp, \"pic\");\n            console.log(\"Found \".concat(childPicElements.length, \" child images in group \").concat(index));\n            for(let i = 0; i < childPicElements.length; i++){\n                const childPic = childPicElements[i];\n                const childImage = await this.extractImage(childPic, slideNumber, i);\n                if (childImage) {\n                    children.push(childImage);\n                }\n            }\n            // Create the group object\n            const groupObject = {\n                id: crypto.randomUUID(),\n                type: \"group\",\n                transform,\n                style: {},\n                children,\n                groupId: \"group-\".concat(slideNumber, \"-\").concat(index)\n            };\n            console.log(\"Successfully created group object with \".concat(children.length, \" children\"));\n            return groupObject;\n        } catch (error) {\n            console.error(\"Error extracting grouped shape \".concat(index, \":\"), error);\n            return null;\n        }\n    }\n    extractBasicShape(shape, slideNumber, index) {\n        try {\n            var _prstGeom_getAttribute;\n            console.log(\"Extracting basic shape \".concat(index + 1, \" from slide \").concat(slideNumber));\n            const spPr = this.findElementByTagName(shape, \"spPr\");\n            if (!spPr) {\n                console.warn(\"No spPr found in basic shape \".concat(index + 1));\n                return null;\n            }\n            const transform = this.extractTransform(spPr);\n            // Get the actual shape type from the XML with better detection\n            let prstGeom = this.findElementByTagName(spPr, \"prstGeom\");\n            let shapeType = \"rectangle\";\n            if (prstGeom) {\n                const prst = prstGeom.getAttribute(\"prst\");\n                console.log(\"Found shape type in XML: \".concat(prst));\n                // Enhanced shape type detection\n                switch(prst){\n                    case \"rect\":\n                    case \"roundRect\":\n                    case \"snip1Rect\":\n                    case \"snip2Rect\":\n                    case \"snipRoundRect\":\n                    case \"round1Rect\":\n                    case \"round2Rect\":\n                        shapeType = \"rectangle\";\n                        break;\n                    case \"ellipse\":\n                    case \"oval\":\n                        shapeType = \"ellipse\";\n                        break;\n                    case \"line\":\n                    case \"straightConnector1\":\n                    case \"straightConnector2\":\n                    case \"straightConnector3\":\n                    case \"straightConnector4\":\n                    case \"straightConnector5\":\n                    case \"straightConnector6\":\n                    case \"bentConnector2\":\n                    case \"bentConnector3\":\n                    case \"bentConnector4\":\n                    case \"bentConnector5\":\n                        shapeType = \"line\";\n                        break;\n                    default:\n                        console.log(\"Unknown shape type: \".concat(prst, \", defaulting to rectangle\"));\n                        shapeType = \"rectangle\";\n                }\n            } else {\n                // Try to determine shape type from other properties\n                const custGeom = this.findElementByTagName(spPr, \"custGeom\");\n                if (custGeom) {\n                    console.log(\"Found custom geometry, defaulting to rectangle\");\n                    shapeType = \"rectangle\";\n                } else {\n                    console.log(\"No geometry found, defaulting to rectangle\");\n                    shapeType = \"rectangle\";\n                }\n            }\n            console.log(\"Extracted basic shape: type=\".concat(shapeType, \", transform=\"), transform);\n            // For basic shapes, we might still have some text content (like placeholders)\n            let content = \"\";\n            const txBody = this.findElementByTagName(shape, \"txBody\");\n            if (txBody) {\n                content = this.extractTextContent(shape);\n            }\n            // Check if this is a placeholder\n            const nvPr = this.findElementByTagName(shape, \"nvPr\");\n            const ph = nvPr ? this.findElementByTagName(nvPr, \"ph\") : null;\n            if (ph) {\n                const phType = ph.getAttribute(\"type\");\n                if (phType === \"title\") {\n                    content = \"Title Placeholder\";\n                } else if (phType === \"body\") {\n                    content = \"Body Placeholder\";\n                } else if (phType === \"pic\") {\n                    content = \"Picture Placeholder\";\n                } else {\n                    content = \"Content Placeholder\";\n                }\n            }\n            // Get shape name for better identification\n            const cNvPr = this.findElementByTagName(shape, \"cNvPr\");\n            const shapeName = (cNvPr === null || cNvPr === void 0 ? void 0 : cNvPr.getAttribute(\"name\")) || \"Shape \".concat(index + 1);\n            console.log(\"Shape name: \".concat(shapeName));\n            // Enhanced styling based on shape type\n            const style = {\n                fill: shapeType === \"line\" ? \"transparent\" : \"#e5e7eb\",\n                stroke: \"#6b7280\",\n                strokeWidth: shapeType === \"line\" ? 2 : 1\n            };\n            // Add corner radius for rounded rectangles\n            if (shapeType === \"rectangle\" && (prstGeom === null || prstGeom === void 0 ? void 0 : (_prstGeom_getAttribute = prstGeom.getAttribute(\"prst\")) === null || _prstGeom_getAttribute === void 0 ? void 0 : _prstGeom_getAttribute.includes(\"round\"))) {\n                style.rx = 10;\n                style.ry = 10;\n            }\n            return {\n                id: crypto.randomUUID(),\n                type: shapeType,\n                transform,\n                style,\n                content: content || undefined\n            };\n        } catch (error) {\n            console.error(\"Error extracting basic shape:\", error);\n            return null;\n        }\n    }\n    extractTransform(spPr) {\n        // Debug the spPr element structure\n        console.log(\"Extracting transform from spPr:\", spPr.outerHTML.substring(0, 500) + \"...\");\n        // Try to find xfrm element with better namespace handling\n        let xfrm = spPr.getElementsByTagName(\"xfrm\")[0];\n        if (!xfrm) {\n            // Try with namespace prefixes\n            xfrm = spPr.getElementsByTagName(\"a:xfrm\")[0];\n        }\n        if (!xfrm) {\n            // Try searching by partial tag name\n            const allElements = spPr.getElementsByTagName(\"*\");\n            for(let i = 0; i < allElements.length; i++){\n                const el = allElements[i];\n                if (el.tagName.includes(\"xfrm\")) {\n                    xfrm = el;\n                    break;\n                }\n            }\n        }\n        console.log(\"Found xfrm element:\", xfrm === null || xfrm === void 0 ? void 0 : xfrm.outerHTML);\n        if (xfrm) {\n            // Find offset, extent, and rotation with better namespace handling\n            let off = xfrm.getElementsByTagName(\"off\")[0];\n            if (!off) off = xfrm.getElementsByTagName(\"a:off\")[0];\n            let ext = xfrm.getElementsByTagName(\"ext\")[0];\n            if (!ext) ext = xfrm.getElementsByTagName(\"a:ext\")[0];\n            let rot = xfrm.getElementsByTagName(\"rot\")[0];\n            if (!rot) rot = xfrm.getElementsByTagName(\"a:rot\")[0];\n            console.log(\"Transform elements - off:\", off === null || off === void 0 ? void 0 : off.outerHTML, \"ext:\", ext === null || ext === void 0 ? void 0 : ext.outerHTML, \"rot:\", rot === null || rot === void 0 ? void 0 : rot.outerHTML);\n            // Convert EMUs to pixels with better scaling\n            // 1 EMU = 1/914400 inch, 1 inch = 96 pixels (standard DPI)\n            // So 1 EMU = 96/914400 = 0.000105 pixels\n            // For better visibility, we'll scale this up\n            const emuToPixel = 96 / 914400;\n            const scaleFactor = 1 // Adjust this to make shapes bigger/smaller\n            ;\n            const left = parseInt((off === null || off === void 0 ? void 0 : off.getAttribute(\"x\")) || \"0\") * emuToPixel * scaleFactor;\n            const top = parseInt((off === null || off === void 0 ? void 0 : off.getAttribute(\"y\")) || \"0\") * emuToPixel * scaleFactor;\n            const width = parseInt((ext === null || ext === void 0 ? void 0 : ext.getAttribute(\"cx\")) || \"1000000\") * emuToPixel * scaleFactor;\n            const height = parseInt((ext === null || ext === void 0 ? void 0 : ext.getAttribute(\"cy\")) || \"1000000\") * emuToPixel * scaleFactor;\n            const angle = parseInt((rot === null || rot === void 0 ? void 0 : rot.getAttribute(\"val\")) || \"0\") / 60000 // Convert 60kths to degrees\n            ;\n            const transform = {\n                left: Math.max(0, left),\n                top: Math.max(0, top),\n                width: Math.max(50, width),\n                height: Math.max(50, height),\n                angle,\n                scaleX: 1,\n                scaleY: 1,\n                flipX: false,\n                flipY: false\n            };\n            console.log(\"Extracted transform (EMU values):\", {\n                emuLeft: off === null || off === void 0 ? void 0 : off.getAttribute(\"x\"),\n                emuTop: off === null || off === void 0 ? void 0 : off.getAttribute(\"y\"),\n                emuWidth: ext === null || ext === void 0 ? void 0 : ext.getAttribute(\"cx\"),\n                emuHeight: ext === null || ext === void 0 ? void 0 : ext.getAttribute(\"cy\")\n            });\n            console.log(\"Converted transform (pixels):\", transform);\n            return transform;\n        }\n        console.warn(\"No xfrm found, using default transform\");\n        return {\n            left: 100,\n            top: 100,\n            width: 200,\n            height: 150,\n            angle: 0,\n            scaleX: 1,\n            scaleY: 1,\n            flipX: false,\n            flipY: false\n        };\n    }\n    extractTextContent(textBox) {\n        // Try multiple approaches to find text content\n        let content = \"\";\n        // First try: look for text in txBody > p > r > t\n        const txBody = this.findElementByTagName(textBox, \"txBody\");\n        if (txBody) {\n            const paragraphs = this.findElementsByTagName(txBody, \"p\");\n            console.log(\"Found \".concat(paragraphs.length, \" paragraphs in text box\"));\n            for(let i = 0; i < paragraphs.length; i++){\n                const paragraph = paragraphs[i];\n                const textRuns = this.findElementsByTagName(paragraph, \"r\");\n                console.log(\"Paragraph \".concat(i + 1, \" has \").concat(textRuns.length, \" text runs\"));\n                let paragraphText = \"\";\n                for(let j = 0; j < textRuns.length; j++){\n                    const textRun = textRuns[j];\n                    const textElement = this.findElementByTagName(textRun, \"t\");\n                    if (textElement && textElement.textContent) {\n                        paragraphText += textElement.textContent;\n                        console.log(\"Text run \".concat(j + 1, ': \"').concat(textElement.textContent, '\"'));\n                    }\n                }\n                // Add paragraph text to content\n                if (paragraphText) {\n                    if (content) content += \"\\n\" // Add line break between paragraphs\n                    ;\n                    content += paragraphText;\n                }\n            }\n        }\n        // Second try: look for text directly in the textBox\n        if (!content) {\n            const textElements = this.findElementsByTagName(textBox, \"t\");\n            console.log(\"Found \".concat(textElements.length, \" text elements directly in text box\"));\n            for(let i = 0; i < textElements.length; i++){\n                const element = textElements[i];\n                if (element.textContent) {\n                    if (content) content += \"\\n\";\n                    content += element.textContent;\n                    console.log(\"Direct text element \".concat(i + 1, ': \"').concat(element.textContent, '\"'));\n                }\n            }\n        }\n        // Third try: look for any text content in the element\n        if (!content) {\n            content = textBox.textContent || \"\";\n            console.log('Fallback text content: \"'.concat(content, '\"'));\n        }\n        console.log('Final extracted text content: \"'.concat(content, '\"'));\n        return content || \"Text Box\";\n    }\n    extractTextStyle(textBox) {\n        const defRPr = this.findElementByTagName(textBox, \"defRPr\");\n        if (defRPr) {\n            return {\n                fontFamily: defRPr.getAttribute(\"typeface\") || \"Arial\",\n                fontSize: parseInt(defRPr.getAttribute(\"sz\") || \"1800\") / 100,\n                fontWeight: defRPr.getAttribute(\"b\") === \"1\" ? \"bold\" : \"normal\",\n                fontStyle: defRPr.getAttribute(\"i\") === \"1\" ? \"italic\" : \"normal\",\n                textDecoration: defRPr.getAttribute(\"u\") === \"1\" ? \"underline\" : \"none\",\n                color: this.extractColor(defRPr),\n                textAlign: \"left\",\n                lineHeight: 1.2\n            };\n        }\n        return {\n            fontFamily: \"Arial\",\n            fontSize: 18,\n            fontWeight: \"normal\",\n            fontStyle: \"normal\",\n            textDecoration: \"none\",\n            color: \"#000000\",\n            textAlign: \"left\",\n            lineHeight: 1.2\n        };\n    }\n    extractColor(defRPr) {\n        const solidFill = this.findElementByTagName(defRPr, \"solidFill\");\n        if (solidFill) {\n            const srgbClr = this.findElementByTagName(solidFill, \"srgbClr\");\n            if (srgbClr) {\n                const val = srgbClr.getAttribute(\"val\");\n                if (val) {\n                    return \"#\".concat(val);\n                }\n            }\n        }\n        return \"#000000\";\n    }\n    determineShapeType(spPr) {\n        // Try to find prstGeom element with better namespace handling\n        let prstGeom = spPr.getElementsByTagName(\"prstGeom\")[0];\n        if (!prstGeom) {\n            prstGeom = spPr.getElementsByTagName(\"a:prstGeom\")[0];\n        }\n        if (prstGeom) {\n            const prst = prstGeom.getAttribute(\"prst\");\n            console.log(\"Found shape type: \".concat(prst));\n            switch(prst){\n                case \"rect\":\n                case \"roundRect\":\n                    return \"rectangle\";\n                case \"ellipse\":\n                case \"oval\":\n                    return \"ellipse\";\n                case \"line\":\n                case \"straightConnector1\":\n                    return \"line\";\n                default:\n                    console.log(\"Unknown shape type: \".concat(prst, \", defaulting to rectangle\"));\n                    return \"rectangle\";\n            }\n        }\n        // If no prstGeom found, try to determine from other properties\n        console.log(\"No prstGeom found, defaulting to rectangle\");\n        return \"rectangle\";\n    }\n    createDefaultSlide() {\n        return {\n            id: crypto.randomUUID(),\n            name: \"Slide 1\",\n            width: 960,\n            height: 540,\n            objects: [\n                {\n                    id: crypto.randomUUID(),\n                    type: \"text\",\n                    transform: {\n                        left: 100,\n                        top: 100,\n                        width: 300,\n                        height: 100,\n                        angle: 0,\n                        scaleX: 1,\n                        scaleY: 1,\n                        flipX: false,\n                        flipY: false\n                    },\n                    style: {\n                        fontFamily: \"Arial\",\n                        fontSize: 24,\n                        fontWeight: \"bold\",\n                        color: \"#000000\",\n                        textAlign: \"left\"\n                    },\n                    content: \"Welcome to PPTX Editor\"\n                }\n            ]\n        };\n    }\n    extractIndividualTextElements(textBox, slideNumber, shapeIndex) {\n        const textObjects = [];\n        try {\n            const txBody = this.findElementByTagName(textBox, \"txBody\");\n            if (!txBody) return textObjects;\n            // Get the base transform from the shape\n            const spPr = this.findElementByTagName(textBox, \"spPr\");\n            const baseTransform = spPr ? this.extractTransform(spPr) : {\n                left: 100,\n                top: 100,\n                width: 300,\n                height: 150,\n                angle: 0,\n                scaleX: 1,\n                scaleY: 1,\n                flipX: false,\n                flipY: false\n            };\n            const paragraphs = this.findElementsByTagName(txBody, \"p\");\n            console.log(\"Extracting \".concat(paragraphs.length, \" individual text elements from shape \").concat(shapeIndex + 1));\n            for(let i = 0; i < paragraphs.length; i++){\n                const paragraph = paragraphs[i];\n                const textRuns = this.findElementsByTagName(paragraph, \"r\");\n                for(let j = 0; j < textRuns.length; j++){\n                    const textRun = textRuns[j];\n                    const textElement = this.findElementByTagName(textRun, \"t\");\n                    if (textElement && textElement.textContent && textElement.textContent.trim()) {\n                        const textContent = textElement.textContent.trim();\n                        console.log('Creating individual text object: \"'.concat(textContent, '\"'));\n                        // Get text style from this specific run\n                        const rPr = this.findElementByTagName(textRun, \"rPr\");\n                        const textStyle = rPr ? this.extractTextStyleFromRun(rPr) : this.extractTextStyle(textBox);\n                        // Calculate position based on paragraph and text run index\n                        // This creates a more natural text layout\n                        const textLeft = baseTransform.left + i * 10;\n                        const textTop = baseTransform.top + i * 30 + j * 20;\n                        const textWidth = Math.max(200, textContent.length * 8) // Width based on text length\n                        ;\n                        const textHeight = 30;\n                        // Create a separate text object for this text element\n                        const textObject = {\n                            id: crypto.randomUUID(),\n                            type: \"text\",\n                            transform: {\n                                left: textLeft,\n                                top: textTop,\n                                width: textWidth,\n                                height: textHeight,\n                                angle: baseTransform.angle,\n                                scaleX: baseTransform.scaleX,\n                                scaleY: baseTransform.scaleY,\n                                flipX: baseTransform.flipX,\n                                flipY: baseTransform.flipY\n                            },\n                            style: textStyle,\n                            content: textContent\n                        };\n                        textObjects.push(textObject);\n                    }\n                }\n            }\n        } catch (error) {\n            console.error(\"Error extracting individual text elements:\", error);\n        }\n        return textObjects;\n    }\n    extractTextStyleFromRun(rPr) {\n        return {\n            fontFamily: rPr.getAttribute(\"typeface\") || \"Arial\",\n            fontSize: parseInt(rPr.getAttribute(\"sz\") || \"1800\") / 100,\n            fontWeight: rPr.getAttribute(\"b\") === \"1\" ? \"bold\" : \"normal\",\n            fontStyle: rPr.getAttribute(\"i\") === \"1\" ? \"italic\" : \"normal\",\n            textDecoration: rPr.getAttribute(\"u\") === \"1\" ? \"underline\" : \"none\",\n            color: this.extractColor(rPr),\n            textAlign: \"left\",\n            lineHeight: 1.2\n        };\n    }\n    constructor(){\n        this.zip = null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9wcHR4UGFyc2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QjtBQUdsQixNQUFNQztJQUdYLE1BQU1DLFVBQVVDLElBQVUsRUFBeUI7UUFDakQsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFFWixvQkFBb0I7WUFDcEIsSUFBSSxDQUFDQyxHQUFHLEdBQUcsTUFBTU4sc0RBQWUsQ0FBQ0c7WUFDakNDLFFBQVFDLEdBQUcsQ0FBQztZQUVaLCtCQUErQjtZQUMvQixNQUFNRyxZQUFZQyxPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDSixHQUFHLENBQUNLLEtBQUs7WUFDNUNQLFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUJHO1lBRTdCLHFCQUFxQjtZQUNyQixNQUFNSSxTQUFTLE1BQU0sSUFBSSxDQUFDQyxVQUFVO1lBQ3BDLE1BQU1DLGFBQWEsTUFBTSxJQUFJLENBQUNDLHFCQUFxQjtZQUVuRFgsUUFBUUMsR0FBRyxDQUFDO1lBRVosT0FBTztnQkFDTFcsSUFBSUMsT0FBT0MsVUFBVTtnQkFDckJDLE1BQU1oQixLQUFLZ0IsSUFBSSxDQUFDQyxPQUFPLENBQUMsU0FBUztnQkFDakNSO2dCQUNBUyxVQUFVUDtZQUNaO1FBQ0YsRUFBRSxPQUFPUSxPQUFPO1lBQ2RsQixRQUFRa0IsS0FBSyxDQUFDLDRCQUE0QkE7WUFDMUMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsTUFBY1Asd0JBQXNEO1FBQ2xFLElBQUk7Z0JBQ2dCO1lBQWxCLE1BQU1RLGFBQVksZ0JBQUksQ0FBQ2pCLEdBQUcsY0FBUiwwQ0FBVUgsSUFBSSxDQUFDO1lBQ2pDLElBQUlvQixXQUFXO2dCQUNiLE1BQU1DLFVBQVUsTUFBTUQsVUFBVUUsS0FBSyxDQUFDO2dCQUN0QyxNQUFNQyxTQUFTLElBQUlDO2dCQUNuQixNQUFNQyxNQUFNRixPQUFPRyxlQUFlLENBQUNMLFNBQVM7Z0JBRTVDLE1BQU1NLGdCQUFnQkYsSUFBSUcsYUFBYSxDQUFDO2dCQUN4QyxPQUFPO29CQUNMQyxRQUFRRixDQUFBQSwwQkFBQUEsb0NBQUFBLGNBQWVHLFdBQVcsS0FBSUM7Z0JBQ3hDO1lBQ0Y7UUFDRixFQUFFLE9BQU9aLE9BQU87WUFDZGxCLFFBQVErQixJQUFJLENBQUMsMkNBQTJDYjtRQUMxRDtRQUVBLE9BQU8sQ0FBQztJQUNWO0lBRUEsTUFBY1QsYUFBK0I7UUFDM0MsTUFBTUQsU0FBa0IsRUFBRTtRQUUxQixJQUFJO2dCQUVtQjtZQURyQix3Q0FBd0M7WUFDeEMsTUFBTXdCLGdCQUFlLGdCQUFJLENBQUM5QixHQUFHLGNBQVIsMENBQVVILElBQUksQ0FBQztZQUNwQyxJQUFJaUMsY0FBYztnQkFDaEIsTUFBTVosVUFBVSxNQUFNWSxhQUFhWCxLQUFLLENBQUM7Z0JBQ3pDckIsUUFBUUMsR0FBRyxDQUFDLDZCQUE2Qm1CLFFBQVFhLFNBQVMsQ0FBQyxHQUFHLE9BQU87Z0JBRXJFLE1BQU1YLFNBQVMsSUFBSUM7Z0JBQ25CLE1BQU1DLE1BQU1GLE9BQU9HLGVBQWUsQ0FBQ0wsU0FBUztnQkFFNUMseUNBQXlDO2dCQUN6QyxJQUFJYyxXQUFXVixJQUFJVyxvQkFBb0IsQ0FBQztnQkFDeENuQyxRQUFRQyxHQUFHLENBQUMsU0FBeUIsT0FBaEJpQyxTQUFTRSxNQUFNLEVBQUM7Z0JBRXJDLGlEQUFpRDtnQkFDakQsSUFBSUYsU0FBU0UsTUFBTSxLQUFLLEdBQUc7d0JBRU07b0JBRC9CLHVEQUF1RDtvQkFDdkQsTUFBTUMsYUFBYWhDLE9BQU9DLElBQUksQ0FBQyxtQkFBSSxDQUFDSixHQUFHLGNBQVIsNENBQVVLLEtBQUssS0FBSSxDQUFDLEdBQ2hEK0IsTUFBTSxDQUFDdkIsQ0FBQUEsT0FBUUEsS0FBS3dCLFVBQVUsQ0FBQyx1QkFBdUJ4QixLQUFLeUIsUUFBUSxDQUFDLFNBQ3BFQyxJQUFJO29CQUVQekMsUUFBUUMsR0FBRyxDQUFDLCtCQUErQm9DO29CQUUzQyxJQUFJQSxXQUFXRCxNQUFNLEdBQUcsR0FBRzt3QkFDekIsd0NBQXdDO3dCQUN4QyxJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSUwsV0FBV0QsTUFBTSxFQUFFTSxJQUFLOzRCQUMxQyxNQUFNQyxZQUFZTixVQUFVLENBQUNLLEVBQUU7NEJBQy9CLE1BQU1FLGNBQWNGLElBQUk7NEJBQ3hCMUMsUUFBUUMsR0FBRyxDQUFDLDBCQUFvQyxPQUFWMEM7NEJBRXRDLE1BQU1FLFFBQVEsTUFBTSxJQUFJLENBQUNDLGlCQUFpQixDQUFDSCxXQUFXQzs0QkFDdEQsSUFBSUMsT0FBTztnQ0FDVHJDLE9BQU91QyxJQUFJLENBQUNGO2dDQUNaN0MsUUFBUUMsR0FBRyxDQUFDLDZCQUF5QyxPQUFaMkMsYUFBWTs0QkFDdkQ7d0JBQ0Y7b0JBQ0Y7Z0JBQ0YsT0FBTztvQkFDTCw4Q0FBOEM7b0JBQzlDLElBQUssSUFBSUYsSUFBSSxHQUFHQSxJQUFJUixTQUFTRSxNQUFNLEVBQUVNLElBQUs7d0JBQ3hDLE1BQU1NLFVBQVVkLFFBQVEsQ0FBQ1EsRUFBRSxDQUFDTyxZQUFZLENBQUM7d0JBQ3pDakQsUUFBUUMsR0FBRyxDQUFDLG9CQUFzQytDLE9BQWxCTixJQUFJLEdBQUUsY0FBb0IsT0FBUk07d0JBQ2xELElBQUlBLFNBQVM7NEJBQ1gsTUFBTUgsUUFBUSxNQUFNLElBQUksQ0FBQ0ssU0FBUyxDQUFDRixTQUFTTixJQUFJOzRCQUNoRCxJQUFJRyxPQUFPO2dDQUNUckMsT0FBT3VDLElBQUksQ0FBQ0Y7Z0NBQ1o3QyxRQUFRQyxHQUFHLENBQUMsNkJBQW1DLE9BQU55QyxJQUFJOzRCQUMvQyxPQUFPO2dDQUNMMUMsUUFBUStCLElBQUksQ0FBQyx3QkFBOEIsT0FBTlcsSUFBSTs0QkFDM0M7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRixPQUFPO2dCQUNMMUMsUUFBUStCLElBQUksQ0FBQztZQUNmO1FBQ0YsRUFBRSxPQUFPYixPQUFPO1lBQ2RsQixRQUFRa0IsS0FBSyxDQUFDLHlCQUF5QkE7WUFDdkMsMENBQTBDO1lBQzFDVixPQUFPdUMsSUFBSSxDQUFDLElBQUksQ0FBQ0ksa0JBQWtCO1FBQ3JDO1FBRUFuRCxRQUFRQyxHQUFHLENBQUMsd0JBQXNDLE9BQWRPLE9BQU80QixNQUFNO1FBQ2pELE9BQU81QixPQUFPNEIsTUFBTSxHQUFHLElBQUk1QixTQUFTO1lBQUMsSUFBSSxDQUFDMkMsa0JBQWtCO1NBQUc7SUFDakU7SUFFQSxNQUFjRCxVQUFVRixPQUFlLEVBQUVKLFdBQW1CLEVBQXlCO1FBQ25GLElBQUk7Z0JBRWM7WUFEaEIsNENBQTRDO1lBQzVDLElBQUlELGFBQVksZ0JBQUksQ0FBQ3pDLEdBQUcsY0FBUiwwQ0FBVUgsSUFBSSxDQUFDLG1CQUErQixPQUFaNkMsYUFBWTtZQUU5RCxxREFBcUQ7WUFDckQsSUFBSSxDQUFDRCxXQUFXO29CQUNHO2dCQUFqQixNQUFNUyxZQUFXLGlCQUFJLENBQUNsRCxHQUFHLGNBQVIsNENBQVVILElBQUksQ0FBQyx5QkFBcUMsT0FBWjZDLGFBQVk7Z0JBQ3JFLElBQUlRLFVBQVU7d0JBS1FDO29CQUpwQixNQUFNQyxhQUFhLE1BQU1GLFNBQVMvQixLQUFLLENBQUM7b0JBQ3hDLE1BQU1rQyxZQUFZLElBQUloQztvQkFDdEIsTUFBTThCLFNBQVNFLFVBQVU5QixlQUFlLENBQUM2QixZQUFZO29CQUVyRCxNQUFNRSxlQUFjSCx3QkFBQUEsT0FBTzFCLGFBQWEsQ0FBQyxvQkFBNEIsT0FBUnFCLFNBQVEsb0JBQWpESyw0Q0FBQUEsc0JBQXVESixZQUFZLENBQUM7b0JBQ3hGLElBQUlPLGFBQWE7NEJBRUg7d0JBRFosTUFBTUMsWUFBWSxjQUEyQyxPQUE3QkQsWUFBWUUsS0FBSyxDQUFDLEtBQUtDLEdBQUc7d0JBQzFEaEIsYUFBWSxpQkFBSSxDQUFDekMsR0FBRyxjQUFSLDRDQUFVSCxJQUFJLENBQUMwRDtvQkFDN0I7Z0JBQ0Y7WUFDRjtZQUVBLGlEQUFpRDtZQUNqRCxJQUFJLENBQUNkLFdBQVc7b0JBQ2lCO2dCQUEvQixNQUFNTixhQUFhaEMsT0FBT0MsSUFBSSxDQUFDLG1CQUFJLENBQUNKLEdBQUcsY0FBUiw0Q0FBVUssS0FBSyxLQUFJLENBQUMsR0FDaEQrQixNQUFNLENBQUN2QixDQUFBQSxPQUFRQSxLQUFLd0IsVUFBVSxDQUFDLHVCQUF1QnhCLEtBQUt5QixRQUFRLENBQUMsU0FDcEVDLElBQUk7Z0JBRVAsSUFBSUosV0FBV0QsTUFBTSxHQUFHLEdBQUc7d0JBRWI7b0JBRFosTUFBTXdCLGNBQWN2QixVQUFVLENBQUNPLGNBQWMsRUFBRSxJQUFJUCxVQUFVLENBQUMsRUFBRTtvQkFDaEVNLGFBQVksaUJBQUksQ0FBQ3pDLEdBQUcsY0FBUiw0Q0FBVUgsSUFBSSxDQUFDNkQ7Z0JBQzdCO1lBQ0Y7WUFFQSxJQUFJLENBQUNqQixXQUFXO2dCQUNkM0MsUUFBUStCLElBQUksQ0FBQyx1Q0FBbUQsT0FBWmE7Z0JBQ3BELE9BQU87WUFDVDtZQUVBLE1BQU1pQixlQUFlLE1BQU1sQixVQUFVdEIsS0FBSyxDQUFDO1lBQzNDLE1BQU15QyxjQUFjLElBQUl2QztZQUN4QixNQUFNd0MsV0FBV0QsWUFBWXJDLGVBQWUsQ0FBQ29DLGNBQWM7WUFFM0QsMkJBQTJCO1lBQzNCLE1BQU1HLFFBQVFELFNBQVM1QixvQkFBb0IsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUN2RCxNQUFNOEIsUUFBUUMsU0FBU0YsQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPZixZQUFZLENBQUMsVUFBUyxhQUFhLE1BQU0seUJBQXlCOztZQUNoRyxNQUFNa0IsU0FBU0QsU0FBU0YsQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPZixZQUFZLENBQUMsVUFBUyxhQUFhO1lBRWxFLGlCQUFpQjtZQUNqQixNQUFNbUIsVUFBVSxNQUFNLElBQUksQ0FBQ0MsYUFBYSxDQUFDTixVQUFVbkI7WUFFbkQsT0FBTztnQkFDTGhDLElBQUlDLE9BQU9DLFVBQVU7Z0JBQ3JCQyxNQUFNLFNBQXFCLE9BQVo2QjtnQkFDZnFCO2dCQUNBRTtnQkFDQUM7WUFDRjtRQUNGLEVBQUUsT0FBT2xELE9BQU87WUFDZGxCLFFBQVFrQixLQUFLLENBQUMsdUJBQW1DLE9BQVowQixhQUFZLE1BQUkxQjtZQUNyRCxPQUFPO1FBQ1Q7SUFDRjtJQUVBLE1BQWM0QixrQkFBa0J3QixhQUFxQixFQUFFMUIsV0FBbUIsRUFBeUI7UUFDakcsSUFBSTtnQkFDZ0I7WUFBbEIsTUFBTUQsYUFBWSxnQkFBSSxDQUFDekMsR0FBRyxjQUFSLDBDQUFVSCxJQUFJLENBQUN1RTtZQUNqQyxJQUFJLENBQUMzQixXQUFXO2dCQUNkM0MsUUFBUStCLElBQUksQ0FBQyw4QkFBNEMsT0FBZHVDO2dCQUMzQyxPQUFPO1lBQ1Q7WUFFQSxNQUFNVCxlQUFlLE1BQU1sQixVQUFVdEIsS0FBSyxDQUFDO1lBQzNDckIsUUFBUUMsR0FBRyxDQUFDLFNBQXFCLE9BQVoyQyxhQUFZLGtCQUFnQmlCLGFBQWE1QixTQUFTLENBQUMsR0FBRyxRQUFRO1lBRW5GLE1BQU02QixjQUFjLElBQUl2QztZQUN4QixNQUFNd0MsV0FBV0QsWUFBWXJDLGVBQWUsQ0FBQ29DLGNBQWM7WUFFM0QsMERBQTBEO1lBQzFELElBQUlHLFFBQVFELFNBQVM1QixvQkFBb0IsQ0FBQyxRQUFRLENBQUMsRUFBRTtZQUNyRCxJQUFJLENBQUM2QixPQUFPO2dCQUNWQSxRQUFRRCxTQUFTNUIsb0JBQW9CLENBQUMsVUFBVSxDQUFDLEVBQUU7WUFDckQ7WUFFQSxJQUFJOEIsUUFBUSxLQUFLRSxTQUFTLElBQUkscUJBQXFCOztZQUNuRCxJQUFJSCxPQUFPO2dCQUNULE1BQU1PLEtBQUtQLE1BQU1mLFlBQVksQ0FBQztnQkFDOUIsTUFBTXVCLEtBQUtSLE1BQU1mLFlBQVksQ0FBQztnQkFDOUJqRCxRQUFRQyxHQUFHLENBQUMsU0FBcUIsT0FBWjJDLGFBQVksMEJBQXdCO29CQUFFMkI7b0JBQUlDO2dCQUFHO2dCQUVsRSxJQUFJRCxNQUFNQyxJQUFJO29CQUNaLHlCQUF5QjtvQkFDekIsTUFBTUMsYUFBYSxLQUFLO29CQUN4QlIsUUFBUUMsU0FBU0ssTUFBTUU7b0JBQ3ZCTixTQUFTRCxTQUFTTSxNQUFNQztvQkFDeEJ6RSxRQUFRQyxHQUFHLENBQUMsU0FBcUIsT0FBWjJDLGFBQVksMkJBQXlCO3dCQUFFcUI7d0JBQU9FO29CQUFPO2dCQUM1RTtZQUNGLE9BQU87Z0JBQ0xuRSxRQUFRK0IsSUFBSSxDQUFDLDJCQUF1QyxPQUFaYSxhQUFZO1lBQ3REO1lBRUEsaUJBQWlCO1lBQ2pCLE1BQU13QixVQUFVLE1BQU0sSUFBSSxDQUFDQyxhQUFhLENBQUNOLFVBQVVuQjtZQUVuRCxPQUFPO2dCQUNMaEMsSUFBSUMsT0FBT0MsVUFBVTtnQkFDckJDLE1BQU0sU0FBcUIsT0FBWjZCO2dCQUNmcUIsT0FBT1MsS0FBS0MsR0FBRyxDQUFDVixPQUFPO2dCQUN2QkUsUUFBUU8sS0FBS0MsR0FBRyxDQUFDUixRQUFRO2dCQUN6QkM7WUFDRjtRQUNGLEVBQUUsT0FBT2xELE9BQU87WUFDZGxCLFFBQVFrQixLQUFLLENBQUMsaUNBQStDLE9BQWRvRCxlQUFjLE1BQUlwRDtZQUNqRSxPQUFPO1FBQ1Q7SUFDRjtJQUVBLE1BQWNtRCxjQUFjTixRQUFrQixFQUFFbkIsV0FBbUIsRUFBMEI7UUFDM0YsTUFBTXdCLFVBQXlCLEVBQUU7UUFFakMsSUFBSTtZQUNGcEUsUUFBUUMsR0FBRyxDQUFDLGdDQUE0QyxPQUFaMkM7WUFFNUMseUNBQXlDO1lBRXpDLDJEQUEyRDtZQUMzRCxrREFBa0Q7WUFDbEQsSUFBSWdDLFNBQVMsSUFBSSxDQUFDQyxvQkFBb0IsQ0FBQ2QsVUFBVTtZQUNqRCxJQUFJYSxRQUFRO2dCQUNWLE1BQU1FLFlBQVksSUFBSSxDQUFDQyxxQkFBcUIsQ0FBQ0gsUUFBUTtnQkFDckQ1RSxRQUFRQyxHQUFHLENBQUMsU0FBMEIsT0FBakI2RSxVQUFVMUMsTUFBTSxFQUFDO2dCQUV0QyxJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSW9DLFVBQVUxQyxNQUFNLEVBQUVNLElBQUs7b0JBQ3pDLE1BQU1zQyxVQUFVRixTQUFTLENBQUNwQyxFQUFFO29CQUM1QjFDLFFBQVFDLEdBQUcsQ0FBQyxvQkFBMEIsT0FBTnlDLElBQUksR0FBRSxNQUFJc0MsUUFBUUMsT0FBTyxFQUFFRCxRQUFRL0IsWUFBWSxDQUFDLE9BQU8rQixRQUFRL0IsWUFBWSxDQUFDO29CQUU1RyxpQ0FBaUM7b0JBQ2pDLE1BQU1pQyxPQUFPLElBQUksQ0FBQ0wsb0JBQW9CLENBQUNHLFNBQVM7b0JBQ2hELE1BQU1HLEtBQUtELE9BQU8sSUFBSSxDQUFDTCxvQkFBb0IsQ0FBQ0ssTUFBTSxRQUFRO29CQUMxRCxJQUFJQyxJQUFJO3dCQUNOLE1BQU1DLFNBQVNELEdBQUdsQyxZQUFZLENBQUM7d0JBQy9CakQsUUFBUUMsR0FBRyxDQUFDLFNBQTRDbUYsT0FBbkMxQyxJQUFJLEdBQUUsK0JBQW9DLE9BQVAwQztvQkFDMUQ7b0JBRUEsbUNBQW1DO29CQUNuQyxNQUFNQyxRQUFRLElBQUksQ0FBQ1Isb0JBQW9CLENBQUNHLFNBQVM7b0JBQ2pELElBQUlLLE9BQU87d0JBQ1RyRixRQUFRQyxHQUFHLENBQUMsU0FBZSxPQUFOeUMsSUFBSSxHQUFFO3dCQUMzQixNQUFNNEMsY0FBYyxJQUFJLENBQUNDLG1CQUFtQixDQUFDRixPQUFPekMsYUFBYUY7d0JBQ2pFLElBQUk0QyxhQUFhO2dDQUVtREE7NEJBRGxFbEIsUUFBUXJCLElBQUksQ0FBQ3VDOzRCQUNidEYsUUFBUUMsR0FBRyxDQUFDLHdDQUFzRHFGLE9BQWQ1QyxJQUFJLEdBQUUsVUFBMEMsT0FBbEM0QyxFQUFBQSx3QkFBQUEsWUFBWUUsUUFBUSxjQUFwQkYsNENBQUFBLHNCQUFzQmxELE1BQU0sS0FBSSxHQUFFO3dCQUN0Rzt3QkFDQTtvQkFDRjtvQkFFQSxnQ0FBZ0M7b0JBQ2hDLE1BQU1xRCxTQUFTLElBQUksQ0FBQ1osb0JBQW9CLENBQUNHLFNBQVM7b0JBQ2xELE1BQU1VLFVBQVVELFVBQVUsSUFBSSxDQUFDVixxQkFBcUIsQ0FBQ1UsUUFBUSxLQUFLckQsTUFBTSxHQUFHO29CQUUzRSxJQUFJc0QsU0FBUzt3QkFDWCw4RUFBOEU7d0JBQzlFMUYsUUFBUUMsR0FBRyxDQUFDLFNBQWUsT0FBTnlDLElBQUksR0FBRTt3QkFDM0IsTUFBTWlELGNBQWMsSUFBSSxDQUFDQyw2QkFBNkIsQ0FBQ1osU0FBU3BDLGFBQWFGO3dCQUM3RTBCLFFBQVFyQixJQUFJLElBQUk0Qzt3QkFDaEIzRixRQUFRQyxHQUFHLENBQUMsYUFBMkR5QyxPQUE5Q2lELFlBQVl2RCxNQUFNLEVBQUMsNkJBQWlDLE9BQU5NLElBQUk7b0JBQzdFLE9BQU87d0JBQ0wsOENBQThDO3dCQUM5QzFDLFFBQVFDLEdBQUcsQ0FBQyxTQUFlLE9BQU55QyxJQUFJLEdBQUU7d0JBQzNCLE1BQU1tRCxRQUFRLElBQUksQ0FBQ0MsaUJBQWlCLENBQUNkLFNBQVNwQyxhQUFhRjt3QkFDM0QsSUFBSW1ELE9BQU87NEJBQ1R6QixRQUFRckIsSUFBSSxDQUFDOEM7NEJBQ2I3RixRQUFRQyxHQUFHLENBQUMsc0NBQTRDLE9BQU55QyxJQUFJLEdBQUUsTUFBSW1ELE1BQU1FLElBQUk7d0JBQ3hFO29CQUNGO2dCQUNGO1lBQ0YsT0FBTztnQkFDTC9GLFFBQVErQixJQUFJLENBQUM7WUFDZjtZQUVBLG9EQUFvRDtZQUNwRCxJQUFJcUMsUUFBUWhDLE1BQU0sS0FBSyxHQUFHO2dCQUN4QnBDLFFBQVFDLEdBQUcsQ0FBQztnQkFFWixpREFBaUQ7Z0JBQ2pELE1BQU0rRixnQkFBZ0IsSUFBSSxDQUFDakIscUJBQXFCLENBQUNoQixVQUFVO2dCQUMzRC9ELFFBQVFDLEdBQUcsQ0FBQyxTQUE4QixPQUFyQitGLGNBQWM1RCxNQUFNLEVBQUM7Z0JBRTFDLElBQUssSUFBSU0sSUFBSSxHQUFHQSxJQUFJc0QsY0FBYzVELE1BQU0sRUFBRU0sSUFBSztvQkFDN0MsTUFBTXVELFlBQVlELGFBQWEsQ0FBQ3RELEVBQUU7b0JBQ2xDMUMsUUFBUUMsR0FBRyxDQUFDLHlCQUErQixPQUFOeUMsSUFBSSxHQUFFLE1BQUl1RCxVQUFVaEIsT0FBTyxFQUFFZ0IsVUFBVWhELFlBQVksQ0FBQztvQkFFekYsaUNBQWlDO29CQUNqQyxNQUFNb0MsUUFBUSxJQUFJLENBQUNSLG9CQUFvQixDQUFDb0IsV0FBVztvQkFDbkQsSUFBSVosT0FBTzt3QkFDVHJGLFFBQVFDLEdBQUcsQ0FBQyxjQUFvQixPQUFOeUMsSUFBSSxHQUFFO3dCQUNoQyxNQUFNNEMsY0FBYyxJQUFJLENBQUNDLG1CQUFtQixDQUFDRixPQUFPekMsYUFBYUY7d0JBQ2pFLElBQUk0QyxhQUFhOzRCQUNmbEIsUUFBUXJCLElBQUksQ0FBQ3VDO3dCQUNmO3dCQUNBO29CQUNGO29CQUVBLE1BQU1HLFNBQVMsSUFBSSxDQUFDWixvQkFBb0IsQ0FBQ29CLFdBQVc7b0JBQ3BELE1BQU1QLFVBQVVELFVBQVUsSUFBSSxDQUFDVixxQkFBcUIsQ0FBQ1UsUUFBUSxLQUFLckQsTUFBTSxHQUFHO29CQUUzRSxJQUFJc0QsU0FBUzt3QkFDWCxNQUFNQyxjQUFjLElBQUksQ0FBQ0MsNkJBQTZCLENBQUNLLFdBQVdyRCxhQUFhRjt3QkFDL0UwQixRQUFRckIsSUFBSSxJQUFJNEM7b0JBQ2xCLE9BQU87d0JBQ0wsTUFBTUUsUUFBUSxJQUFJLENBQUNDLGlCQUFpQixDQUFDRyxXQUFXckQsYUFBYUY7d0JBQzdELElBQUltRCxPQUFPOzRCQUNUekIsUUFBUXJCLElBQUksQ0FBQzhDO3dCQUNmO29CQUNGO2dCQUNGO1lBQ0Y7WUFFQSw4Q0FBOEM7WUFDOUMsSUFBSXpCLFFBQVFoQyxNQUFNLEtBQUssR0FBRztnQkFDeEJwQyxRQUFRQyxHQUFHLENBQUM7Z0JBRVosTUFBTWlHLGVBQWUsSUFBSSxDQUFDbkIscUJBQXFCLENBQUNoQixVQUFVO2dCQUMxRC9ELFFBQVFDLEdBQUcsQ0FBQyxTQUE2QixPQUFwQmlHLGFBQWE5RCxNQUFNLEVBQUM7Z0JBRXpDLElBQUk4RCxhQUFhOUQsTUFBTSxHQUFHLEdBQUc7b0JBQzNCLDBEQUEwRDtvQkFDMUQsTUFBTStELFlBQVlELFlBQVksQ0FBQyxFQUFFO29CQUNqQyxNQUFNckUsY0FBY3NFLFVBQVV0RSxXQUFXLElBQUk7b0JBQzdDN0IsUUFBUUMsR0FBRyxDQUFDLHVDQUFtRCxPQUFaNEIsYUFBWTtvQkFFL0QsTUFBTXVFLGFBQTBCO3dCQUM5QnhGLElBQUlDLE9BQU9DLFVBQVU7d0JBQ3JCaUYsTUFBTTt3QkFDTk0sV0FBVzs0QkFDVEMsTUFBTTs0QkFDTkMsS0FBSzs0QkFDTHRDLE9BQU87NEJBQ1BFLFFBQVE7NEJBQ1JxQyxPQUFPOzRCQUNQQyxRQUFROzRCQUNSQyxRQUFROzRCQUNSQyxPQUFPOzRCQUNQQyxPQUFPO3dCQUNUO3dCQUNBQyxPQUFPOzRCQUNMQyxZQUFZOzRCQUNaQyxVQUFVOzRCQUNWQyxZQUFZOzRCQUNaQyxXQUFXOzRCQUNYQyxnQkFBZ0I7NEJBQ2hCQyxPQUFPOzRCQUNQQyxXQUFXOzRCQUNYQyxZQUFZO3dCQUNkO3dCQUNBakcsU0FBU1M7b0JBQ1g7b0JBRUF1QyxRQUFRckIsSUFBSSxDQUFDcUQ7b0JBQ2JwRyxRQUFRQyxHQUFHLENBQUM7Z0JBQ2Q7WUFDRjtZQUVBLGlCQUFpQjtZQUNqQixNQUFNcUgsU0FBUyxJQUFJLENBQUN2QyxxQkFBcUIsQ0FBQ2hCLFVBQVU7WUFDcEQvRCxRQUFRQyxHQUFHLENBQUMsU0FBdUIsT0FBZHFILE9BQU9sRixNQUFNLEVBQUM7WUFDbkMsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUk0RSxPQUFPbEYsTUFBTSxFQUFFTSxJQUFLO2dCQUN0QyxNQUFNNkUsUUFBUUQsTUFBTSxDQUFDNUUsRUFBRTtnQkFDdkIsTUFBTW1ELFFBQVEsTUFBTSxJQUFJLENBQUMyQixZQUFZLENBQUNELE9BQU8zRSxhQUFhRjtnQkFDMUQsSUFBSW1ELE9BQU87b0JBQ1R6QixRQUFRckIsSUFBSSxDQUFDOEM7b0JBQ2I3RixRQUFRQyxHQUFHLENBQUMsZ0NBQXNDLE9BQU55QyxJQUFJO2dCQUNsRDtZQUNGO1lBRUExQyxRQUFRQyxHQUFHLENBQUMsNEJBQTJDLE9BQWZtRSxRQUFRaEMsTUFBTTtZQUN0RHBDLFFBQVFDLEdBQUcsQ0FBQyxrQkFBa0JtRSxRQUFRcUQsR0FBRyxDQUFDQyxDQUFBQSxNQUFRO29CQUFFM0IsTUFBTTJCLElBQUkzQixJQUFJO29CQUFFM0UsU0FBU3NHLElBQUl0RyxPQUFPO29CQUFFaUYsV0FBV3FCLElBQUlyQixTQUFTO2dCQUFDO1FBQ3JILEVBQUUsT0FBT25GLE9BQU87WUFDZGxCLFFBQVFrQixLQUFLLENBQUMsNEJBQTRCQTtRQUM1QztRQUVBLE9BQU9rRDtJQUNUO0lBRUEsMENBQTBDO0lBQ2xDUyxxQkFBcUI4QyxNQUEwQixFQUFFMUMsT0FBZSxFQUFrQjtRQUN4Riw4Q0FBOEM7UUFDOUMsSUFBSTJDLFVBQVVELE9BQU94RixvQkFBb0IsQ0FBQzhDLFFBQVEsQ0FBQyxFQUFFO1FBQ3JELElBQUkyQyxTQUFTLE9BQU9BO1FBRXBCLG1EQUFtRDtRQUNuRCxNQUFNQyxXQUFXO1lBQUM7WUFBTTtZQUFNO1lBQU07U0FBRztRQUN2QyxLQUFLLE1BQU1DLFVBQVVELFNBQVU7WUFDN0IsTUFBTUUsY0FBY0QsU0FBUzdDO1lBQzdCMkMsVUFBVUQsT0FBT3hGLG9CQUFvQixDQUFDNEYsWUFBWSxDQUFDLEVBQUU7WUFDckQsSUFBSUgsU0FBUyxPQUFPQTtRQUN0QjtRQUVBLDBDQUEwQztRQUMxQyxNQUFNSSxjQUFjTCxPQUFPeEYsb0JBQW9CLENBQUM7UUFDaEQsSUFBSyxJQUFJTyxJQUFJLEdBQUdBLElBQUlzRixZQUFZNUYsTUFBTSxFQUFFTSxJQUFLO1lBQzNDLE1BQU11RixLQUFLRCxXQUFXLENBQUN0RixFQUFFO1lBQ3pCLElBQUl1RixHQUFHaEQsT0FBTyxDQUFDekMsUUFBUSxDQUFDeUMsWUFBWWdELEdBQUdoRCxPQUFPLENBQUNpRCxRQUFRLENBQUNqRCxVQUFVO2dCQUNoRSxPQUFPZ0Q7WUFDVDtRQUNGO1FBRUEsT0FBTztJQUNUO0lBRVFsRCxzQkFBc0I0QyxNQUEwQixFQUFFMUMsT0FBZSxFQUFhO1FBQ3BGLDJDQUEyQztRQUMzQyxJQUFJa0QsV0FBV0MsTUFBTUMsSUFBSSxDQUFDVixPQUFPeEYsb0JBQW9CLENBQUM4QztRQUN0RCxJQUFJa0QsU0FBUy9GLE1BQU0sR0FBRyxHQUFHLE9BQU8rRjtRQUVoQyxtREFBbUQ7UUFDbkQsTUFBTU4sV0FBVztZQUFDO1lBQU07WUFBTTtZQUFNO1NBQUc7UUFDdkMsS0FBSyxNQUFNQyxVQUFVRCxTQUFVO1lBQzdCLE1BQU1FLGNBQWNELFNBQVM3QztZQUM3QmtELFdBQVdDLE1BQU1DLElBQUksQ0FBQ1YsT0FBT3hGLG9CQUFvQixDQUFDNEY7WUFDbEQsSUFBSUksU0FBUy9GLE1BQU0sR0FBRyxHQUFHLE9BQU8rRjtRQUNsQztRQUVBLDBDQUEwQztRQUMxQyxNQUFNSCxjQUFjTCxPQUFPeEYsb0JBQW9CLENBQUM7UUFDaEQsTUFBTW1HLG1CQUE4QixFQUFFO1FBQ3RDLElBQUssSUFBSTVGLElBQUksR0FBR0EsSUFBSXNGLFlBQVk1RixNQUFNLEVBQUVNLElBQUs7WUFDM0MsTUFBTXVGLEtBQUtELFdBQVcsQ0FBQ3RGLEVBQUU7WUFDekIsSUFBSXVGLEdBQUdoRCxPQUFPLENBQUN6QyxRQUFRLENBQUN5QyxZQUFZZ0QsR0FBR2hELE9BQU8sQ0FBQ2lELFFBQVEsQ0FBQ2pELFVBQVU7Z0JBQ2hFcUQsaUJBQWlCdkYsSUFBSSxDQUFDa0Y7WUFDeEI7UUFDRjtRQUVBLE9BQU9LO0lBQ1Q7SUFFQSxNQUFjZCxhQUFhRCxLQUFjLEVBQUUzRSxXQUFtQixFQUFFMkYsS0FBYSxFQUErQjtRQUMxRyxJQUFJO1lBQ0Z2SSxRQUFRQyxHQUFHLENBQUMsMkJBQStDMkMsT0FBcEIyRixPQUFNLGdCQUEwQixPQUFaM0Y7WUFFM0QsTUFBTTRGLE9BQU8sSUFBSSxDQUFDM0Qsb0JBQW9CLENBQUMwQyxPQUFPO1lBQzlDLElBQUksQ0FBQ2lCLE1BQU0sT0FBTztZQUVsQixNQUFNbkMsWUFBWSxJQUFJLENBQUNvQyxnQkFBZ0IsQ0FBQ0Q7WUFFeEMsOENBQThDO1lBQzlDLE1BQU1FLFdBQVcsSUFBSSxDQUFDN0Qsb0JBQW9CLENBQUMwQyxPQUFPO1lBQ2xELElBQUltQixVQUFVO2dCQUNaLE1BQU1DLE9BQU8sSUFBSSxDQUFDOUQsb0JBQW9CLENBQUM2RCxVQUFVO2dCQUNqRCxJQUFJQyxNQUFNO29CQUNSLE1BQU1DLFFBQVFELEtBQUsxRixZQUFZLENBQUM7b0JBQ2hDLE1BQU00RixPQUFPRixLQUFLMUYsWUFBWSxDQUFDO29CQUUvQmpELFFBQVFDLEdBQUcsQ0FBQyxTQUE2QjJJLE9BQXBCTCxPQUFNLGdCQUE4Qk0sT0FBaEJELE9BQU0sWUFBZSxPQUFMQztvQkFFekQsSUFBSUQsU0FBU0MsTUFBTTt3QkFDakIsb0NBQW9DO3dCQUNwQyxNQUFNQyxVQUFVRixTQUFTQzt3QkFDekIsTUFBTUUsWUFBWSxNQUFNLElBQUksQ0FBQ0MsYUFBYSxDQUFDRjt3QkFFM0MsSUFBSUMsV0FBVzs0QkFDYi9JLFFBQVFDLEdBQUcsQ0FBQyw0QkFBMkMsT0FBZjhJLFVBQVVoSSxJQUFJOzRCQUV0RCw0QkFBNEI7NEJBQzVCLE1BQU1rSSxZQUFZLE1BQU1GLFVBQVUxSCxLQUFLLENBQUM7NEJBQ3hDLE1BQU02SCxXQUFXLElBQUksQ0FBQ0MsV0FBVyxDQUFDSixVQUFVaEksSUFBSTs0QkFDaEQsTUFBTXFJLFVBQVUsUUFBMkJILE9BQW5CQyxVQUFTLFlBQW9CLE9BQVZEOzRCQUUzQyxPQUFPO2dDQUNMckksSUFBSUMsT0FBT0MsVUFBVTtnQ0FDckJpRixNQUFNO2dDQUNOTTtnQ0FDQVEsT0FBTyxDQUFDO2dDQUNSd0MsS0FBS0Q7NEJBQ1A7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUVBLG9FQUFvRTtZQUNwRXBKLFFBQVErQixJQUFJLENBQUMsaURBQXVELE9BQU53RyxPQUFNO1lBQ3BFLE9BQU87Z0JBQ0wzSCxJQUFJQyxPQUFPQyxVQUFVO2dCQUNyQmlGLE1BQU07Z0JBQ05NO2dCQUNBUSxPQUFPLENBQUM7Z0JBQ1J3QyxLQUFLLDZCQUF1TyxPQUExTUMsS0FBSztZQUN6QztRQUNGLEVBQUUsT0FBT3BJLE9BQU87WUFDZGxCLFFBQVFrQixLQUFLLENBQUMsMEJBQWdDLE9BQU5xSCxPQUFNLE1BQUlySDtZQUNsRCxPQUFPO1FBQ1Q7SUFDRjtJQUVBLE1BQWM4SCxjQUFjRixPQUFlLEVBQXFDO1FBQzlFLElBQUk7Z0JBRWUsV0F1Q1k7WUF4QzdCLDBDQUEwQztZQUMxQyxNQUFNUyxZQUFXLGdCQUFJLENBQUNySixHQUFHLGNBQVIsMENBQVVILElBQUksQ0FBQztZQUNoQyxJQUFJd0osVUFBVTtnQkFDWixNQUFNQyxjQUFjLE1BQU1ELFNBQVNsSSxLQUFLLENBQUM7Z0JBQ3pDLE1BQU1vSSxhQUFhLElBQUlsSTtnQkFDdkIsTUFBTW1JLFVBQVVELFdBQVdoSSxlQUFlLENBQUMrSCxhQUFhO2dCQUV4RCxNQUFNRyxlQUFlRCxRQUFRL0gsYUFBYSxDQUFDLG9CQUE0QixPQUFSbUgsU0FBUTtnQkFDdkUsSUFBSWEsY0FBYztvQkFDaEIsTUFBTUMsU0FBU0QsYUFBYTFHLFlBQVksQ0FBQztvQkFDekMsSUFBSTJHLFFBQVE7NEJBR1E7d0JBRmxCLG9DQUFvQzt3QkFDcEMsTUFBTUMsWUFBWUQsT0FBT3JILFVBQVUsQ0FBQyxPQUFPcUgsT0FBT0UsS0FBSyxDQUFDLEtBQUssT0FBYyxPQUFQRjt3QkFDcEUsTUFBTWIsYUFBWSxpQkFBSSxDQUFDN0ksR0FBRyxjQUFSLDRDQUFVSCxJQUFJLENBQUM4Sjt3QkFDakMsSUFBSWQsV0FBVzs0QkFDYi9JLFFBQVFDLEdBQUcsQ0FBQyx1Q0FBaUQsT0FBVjRKOzRCQUNuRCxPQUFPZDt3QkFDVDtvQkFDRjtnQkFDRjtZQUNGO1lBRUEseUJBQXlCO1lBQ3pCLE1BQU1nQixjQUFjO2dCQUNqQixrQkFBeUIsT0FBUmpCLFNBQVE7Z0JBQ3pCLGtCQUF5QixPQUFSQSxTQUFRO2dCQUN6QixrQkFBeUIsT0FBUkEsU0FBUTtnQkFDekIsa0JBQXlCLE9BQVJBLFNBQVE7Z0JBQ3pCLGtCQUF5QixPQUFSQSxTQUFRO2FBQzNCO1lBRUQsS0FBSyxNQUFNa0IsUUFBUUQsWUFBYTtvQkFDWjtnQkFBbEIsTUFBTWhCLGFBQVksaUJBQUksQ0FBQzdJLEdBQUcsY0FBUiw0Q0FBVUgsSUFBSSxDQUFDaUs7Z0JBQ2pDLElBQUlqQixXQUFXO29CQUNiL0ksUUFBUUMsR0FBRyxDQUFDLHFDQUEwQyxPQUFMK0o7b0JBQ2pELE9BQU9qQjtnQkFDVDtZQUNGO1lBRUEsc0NBQXNDO1lBQ3RDLE1BQU1rQixXQUFXNUosT0FBT0MsSUFBSSxDQUFDLG1CQUFJLENBQUNKLEdBQUcsY0FBUiw0Q0FBVUssS0FBSyxLQUFJLENBQUM7WUFDakQsTUFBTTJKLGFBQWFELFNBQVMzSCxNQUFNLENBQUN2QixDQUFBQSxPQUNqQ0EsS0FBS21ILFFBQVEsQ0FBQyxZQUNibkgsQ0FBQUEsS0FBS3lCLFFBQVEsQ0FBQyxXQUFXekIsS0FBS3lCLFFBQVEsQ0FBQyxXQUFXekIsS0FBS3lCLFFBQVEsQ0FBQyxZQUFZekIsS0FBS3lCLFFBQVEsQ0FBQyxXQUFXekIsS0FBS3lCLFFBQVEsQ0FBQyxPQUFNO1lBRzVIeEMsUUFBUUMsR0FBRyxDQUFDLFNBQTJCLE9BQWxCaUssV0FBVzlILE1BQU0sRUFBQyxrQ0FBZ0M4SDtZQUV2RSw4Q0FBOEM7WUFDOUMsS0FBSyxNQUFNTCxhQUFhSyxXQUFZO2dCQUNsQyxJQUFJTCxVQUFVM0IsUUFBUSxDQUFDWSxZQUFZZSxVQUFVM0IsUUFBUSxDQUFDLFFBQWdCLE9BQVJZLFdBQVk7d0JBQ3REO29CQUFsQixNQUFNQyxhQUFZLGlCQUFJLENBQUM3SSxHQUFHLGNBQVIsNENBQVVILElBQUksQ0FBQzhKO29CQUNqQyxJQUFJZCxXQUFXO3dCQUNiL0ksUUFBUUMsR0FBRyxDQUFDLGtDQUE0QyxPQUFWNEo7d0JBQzlDLE9BQU9kO29CQUNUO2dCQUNGO1lBQ0Y7WUFFQSxPQUFPO1FBQ1QsRUFBRSxPQUFPN0gsT0FBTztZQUNkbEIsUUFBUWtCLEtBQUssQ0FBQyw2QkFBNkJBO1lBQzNDLE9BQU87UUFDVDtJQUNGO0lBRVFpSSxZQUFZZ0IsUUFBZ0IsRUFBVTtZQUNoQ0E7UUFBWixNQUFNQyxPQUFNRCxzQkFBQUEsU0FBU3pHLEtBQUssQ0FBQyxLQUFLQyxHQUFHLGdCQUF2QndHLDBDQUFBQSxvQkFBMkJFLFdBQVc7UUFDbEQsT0FBUUQ7WUFDTixLQUFLO2dCQUFPLE9BQU87WUFDbkIsS0FBSztZQUNMLEtBQUs7Z0JBQVEsT0FBTztZQUNwQixLQUFLO2dCQUFPLE9BQU87WUFDbkIsS0FBSztnQkFBTyxPQUFPO1lBQ25CLEtBQUs7Z0JBQU8sT0FBTztZQUNuQjtnQkFBUyxPQUFPO1FBQ2xCO0lBQ0Y7SUFFQSxNQUFjN0Usb0JBQW9CRixLQUFjLEVBQUV6QyxXQUFtQixFQUFFMkYsS0FBYSxFQUErQjtRQUNqSCxJQUFJO1lBQ0Z2SSxRQUFRQyxHQUFHLENBQUMsNEJBQWdEMkMsT0FBcEIyRixPQUFNLGdCQUEwQixPQUFaM0Y7WUFFNUQsZ0NBQWdDO1lBQ2hDLE1BQU0wSCxVQUFVLElBQUksQ0FBQ3pGLG9CQUFvQixDQUFDUSxPQUFPO1lBQ2pELE1BQU1nQixZQUFZaUUsVUFBVSxJQUFJLENBQUM3QixnQkFBZ0IsQ0FBQzZCLFdBQVc7Z0JBQzNEaEUsTUFBTTtnQkFDTkMsS0FBSztnQkFDTHRDLE9BQU87Z0JBQ1BFLFFBQVE7Z0JBQ1JxQyxPQUFPO2dCQUNQQyxRQUFRO2dCQUNSQyxRQUFRO2dCQUNSQyxPQUFPO2dCQUNQQyxPQUFPO1lBQ1Q7WUFFQSxzQ0FBc0M7WUFDdEMsTUFBTXBCLFdBQTBCLEVBQUU7WUFFbEMsd0NBQXdDO1lBQ3hDLE1BQU0rRSxrQkFBa0IsSUFBSSxDQUFDeEYscUJBQXFCLENBQUNNLE9BQU87WUFDMURyRixRQUFRQyxHQUFHLENBQUMsU0FBeURzSSxPQUFoRGdDLGdCQUFnQm5JLE1BQU0sRUFBQywyQkFBK0IsT0FBTm1HO1lBRXJFLElBQUssSUFBSTdGLElBQUksR0FBR0EsSUFBSTZILGdCQUFnQm5JLE1BQU0sRUFBRU0sSUFBSztnQkFDL0MsTUFBTThILFVBQVVELGVBQWUsQ0FBQzdILEVBQUU7Z0JBQ2xDMUMsUUFBUUMsR0FBRyxDQUFDLDBCQUE0Q3NJLE9BQWxCN0YsSUFBSSxHQUFFLGNBQWtCLE9BQU42RjtnQkFFeEQsMEJBQTBCO2dCQUMxQixNQUFNOUMsU0FBUyxJQUFJLENBQUNaLG9CQUFvQixDQUFDMkYsU0FBUztnQkFDbEQsTUFBTTlFLFVBQVVELFVBQVUsSUFBSSxDQUFDVixxQkFBcUIsQ0FBQ1UsUUFBUSxLQUFLckQsTUFBTSxHQUFHO2dCQUUzRSxJQUFJc0QsU0FBUztvQkFDWCxrQ0FBa0M7b0JBQ2xDLE1BQU1DLGNBQWMsSUFBSSxDQUFDQyw2QkFBNkIsQ0FBQzRFLFNBQVM1SCxhQUFhRjtvQkFDN0U4QyxTQUFTekMsSUFBSSxJQUFJNEM7Z0JBQ25CLE9BQU87b0JBQ0wseUJBQXlCO29CQUN6QixNQUFNOEUsYUFBYSxJQUFJLENBQUMzRSxpQkFBaUIsQ0FBQzBFLFNBQVM1SCxhQUFhRjtvQkFDaEUsSUFBSStILFlBQVk7d0JBQ2RqRixTQUFTekMsSUFBSSxDQUFDMEg7b0JBQ2hCO2dCQUNGO1lBQ0Y7WUFFQSx5Q0FBeUM7WUFDekMsTUFBTUMsbUJBQW1CLElBQUksQ0FBQzNGLHFCQUFxQixDQUFDTSxPQUFPO1lBQzNEckYsUUFBUUMsR0FBRyxDQUFDLFNBQTBEc0ksT0FBakRtQyxpQkFBaUJ0SSxNQUFNLEVBQUMsMkJBQStCLE9BQU5tRztZQUV0RSxJQUFLLElBQUk3RixJQUFJLEdBQUdBLElBQUlnSSxpQkFBaUJ0SSxNQUFNLEVBQUVNLElBQUs7Z0JBQ2hELE1BQU1pSSxXQUFXRCxnQkFBZ0IsQ0FBQ2hJLEVBQUU7Z0JBQ3BDLE1BQU1rSSxhQUFhLE1BQU0sSUFBSSxDQUFDcEQsWUFBWSxDQUFDbUQsVUFBVS9ILGFBQWFGO2dCQUNsRSxJQUFJa0ksWUFBWTtvQkFDZHBGLFNBQVN6QyxJQUFJLENBQUM2SDtnQkFDaEI7WUFDRjtZQUVBLDBCQUEwQjtZQUMxQixNQUFNdEYsY0FBMkI7Z0JBQy9CMUUsSUFBSUMsT0FBT0MsVUFBVTtnQkFDckJpRixNQUFNO2dCQUNOTTtnQkFDQVEsT0FBTyxDQUFDO2dCQUNSckI7Z0JBQ0FxRixTQUFTLFNBQXdCdEMsT0FBZjNGLGFBQVksS0FBUyxPQUFOMkY7WUFDbkM7WUFFQXZJLFFBQVFDLEdBQUcsQ0FBQywwQ0FBMEQsT0FBaEJ1RixTQUFTcEQsTUFBTSxFQUFDO1lBQ3RFLE9BQU9rRDtRQUVULEVBQUUsT0FBT3BFLE9BQU87WUFDZGxCLFFBQVFrQixLQUFLLENBQUMsa0NBQXdDLE9BQU5xSCxPQUFNLE1BQUlySDtZQUMxRCxPQUFPO1FBQ1Q7SUFDRjtJQUVRNEUsa0JBQWtCRCxLQUFjLEVBQUVqRCxXQUFtQixFQUFFMkYsS0FBYSxFQUFzQjtRQUNoRyxJQUFJO2dCQXFHK0J1QztZQXBHakM5SyxRQUFRQyxHQUFHLENBQUMsMEJBQWtEMkMsT0FBeEIyRixRQUFRLEdBQUUsZ0JBQTBCLE9BQVozRjtZQUU5RCxNQUFNNEYsT0FBTyxJQUFJLENBQUMzRCxvQkFBb0IsQ0FBQ2dCLE9BQU87WUFDOUMsSUFBSSxDQUFDMkMsTUFBTTtnQkFDVHhJLFFBQVErQixJQUFJLENBQUMsZ0NBQTBDLE9BQVZ3RyxRQUFRO2dCQUNyRCxPQUFPO1lBQ1Q7WUFFQSxNQUFNbEMsWUFBWSxJQUFJLENBQUNvQyxnQkFBZ0IsQ0FBQ0Q7WUFFeEMsK0RBQStEO1lBQy9ELElBQUlzQyxXQUFXLElBQUksQ0FBQ2pHLG9CQUFvQixDQUFDMkQsTUFBTTtZQUMvQyxJQUFJdUMsWUFBOEM7WUFFbEQsSUFBSUQsVUFBVTtnQkFDWixNQUFNRSxPQUFPRixTQUFTN0gsWUFBWSxDQUFDO2dCQUNuQ2pELFFBQVFDLEdBQUcsQ0FBQyw0QkFBaUMsT0FBTCtLO2dCQUV4QyxnQ0FBZ0M7Z0JBQ2hDLE9BQVFBO29CQUNOLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7d0JBQ0hELFlBQVk7d0JBQ1o7b0JBQ0YsS0FBSztvQkFDTCxLQUFLO3dCQUNIQSxZQUFZO3dCQUNaO29CQUNGLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSztvQkFDTCxLQUFLO29CQUNMLEtBQUs7b0JBQ0wsS0FBSzt3QkFDSEEsWUFBWTt3QkFDWjtvQkFDRjt3QkFDRS9LLFFBQVFDLEdBQUcsQ0FBQyx1QkFBNEIsT0FBTCtLLE1BQUs7d0JBQ3hDRCxZQUFZO2dCQUNoQjtZQUNGLE9BQU87Z0JBQ0wsb0RBQW9EO2dCQUNwRCxNQUFNRSxXQUFXLElBQUksQ0FBQ3BHLG9CQUFvQixDQUFDMkQsTUFBTTtnQkFDakQsSUFBSXlDLFVBQVU7b0JBQ1pqTCxRQUFRQyxHQUFHLENBQUM7b0JBQ1o4SyxZQUFZO2dCQUNkLE9BQU87b0JBQ0wvSyxRQUFRQyxHQUFHLENBQUM7b0JBQ1o4SyxZQUFZO2dCQUNkO1lBQ0Y7WUFFQS9LLFFBQVFDLEdBQUcsQ0FBQywrQkFBeUMsT0FBVjhLLFdBQVUsaUJBQWUxRTtZQUVwRSw4RUFBOEU7WUFDOUUsSUFBSWpGLFVBQVU7WUFDZCxNQUFNcUUsU0FBUyxJQUFJLENBQUNaLG9CQUFvQixDQUFDZ0IsT0FBTztZQUNoRCxJQUFJSixRQUFRO2dCQUNWckUsVUFBVSxJQUFJLENBQUM4SixrQkFBa0IsQ0FBQ3JGO1lBQ3BDO1lBRUEsaUNBQWlDO1lBQ2pDLE1BQU1YLE9BQU8sSUFBSSxDQUFDTCxvQkFBb0IsQ0FBQ2dCLE9BQU87WUFDOUMsTUFBTVYsS0FBS0QsT0FBTyxJQUFJLENBQUNMLG9CQUFvQixDQUFDSyxNQUFNLFFBQVE7WUFDMUQsSUFBSUMsSUFBSTtnQkFDTixNQUFNQyxTQUFTRCxHQUFHbEMsWUFBWSxDQUFDO2dCQUMvQixJQUFJbUMsV0FBVyxTQUFTO29CQUN0QmhFLFVBQVU7Z0JBQ1osT0FBTyxJQUFJZ0UsV0FBVyxRQUFRO29CQUM1QmhFLFVBQVU7Z0JBQ1osT0FBTyxJQUFJZ0UsV0FBVyxPQUFPO29CQUMzQmhFLFVBQVU7Z0JBQ1osT0FBTztvQkFDTEEsVUFBVTtnQkFDWjtZQUNGO1lBRUEsMkNBQTJDO1lBQzNDLE1BQU0rSixRQUFRLElBQUksQ0FBQ3RHLG9CQUFvQixDQUFDZ0IsT0FBTztZQUMvQyxNQUFNdUYsWUFBWUQsQ0FBQUEsa0JBQUFBLDRCQUFBQSxNQUFPbEksWUFBWSxDQUFDLFlBQVcsU0FBbUIsT0FBVnNGLFFBQVE7WUFDbEV2SSxRQUFRQyxHQUFHLENBQUMsZUFBeUIsT0FBVm1MO1lBRTNCLHVDQUF1QztZQUN2QyxNQUFNdkUsUUFBYTtnQkFDakJ3RSxNQUFNTixjQUFjLFNBQVMsZ0JBQWdCO2dCQUM3Q08sUUFBUTtnQkFDUkMsYUFBYVIsY0FBYyxTQUFTLElBQUk7WUFDMUM7WUFFQSwyQ0FBMkM7WUFDM0MsSUFBSUEsY0FBYyxnQkFBZUQscUJBQUFBLGdDQUFBQSx5QkFBQUEsU0FBVTdILFlBQVksQ0FBQyxxQkFBdkI2SCw2Q0FBQUEsdUJBQWdDNUMsUUFBUSxDQUFDLFdBQVU7Z0JBQ2xGckIsTUFBTTJFLEVBQUUsR0FBRztnQkFDWDNFLE1BQU00RSxFQUFFLEdBQUc7WUFDYjtZQUVBLE9BQU87Z0JBQ0w3SyxJQUFJQyxPQUFPQyxVQUFVO2dCQUNyQmlGLE1BQU1nRjtnQkFDTjFFO2dCQUNBUTtnQkFDQXpGLFNBQVNBLFdBQVdVO1lBQ3RCO1FBQ0YsRUFBRSxPQUFPWixPQUFPO1lBQ2RsQixRQUFRa0IsS0FBSyxDQUFDLGlDQUFpQ0E7WUFDL0MsT0FBTztRQUNUO0lBQ0Y7SUFFUXVILGlCQUFpQkQsSUFBYSxFQUFhO1FBQ2pELG1DQUFtQztRQUNuQ3hJLFFBQVFDLEdBQUcsQ0FBQyxtQ0FBbUN1SSxLQUFLa0QsU0FBUyxDQUFDekosU0FBUyxDQUFDLEdBQUcsT0FBTztRQUVsRiwwREFBMEQ7UUFDMUQsSUFBSTBKLE9BQU9uRCxLQUFLckcsb0JBQW9CLENBQUMsT0FBTyxDQUFDLEVBQUU7UUFDL0MsSUFBSSxDQUFDd0osTUFBTTtZQUNULDhCQUE4QjtZQUM5QkEsT0FBT25ELEtBQUtyRyxvQkFBb0IsQ0FBQyxTQUFTLENBQUMsRUFBRTtRQUMvQztRQUNBLElBQUksQ0FBQ3dKLE1BQU07WUFDVCxvQ0FBb0M7WUFDcEMsTUFBTTNELGNBQWNRLEtBQUtyRyxvQkFBb0IsQ0FBQztZQUM5QyxJQUFLLElBQUlPLElBQUksR0FBR0EsSUFBSXNGLFlBQVk1RixNQUFNLEVBQUVNLElBQUs7Z0JBQzNDLE1BQU11RixLQUFLRCxXQUFXLENBQUN0RixFQUFFO2dCQUN6QixJQUFJdUYsR0FBR2hELE9BQU8sQ0FBQ2lELFFBQVEsQ0FBQyxTQUFTO29CQUMvQnlELE9BQU8xRDtvQkFDUDtnQkFDRjtZQUNGO1FBQ0Y7UUFFQWpJLFFBQVFDLEdBQUcsQ0FBQyx1QkFBdUIwTCxpQkFBQUEsMkJBQUFBLEtBQU1ELFNBQVM7UUFFbEQsSUFBSUMsTUFBTTtZQUNSLG1FQUFtRTtZQUNuRSxJQUFJQyxNQUFNRCxLQUFLeEosb0JBQW9CLENBQUMsTUFBTSxDQUFDLEVBQUU7WUFDN0MsSUFBSSxDQUFDeUosS0FBS0EsTUFBTUQsS0FBS3hKLG9CQUFvQixDQUFDLFFBQVEsQ0FBQyxFQUFFO1lBRXJELElBQUlpSSxNQUFNdUIsS0FBS3hKLG9CQUFvQixDQUFDLE1BQU0sQ0FBQyxFQUFFO1lBQzdDLElBQUksQ0FBQ2lJLEtBQUtBLE1BQU11QixLQUFLeEosb0JBQW9CLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFFckQsSUFBSTBKLE1BQU1GLEtBQUt4SixvQkFBb0IsQ0FBQyxNQUFNLENBQUMsRUFBRTtZQUM3QyxJQUFJLENBQUMwSixLQUFLQSxNQUFNRixLQUFLeEosb0JBQW9CLENBQUMsUUFBUSxDQUFDLEVBQUU7WUFFckRuQyxRQUFRQyxHQUFHLENBQUMsNkJBQTZCMkwsZ0JBQUFBLDBCQUFBQSxJQUFLRixTQUFTLEVBQUUsUUFBUXRCLGdCQUFBQSwwQkFBQUEsSUFBS3NCLFNBQVMsRUFBRSxRQUFRRyxnQkFBQUEsMEJBQUFBLElBQUtILFNBQVM7WUFFdkcsNkNBQTZDO1lBQzdDLDJEQUEyRDtZQUMzRCx5Q0FBeUM7WUFDekMsNkNBQTZDO1lBQzdDLE1BQU1qSCxhQUFhLEtBQUs7WUFDeEIsTUFBTXFILGNBQWMsRUFBRSw0Q0FBNEM7O1lBRWxFLE1BQU14RixPQUFPcEMsU0FBUzBILENBQUFBLGdCQUFBQSwwQkFBQUEsSUFBSzNJLFlBQVksQ0FBQyxTQUFRLE9BQU93QixhQUFhcUg7WUFDcEUsTUFBTXZGLE1BQU1yQyxTQUFTMEgsQ0FBQUEsZ0JBQUFBLDBCQUFBQSxJQUFLM0ksWUFBWSxDQUFDLFNBQVEsT0FBT3dCLGFBQWFxSDtZQUNuRSxNQUFNN0gsUUFBUUMsU0FBU2tHLENBQUFBLGdCQUFBQSwwQkFBQUEsSUFBS25ILFlBQVksQ0FBQyxVQUFTLGFBQWF3QixhQUFhcUg7WUFDNUUsTUFBTTNILFNBQVNELFNBQVNrRyxDQUFBQSxnQkFBQUEsMEJBQUFBLElBQUtuSCxZQUFZLENBQUMsVUFBUyxhQUFhd0IsYUFBYXFIO1lBQzdFLE1BQU10RixRQUFRdEMsU0FBUzJILENBQUFBLGdCQUFBQSwwQkFBQUEsSUFBSzVJLFlBQVksQ0FBQyxXQUFVLE9BQU8sTUFBTSw0QkFBNEI7O1lBRTVGLE1BQU1vRCxZQUFZO2dCQUNoQkMsTUFBTTVCLEtBQUtDLEdBQUcsQ0FBQyxHQUFHMkI7Z0JBQ2xCQyxLQUFLN0IsS0FBS0MsR0FBRyxDQUFDLEdBQUc0QjtnQkFDakJ0QyxPQUFPUyxLQUFLQyxHQUFHLENBQUMsSUFBSVY7Z0JBQ3BCRSxRQUFRTyxLQUFLQyxHQUFHLENBQUMsSUFBSVI7Z0JBQ3JCcUM7Z0JBQ0FDLFFBQVE7Z0JBQ1JDLFFBQVE7Z0JBQ1JDLE9BQU87Z0JBQ1BDLE9BQU87WUFDVDtZQUVBNUcsUUFBUUMsR0FBRyxDQUFDLHFDQUFxQztnQkFDL0M4TCxPQUFPLEVBQUVILGdCQUFBQSwwQkFBQUEsSUFBSzNJLFlBQVksQ0FBQztnQkFDM0IrSSxNQUFNLEVBQUVKLGdCQUFBQSwwQkFBQUEsSUFBSzNJLFlBQVksQ0FBQztnQkFDMUJnSixRQUFRLEVBQUU3QixnQkFBQUEsMEJBQUFBLElBQUtuSCxZQUFZLENBQUM7Z0JBQzVCaUosU0FBUyxFQUFFOUIsZ0JBQUFBLDBCQUFBQSxJQUFLbkgsWUFBWSxDQUFDO1lBQy9CO1lBQ0FqRCxRQUFRQyxHQUFHLENBQUMsaUNBQWlDb0c7WUFDN0MsT0FBT0E7UUFDVDtRQUVBckcsUUFBUStCLElBQUksQ0FBQztRQUNiLE9BQU87WUFDTHVFLE1BQU07WUFDTkMsS0FBSztZQUNMdEMsT0FBTztZQUNQRSxRQUFRO1lBQ1JxQyxPQUFPO1lBQ1BDLFFBQVE7WUFDUkMsUUFBUTtZQUNSQyxPQUFPO1lBQ1BDLE9BQU87UUFDVDtJQUNGO0lBRVFzRSxtQkFBbUJsRyxPQUFnQixFQUFVO1FBQ25ELCtDQUErQztRQUMvQyxJQUFJNUQsVUFBVTtRQUVkLGlEQUFpRDtRQUNqRCxNQUFNcUUsU0FBUyxJQUFJLENBQUNaLG9CQUFvQixDQUFDRyxTQUFTO1FBQ2xELElBQUlTLFFBQVE7WUFDVixNQUFNMEcsYUFBYSxJQUFJLENBQUNwSCxxQkFBcUIsQ0FBQ1UsUUFBUTtZQUN0RHpGLFFBQVFDLEdBQUcsQ0FBQyxTQUEyQixPQUFsQmtNLFdBQVcvSixNQUFNLEVBQUM7WUFFdkMsSUFBSyxJQUFJTSxJQUFJLEdBQUdBLElBQUl5SixXQUFXL0osTUFBTSxFQUFFTSxJQUFLO2dCQUMxQyxNQUFNMEosWUFBWUQsVUFBVSxDQUFDekosRUFBRTtnQkFDL0IsTUFBTTJKLFdBQVcsSUFBSSxDQUFDdEgscUJBQXFCLENBQUNxSCxXQUFXO2dCQUN2RHBNLFFBQVFDLEdBQUcsQ0FBQyxhQUEwQm9NLE9BQWIzSixJQUFJLEdBQUUsU0FBdUIsT0FBaEIySixTQUFTakssTUFBTSxFQUFDO2dCQUV0RCxJQUFJa0ssZ0JBQWdCO2dCQUNwQixJQUFLLElBQUlDLElBQUksR0FBR0EsSUFBSUYsU0FBU2pLLE1BQU0sRUFBRW1LLElBQUs7b0JBQ3hDLE1BQU1DLFVBQVVILFFBQVEsQ0FBQ0UsRUFBRTtvQkFDM0IsTUFBTUUsY0FBYyxJQUFJLENBQUM1SCxvQkFBb0IsQ0FBQzJILFNBQVM7b0JBQ3ZELElBQUlDLGVBQWVBLFlBQVk1SyxXQUFXLEVBQUU7d0JBQzFDeUssaUJBQWlCRyxZQUFZNUssV0FBVzt3QkFDeEM3QixRQUFRQyxHQUFHLENBQUMsWUFBdUJ3TSxPQUFYRixJQUFJLEdBQUUsT0FBNkIsT0FBeEJFLFlBQVk1SyxXQUFXLEVBQUM7b0JBQzdEO2dCQUNGO2dCQUVBLGdDQUFnQztnQkFDaEMsSUFBSXlLLGVBQWU7b0JBQ2pCLElBQUlsTCxTQUFTQSxXQUFXLEtBQUssb0NBQW9DOztvQkFDakVBLFdBQVdrTDtnQkFDYjtZQUNGO1FBQ0Y7UUFFQSxvREFBb0Q7UUFDcEQsSUFBSSxDQUFDbEwsU0FBUztZQUNaLE1BQU04RSxlQUFlLElBQUksQ0FBQ25CLHFCQUFxQixDQUFDQyxTQUFTO1lBQ3pEaEYsUUFBUUMsR0FBRyxDQUFDLFNBQTZCLE9BQXBCaUcsYUFBYTlELE1BQU0sRUFBQztZQUV6QyxJQUFLLElBQUlNLElBQUksR0FBR0EsSUFBSXdELGFBQWE5RCxNQUFNLEVBQUVNLElBQUs7Z0JBQzVDLE1BQU1rRixVQUFVMUIsWUFBWSxDQUFDeEQsRUFBRTtnQkFDL0IsSUFBSWtGLFFBQVEvRixXQUFXLEVBQUU7b0JBQ3ZCLElBQUlULFNBQVNBLFdBQVc7b0JBQ3hCQSxXQUFXd0csUUFBUS9GLFdBQVc7b0JBQzlCN0IsUUFBUUMsR0FBRyxDQUFDLHVCQUFrQzJILE9BQVhsRixJQUFJLEdBQUUsT0FBeUIsT0FBcEJrRixRQUFRL0YsV0FBVyxFQUFDO2dCQUNwRTtZQUNGO1FBQ0Y7UUFFQSxzREFBc0Q7UUFDdEQsSUFBSSxDQUFDVCxTQUFTO1lBQ1pBLFVBQVU0RCxRQUFRbkQsV0FBVyxJQUFJO1lBQ2pDN0IsUUFBUUMsR0FBRyxDQUFDLDJCQUFtQyxPQUFSbUIsU0FBUTtRQUNqRDtRQUVBcEIsUUFBUUMsR0FBRyxDQUFDLGtDQUEwQyxPQUFSbUIsU0FBUTtRQUN0RCxPQUFPQSxXQUFXO0lBQ3BCO0lBRVFzTCxpQkFBaUIxSCxPQUFnQixFQUFzQjtRQUM3RCxNQUFNMkgsU0FBUyxJQUFJLENBQUM5SCxvQkFBb0IsQ0FBQ0csU0FBUztRQUVsRCxJQUFJMkgsUUFBUTtZQUNWLE9BQU87Z0JBQ0w3RixZQUFZNkYsT0FBTzFKLFlBQVksQ0FBQyxlQUFlO2dCQUMvQzhELFVBQVU3QyxTQUFTeUksT0FBTzFKLFlBQVksQ0FBQyxTQUFTLFVBQVU7Z0JBQzFEK0QsWUFBWTJGLE9BQU8xSixZQUFZLENBQUMsU0FBUyxNQUFNLFNBQVM7Z0JBQ3hEZ0UsV0FBVzBGLE9BQU8xSixZQUFZLENBQUMsU0FBUyxNQUFNLFdBQVc7Z0JBQ3pEaUUsZ0JBQWdCeUYsT0FBTzFKLFlBQVksQ0FBQyxTQUFTLE1BQU0sY0FBYztnQkFDakVrRSxPQUFPLElBQUksQ0FBQ3lGLFlBQVksQ0FBQ0Q7Z0JBQ3pCdkYsV0FBVztnQkFDWEMsWUFBWTtZQUNkO1FBQ0Y7UUFFQSxPQUFPO1lBQ0xQLFlBQVk7WUFDWkMsVUFBVTtZQUNWQyxZQUFZO1lBQ1pDLFdBQVc7WUFDWEMsZ0JBQWdCO1lBQ2hCQyxPQUFPO1lBQ1BDLFdBQVc7WUFDWEMsWUFBWTtRQUNkO0lBQ0Y7SUFFUXVGLGFBQWFELE1BQWUsRUFBVTtRQUM1QyxNQUFNRSxZQUFZLElBQUksQ0FBQ2hJLG9CQUFvQixDQUFDOEgsUUFBUTtRQUNwRCxJQUFJRSxXQUFXO1lBQ2IsTUFBTUMsVUFBVSxJQUFJLENBQUNqSSxvQkFBb0IsQ0FBQ2dJLFdBQVc7WUFDckQsSUFBSUMsU0FBUztnQkFDWCxNQUFNQyxNQUFNRCxRQUFRN0osWUFBWSxDQUFDO2dCQUNqQyxJQUFJOEosS0FBSztvQkFDUCxPQUFPLElBQVEsT0FBSkE7Z0JBQ2I7WUFDRjtRQUNGO1FBQ0EsT0FBTztJQUNUO0lBRVFDLG1CQUFtQnhFLElBQWEsRUFBb0M7UUFDMUUsOERBQThEO1FBQzlELElBQUlzQyxXQUFXdEMsS0FBS3JHLG9CQUFvQixDQUFDLFdBQVcsQ0FBQyxFQUFFO1FBQ3ZELElBQUksQ0FBQzJJLFVBQVU7WUFDYkEsV0FBV3RDLEtBQUtyRyxvQkFBb0IsQ0FBQyxhQUFhLENBQUMsRUFBRTtRQUN2RDtRQUVBLElBQUkySSxVQUFVO1lBQ1osTUFBTUUsT0FBT0YsU0FBUzdILFlBQVksQ0FBQztZQUNuQ2pELFFBQVFDLEdBQUcsQ0FBQyxxQkFBMEIsT0FBTCtLO1lBRWpDLE9BQVFBO2dCQUNOLEtBQUs7Z0JBQ0wsS0FBSztvQkFDSCxPQUFPO2dCQUNULEtBQUs7Z0JBQ0wsS0FBSztvQkFDSCxPQUFPO2dCQUNULEtBQUs7Z0JBQ0wsS0FBSztvQkFDSCxPQUFPO2dCQUNUO29CQUNFaEwsUUFBUUMsR0FBRyxDQUFDLHVCQUE0QixPQUFMK0ssTUFBSztvQkFDeEMsT0FBTztZQUNYO1FBQ0Y7UUFFQSwrREFBK0Q7UUFDL0RoTCxRQUFRQyxHQUFHLENBQUM7UUFDWixPQUFPO0lBQ1Q7SUFFUWtELHFCQUE0QjtRQUNsQyxPQUFPO1lBQ0x2QyxJQUFJQyxPQUFPQyxVQUFVO1lBQ3JCQyxNQUFNO1lBQ05rRCxPQUFPO1lBQ1BFLFFBQVE7WUFDUkMsU0FBUztnQkFDUDtvQkFDRXhELElBQUlDLE9BQU9DLFVBQVU7b0JBQ3JCaUYsTUFBTTtvQkFDTk0sV0FBVzt3QkFDVEMsTUFBTTt3QkFDTkMsS0FBSzt3QkFDTHRDLE9BQU87d0JBQ1BFLFFBQVE7d0JBQ1JxQyxPQUFPO3dCQUNQQyxRQUFRO3dCQUNSQyxRQUFRO3dCQUNSQyxPQUFPO3dCQUNQQyxPQUFPO29CQUNUO29CQUNBQyxPQUFPO3dCQUNMQyxZQUFZO3dCQUNaQyxVQUFVO3dCQUNWQyxZQUFZO3dCQUNaRyxPQUFPO3dCQUNQQyxXQUFXO29CQUNiO29CQUNBaEcsU0FBUztnQkFDWDthQUNEO1FBQ0g7SUFDRjtJQUVRd0UsOEJBQThCWixPQUFnQixFQUFFcEMsV0FBbUIsRUFBRXFLLFVBQWtCLEVBQWlCO1FBQzlHLE1BQU10SCxjQUE2QixFQUFFO1FBRXJDLElBQUk7WUFDRixNQUFNRixTQUFTLElBQUksQ0FBQ1osb0JBQW9CLENBQUNHLFNBQVM7WUFDbEQsSUFBSSxDQUFDUyxRQUFRLE9BQU9FO1lBRXBCLHdDQUF3QztZQUN4QyxNQUFNNkMsT0FBTyxJQUFJLENBQUMzRCxvQkFBb0IsQ0FBQ0csU0FBUztZQUNoRCxNQUFNa0ksZ0JBQWdCMUUsT0FBTyxJQUFJLENBQUNDLGdCQUFnQixDQUFDRCxRQUFRO2dCQUN6RGxDLE1BQU07Z0JBQ05DLEtBQUs7Z0JBQ0x0QyxPQUFPO2dCQUNQRSxRQUFRO2dCQUNScUMsT0FBTztnQkFDUEMsUUFBUTtnQkFDUkMsUUFBUTtnQkFDUkMsT0FBTztnQkFDUEMsT0FBTztZQUNUO1lBRUEsTUFBTXVGLGFBQWEsSUFBSSxDQUFDcEgscUJBQXFCLENBQUNVLFFBQVE7WUFDdER6RixRQUFRQyxHQUFHLENBQUMsY0FBdUVnTixPQUF6RGQsV0FBVy9KLE1BQU0sRUFBQyx5Q0FBc0QsT0FBZjZLLGFBQWE7WUFFaEcsSUFBSyxJQUFJdkssSUFBSSxHQUFHQSxJQUFJeUosV0FBVy9KLE1BQU0sRUFBRU0sSUFBSztnQkFDMUMsTUFBTTBKLFlBQVlELFVBQVUsQ0FBQ3pKLEVBQUU7Z0JBQy9CLE1BQU0ySixXQUFXLElBQUksQ0FBQ3RILHFCQUFxQixDQUFDcUgsV0FBVztnQkFFdkQsSUFBSyxJQUFJRyxJQUFJLEdBQUdBLElBQUlGLFNBQVNqSyxNQUFNLEVBQUVtSyxJQUFLO29CQUN4QyxNQUFNQyxVQUFVSCxRQUFRLENBQUNFLEVBQUU7b0JBQzNCLE1BQU1FLGNBQWMsSUFBSSxDQUFDNUgsb0JBQW9CLENBQUMySCxTQUFTO29CQUV2RCxJQUFJQyxlQUFlQSxZQUFZNUssV0FBVyxJQUFJNEssWUFBWTVLLFdBQVcsQ0FBQ3NMLElBQUksSUFBSTt3QkFDNUUsTUFBTXRMLGNBQWM0SyxZQUFZNUssV0FBVyxDQUFDc0wsSUFBSTt3QkFDaERuTixRQUFRQyxHQUFHLENBQUMscUNBQWlELE9BQVo0QixhQUFZO3dCQUU3RCx3Q0FBd0M7d0JBQ3hDLE1BQU11TCxNQUFNLElBQUksQ0FBQ3ZJLG9CQUFvQixDQUFDMkgsU0FBUzt3QkFDL0MsTUFBTWEsWUFBWUQsTUFBTSxJQUFJLENBQUNFLHVCQUF1QixDQUFDRixPQUFPLElBQUksQ0FBQ1YsZ0JBQWdCLENBQUMxSDt3QkFFbEYsMkRBQTJEO3dCQUMzRCwwQ0FBMEM7d0JBQzFDLE1BQU11SSxXQUFXTCxjQUFjNUcsSUFBSSxHQUFJNUQsSUFBSTt3QkFDM0MsTUFBTThLLFVBQVVOLGNBQWMzRyxHQUFHLEdBQUk3RCxJQUFJLEtBQU82SixJQUFJO3dCQUNwRCxNQUFNa0IsWUFBWS9JLEtBQUtDLEdBQUcsQ0FBQyxLQUFLOUMsWUFBWU8sTUFBTSxHQUFHLEdBQUcsNkJBQTZCOzt3QkFDckYsTUFBTXNMLGFBQWE7d0JBRW5CLHNEQUFzRDt3QkFDdEQsTUFBTXRILGFBQTBCOzRCQUM5QnhGLElBQUlDLE9BQU9DLFVBQVU7NEJBQ3JCaUYsTUFBTTs0QkFDTk0sV0FBVztnQ0FDVEMsTUFBTWlIO2dDQUNOaEgsS0FBS2lIO2dDQUNMdkosT0FBT3dKO2dDQUNQdEosUUFBUXVKO2dDQUNSbEgsT0FBTzBHLGNBQWMxRyxLQUFLO2dDQUMxQkMsUUFBUXlHLGNBQWN6RyxNQUFNO2dDQUM1QkMsUUFBUXdHLGNBQWN4RyxNQUFNO2dDQUM1QkMsT0FBT3VHLGNBQWN2RyxLQUFLO2dDQUMxQkMsT0FBT3NHLGNBQWN0RyxLQUFLOzRCQUM1Qjs0QkFDQUMsT0FBT3dHOzRCQUNQak0sU0FBU1M7d0JBQ1g7d0JBRUE4RCxZQUFZNUMsSUFBSSxDQUFDcUQ7b0JBQ25CO2dCQUNGO1lBQ0Y7UUFDRixFQUFFLE9BQU9sRixPQUFPO1lBQ2RsQixRQUFRa0IsS0FBSyxDQUFDLDhDQUE4Q0E7UUFDOUQ7UUFFQSxPQUFPeUU7SUFDVDtJQUVRMkgsd0JBQXdCRixHQUFZLEVBQXNCO1FBQ2hFLE9BQU87WUFDTHRHLFlBQVlzRyxJQUFJbkssWUFBWSxDQUFDLGVBQWU7WUFDNUM4RCxVQUFVN0MsU0FBU2tKLElBQUluSyxZQUFZLENBQUMsU0FBUyxVQUFVO1lBQ3ZEK0QsWUFBWW9HLElBQUluSyxZQUFZLENBQUMsU0FBUyxNQUFNLFNBQVM7WUFDckRnRSxXQUFXbUcsSUFBSW5LLFlBQVksQ0FBQyxTQUFTLE1BQU0sV0FBVztZQUN0RGlFLGdCQUFnQmtHLElBQUluSyxZQUFZLENBQUMsU0FBUyxNQUFNLGNBQWM7WUFDOURrRSxPQUFPLElBQUksQ0FBQ3lGLFlBQVksQ0FBQ1E7WUFDekJoRyxXQUFXO1lBQ1hDLFlBQVk7UUFDZDtJQUNGOzthQTdtQ1FuSCxNQUFvQjs7QUE4bUM5QiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9zcmMvdXRpbHMvcHB0eFBhcnNlci50cz9lMThmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBKU1ppcCBmcm9tICdqc3ppcCdcclxuaW1wb3J0IHsgUFBUWERvY3VtZW50LCBTbGlkZSwgU2hhcGVPYmplY3QsIFRyYW5zZm9ybSwgVGV4dFN0eWxlIH0gZnJvbSAnQC90eXBlcy9wcHR4J1xyXG5cclxuZXhwb3J0IGNsYXNzIFBQVFhQYXJzZXIge1xyXG4gIHByaXZhdGUgemlwOiBKU1ppcCB8IG51bGwgPSBudWxsXHJcblxyXG4gIGFzeW5jIHBhcnNlRmlsZShmaWxlOiBGaWxlKTogUHJvbWlzZTxQUFRYRG9jdW1lbnQ+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdTdGFydGluZyBQUFRYIHBhcnNpbmcuLi4nKVxyXG4gICAgICBcclxuICAgICAgLy8gTG9hZCB0aGUgWklQIGZpbGVcclxuICAgICAgdGhpcy56aXAgPSBhd2FpdCBKU1ppcC5sb2FkQXN5bmMoZmlsZSlcclxuICAgICAgY29uc29sZS5sb2coJ1pJUCBmaWxlIGxvYWRlZCBzdWNjZXNzZnVsbHknKVxyXG4gICAgICBcclxuICAgICAgLy8gTGlzdCBhbGwgZmlsZXMgZm9yIGRlYnVnZ2luZ1xyXG4gICAgICBjb25zdCBmaWxlTmFtZXMgPSBPYmplY3Qua2V5cyh0aGlzLnppcC5maWxlcylcclxuICAgICAgY29uc29sZS5sb2coJ0ZpbGVzIGluIFpJUDonLCBmaWxlTmFtZXMpXHJcbiAgICAgIFxyXG4gICAgICAvLyBQYXJzZSB0aGUgZG9jdW1lbnRcclxuICAgICAgY29uc3Qgc2xpZGVzID0gYXdhaXQgdGhpcy5yZWFkU2xpZGVzKClcclxuICAgICAgY29uc3QgcHJvcGVydGllcyA9IGF3YWl0IHRoaXMucmVhZFByZXNlbnRhdGlvblByb3BzKClcclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdQYXJzaW5nIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgICBuYW1lOiBmaWxlLm5hbWUucmVwbGFjZSgnLnBwdHgnLCAnJyksXHJcbiAgICAgICAgc2xpZGVzLFxyXG4gICAgICAgIG1ldGFkYXRhOiBwcm9wZXJ0aWVzLFxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIFBQVFggZmlsZTonLCBlcnJvcilcclxuICAgICAgdGhyb3cgZXJyb3JcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmVhZFByZXNlbnRhdGlvblByb3BzKCk6IFByb21pc2U8eyBhdXRob3I/OiBzdHJpbmcgfT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgY29yZVByb3BzID0gdGhpcy56aXA/LmZpbGUoJ2RvY1Byb3BzL2NvcmUueG1sJylcclxuICAgICAgaWYgKGNvcmVQcm9wcykge1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBjb3JlUHJvcHMuYXN5bmMoJ3RleHQnKVxyXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKVxyXG4gICAgICAgIGNvbnN0IHhtbCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoY29udGVudCwgJ3RleHQveG1sJylcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCBhdXRob3JFbGVtZW50ID0geG1sLnF1ZXJ5U2VsZWN0b3IoJ2RjXFxcXDpjcmVhdG9yLCBjcmVhdG9yJylcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgYXV0aG9yOiBhdXRob3JFbGVtZW50Py50ZXh0Q29udGVudCB8fCB1bmRlZmluZWRcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybignQ291bGQgbm90IHJlYWQgcHJlc2VudGF0aW9uIHByb3BlcnRpZXM6JywgZXJyb3IpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB7fVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyByZWFkU2xpZGVzKCk6IFByb21pc2U8U2xpZGVbXT4ge1xyXG4gICAgY29uc3Qgc2xpZGVzOiBTbGlkZVtdID0gW11cclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgLy8gR2V0IHNsaWRlIGNvdW50IGZyb20gcHJlc2VudGF0aW9uLnhtbFxyXG4gICAgICBjb25zdCBwcmVzZW50YXRpb24gPSB0aGlzLnppcD8uZmlsZSgncHB0L3ByZXNlbnRhdGlvbi54bWwnKVxyXG4gICAgICBpZiAocHJlc2VudGF0aW9uKSB7XHJcbiAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHByZXNlbnRhdGlvbi5hc3luYygndGV4dCcpXHJcbiAgICAgICAgY29uc29sZS5sb2coJ1ByZXNlbnRhdGlvbiBYTUwgY29udGVudDonLCBjb250ZW50LnN1YnN0cmluZygwLCA1MDApICsgJy4uLicpXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgcGFyc2VyID0gbmV3IERPTVBhcnNlcigpXHJcbiAgICAgICAgY29uc3QgeG1sID0gcGFyc2VyLnBhcnNlRnJvbVN0cmluZyhjb250ZW50LCAndGV4dC94bWwnKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRyeSBtdWx0aXBsZSBhcHByb2FjaGVzIHRvIGZpbmQgc2xpZGVzXHJcbiAgICAgICAgbGV0IHNsaWRlSWRzID0geG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzbGRJZCcpXHJcbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7c2xpZGVJZHMubGVuZ3RofSBzbGlkZXMgdXNpbmcgJ3NsZElkJyB0YWdgKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIElmIG5vIHNsaWRlcyBmb3VuZCwgdHJ5IGFsdGVybmF0aXZlIGFwcHJvYWNoZXNcclxuICAgICAgICBpZiAoc2xpZGVJZHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgICAvLyBUcnkgbG9va2luZyBmb3Igc2xpZGVzIGluIHRoZSBzbGlkZXMgZm9sZGVyIGRpcmVjdGx5XHJcbiAgICAgICAgICBjb25zdCBzbGlkZUZpbGVzID0gT2JqZWN0LmtleXModGhpcy56aXA/LmZpbGVzIHx8IHt9KVxyXG4gICAgICAgICAgICAuZmlsdGVyKG5hbWUgPT4gbmFtZS5zdGFydHNXaXRoKCdwcHQvc2xpZGVzL3NsaWRlJykgJiYgbmFtZS5lbmRzV2l0aCgnLnhtbCcpKVxyXG4gICAgICAgICAgICAuc29ydCgpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdGb3VuZCBzbGlkZSBmaWxlcyBkaXJlY3RseTonLCBzbGlkZUZpbGVzKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoc2xpZGVGaWxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBzbGlkZXMgZnJvbSB0aGUgZmlsZXMgd2UgZm91bmRcclxuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZUZpbGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc2xpZGVGaWxlID0gc2xpZGVGaWxlc1tpXVxyXG4gICAgICAgICAgICAgIGNvbnN0IHNsaWRlTnVtYmVyID0gaSArIDFcclxuICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBzbGlkZSBmaWxlOiAke3NsaWRlRmlsZX1gKVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGNvbnN0IHNsaWRlID0gYXdhaXQgdGhpcy5yZWFkU2xpZGVGcm9tRmlsZShzbGlkZUZpbGUsIHNsaWRlTnVtYmVyKVxyXG4gICAgICAgICAgICAgIGlmIChzbGlkZSkge1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzLnB1c2goc2xpZGUpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGxvYWRlZCBzbGlkZSAke3NsaWRlTnVtYmVyfSBmcm9tIGZpbGVgKVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAvLyBQcm9jZXNzIHNsaWRlcyB1c2luZyB0aGUgdHJhZGl0aW9uYWwgbWV0aG9kXHJcbiAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNsaWRlSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlSWQgPSBzbGlkZUlkc1tpXS5nZXRBdHRyaWJ1dGUoJ3I6aWQnKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBzbGlkZSAke2kgKyAxfSB3aXRoIElEOiAke3NsaWRlSWR9YClcclxuICAgICAgICAgICAgaWYgKHNsaWRlSWQpIHtcclxuICAgICAgICAgICAgICBjb25zdCBzbGlkZSA9IGF3YWl0IHRoaXMucmVhZFNsaWRlKHNsaWRlSWQsIGkgKyAxKVxyXG4gICAgICAgICAgICAgIGlmIChzbGlkZSkge1xyXG4gICAgICAgICAgICAgICAgc2xpZGVzLnB1c2goc2xpZGUpXHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGxvYWRlZCBzbGlkZSAke2kgKyAxfWApXHJcbiAgICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRmFpbGVkIHRvIGxvYWQgc2xpZGUgJHtpICsgMX1gKVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCBmaW5kIHByZXNlbnRhdGlvbi54bWwnKVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIHNsaWRlczonLCBlcnJvcilcclxuICAgICAgLy8gQ3JlYXRlIGEgZGVmYXVsdCBzbGlkZSBpZiBwYXJzaW5nIGZhaWxzXHJcbiAgICAgIHNsaWRlcy5wdXNoKHRoaXMuY3JlYXRlRGVmYXVsdFNsaWRlKCkpXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBUb3RhbCBzbGlkZXMgbG9hZGVkOiAke3NsaWRlcy5sZW5ndGh9YClcclxuICAgIHJldHVybiBzbGlkZXMubGVuZ3RoID4gMCA/IHNsaWRlcyA6IFt0aGlzLmNyZWF0ZURlZmF1bHRTbGlkZSgpXVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyByZWFkU2xpZGUoc2xpZGVJZDogc3RyaW5nLCBzbGlkZU51bWJlcjogbnVtYmVyKTogUHJvbWlzZTxTbGlkZSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIFRyeSB0byBmaW5kIHRoZSBzbGlkZSBmaWxlIGRpcmVjdGx5IGZpcnN0XHJcbiAgICAgIGxldCBzbGlkZUZpbGUgPSB0aGlzLnppcD8uZmlsZShgcHB0L3NsaWRlcy9zbGlkZSR7c2xpZGVOdW1iZXJ9LnhtbGApXHJcbiAgICAgIFxyXG4gICAgICAvLyBJZiBub3QgZm91bmQsIHRyeSB0byBmaW5kIGl0IHRocm91Z2ggcmVsYXRpb25zaGlwc1xyXG4gICAgICBpZiAoIXNsaWRlRmlsZSkge1xyXG4gICAgICAgIGNvbnN0IHNsaWRlUmVsID0gdGhpcy56aXA/LmZpbGUoYHBwdC9zbGlkZXMvX3JlbHMvc2xpZGUke3NsaWRlTnVtYmVyfS54bWwucmVsc2ApXHJcbiAgICAgICAgaWYgKHNsaWRlUmVsKSB7XHJcbiAgICAgICAgICBjb25zdCByZWxDb250ZW50ID0gYXdhaXQgc2xpZGVSZWwuYXN5bmMoJ3RleHQnKVxyXG4gICAgICAgICAgY29uc3QgcmVsUGFyc2VyID0gbmV3IERPTVBhcnNlcigpXHJcbiAgICAgICAgICBjb25zdCByZWxYbWwgPSByZWxQYXJzZXIucGFyc2VGcm9tU3RyaW5nKHJlbENvbnRlbnQsICd0ZXh0L3htbCcpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IHNsaWRlVGFyZ2V0ID0gcmVsWG1sLnF1ZXJ5U2VsZWN0b3IoYFJlbGF0aW9uc2hpcFtJZD1cIiR7c2xpZGVJZH1cIl1gKT8uZ2V0QXR0cmlidXRlKCdUYXJnZXQnKVxyXG4gICAgICAgICAgaWYgKHNsaWRlVGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNsaWRlUGF0aCA9IGBwcHQvc2xpZGVzLyR7c2xpZGVUYXJnZXQuc3BsaXQoJy8nKS5wb3AoKX1gXHJcbiAgICAgICAgICAgIHNsaWRlRmlsZSA9IHRoaXMuemlwPy5maWxlKHNsaWRlUGF0aClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIElmIHN0aWxsIG5vdCBmb3VuZCwgdHJ5IHRvIGZpbmQgYW55IHNsaWRlIGZpbGVcclxuICAgICAgaWYgKCFzbGlkZUZpbGUpIHtcclxuICAgICAgICBjb25zdCBzbGlkZUZpbGVzID0gT2JqZWN0LmtleXModGhpcy56aXA/LmZpbGVzIHx8IHt9KVxyXG4gICAgICAgICAgLmZpbHRlcihuYW1lID0+IG5hbWUuc3RhcnRzV2l0aCgncHB0L3NsaWRlcy9zbGlkZScpICYmIG5hbWUuZW5kc1dpdGgoJy54bWwnKSlcclxuICAgICAgICAgIC5zb3J0KClcclxuICAgICAgICBcclxuICAgICAgICBpZiAoc2xpZGVGaWxlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCB0YXJnZXRTbGlkZSA9IHNsaWRlRmlsZXNbc2xpZGVOdW1iZXIgLSAxXSB8fCBzbGlkZUZpbGVzWzBdXHJcbiAgICAgICAgICBzbGlkZUZpbGUgPSB0aGlzLnppcD8uZmlsZSh0YXJnZXRTbGlkZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGlmICghc2xpZGVGaWxlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBzbGlkZSBmaWxlIGZvciBzbGlkZSAke3NsaWRlTnVtYmVyfWApXHJcbiAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3Qgc2xpZGVDb250ZW50ID0gYXdhaXQgc2xpZGVGaWxlLmFzeW5jKCd0ZXh0JylcclxuICAgICAgY29uc3Qgc2xpZGVQYXJzZXIgPSBuZXcgRE9NUGFyc2VyKClcclxuICAgICAgY29uc3Qgc2xpZGVYbWwgPSBzbGlkZVBhcnNlci5wYXJzZUZyb21TdHJpbmcoc2xpZGVDb250ZW50LCAndGV4dC94bWwnKVxyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBzbGlkZSBkaW1lbnNpb25zXHJcbiAgICAgIGNvbnN0IHNsZFN6ID0gc2xpZGVYbWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NsZFN6JylbMF1cclxuICAgICAgY29uc3Qgd2lkdGggPSBwYXJzZUludChzbGRTej8uZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICc5MTQ0MDAwJykgLyAxMjcwMCAvLyBDb252ZXJ0IEVNVXMgdG8gcGl4ZWxzXHJcbiAgICAgIGNvbnN0IGhlaWdodCA9IHBhcnNlSW50KHNsZFN6Py5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgJzY4NTgwMDAnKSAvIDEyNzAwXHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IHNoYXBlc1xyXG4gICAgICBjb25zdCBvYmplY3RzID0gYXdhaXQgdGhpcy5leHRyYWN0U2hhcGVzKHNsaWRlWG1sLCBzbGlkZU51bWJlcilcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgICAgICAgbmFtZTogYFNsaWRlICR7c2xpZGVOdW1iZXJ9YCxcclxuICAgICAgICB3aWR0aCxcclxuICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgb2JqZWN0cyxcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVhZGluZyBzbGlkZSAke3NsaWRlTnVtYmVyfTpgLCBlcnJvcilcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmVhZFNsaWRlRnJvbUZpbGUoc2xpZGVGaWxlUGF0aDogc3RyaW5nLCBzbGlkZU51bWJlcjogbnVtYmVyKTogUHJvbWlzZTxTbGlkZSB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHNsaWRlRmlsZSA9IHRoaXMuemlwPy5maWxlKHNsaWRlRmlsZVBhdGgpXHJcbiAgICAgIGlmICghc2xpZGVGaWxlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBDb3VsZCBub3QgZmluZCBzbGlkZSBmaWxlOiAke3NsaWRlRmlsZVBhdGh9YClcclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzbGlkZUNvbnRlbnQgPSBhd2FpdCBzbGlkZUZpbGUuYXN5bmMoJ3RleHQnKVxyXG4gICAgICBjb25zb2xlLmxvZyhgU2xpZGUgJHtzbGlkZU51bWJlcn0gWE1MIGNvbnRlbnQ6YCwgc2xpZGVDb250ZW50LnN1YnN0cmluZygwLCAxMDAwKSArICcuLi4nKVxyXG4gICAgICBcclxuICAgICAgY29uc3Qgc2xpZGVQYXJzZXIgPSBuZXcgRE9NUGFyc2VyKClcclxuICAgICAgY29uc3Qgc2xpZGVYbWwgPSBzbGlkZVBhcnNlci5wYXJzZUZyb21TdHJpbmcoc2xpZGVDb250ZW50LCAndGV4dC94bWwnKVxyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBzbGlkZSBkaW1lbnNpb25zIHdpdGggYmV0dGVyIG5hbWVzcGFjZSBoYW5kbGluZ1xyXG4gICAgICBsZXQgc2xkU3ogPSBzbGlkZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2xkU3onKVswXVxyXG4gICAgICBpZiAoIXNsZFN6KSB7XHJcbiAgICAgICAgc2xkU3ogPSBzbGlkZVhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgncDpzbGRTeicpWzBdXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGxldCB3aWR0aCA9IDgwMCwgaGVpZ2h0ID0gNjAwIC8vIERlZmF1bHQgZGltZW5zaW9uc1xyXG4gICAgICBpZiAoc2xkU3opIHtcclxuICAgICAgICBjb25zdCBjeCA9IHNsZFN6LmdldEF0dHJpYnV0ZSgnY3gnKVxyXG4gICAgICAgIGNvbnN0IGN5ID0gc2xkU3ouZ2V0QXR0cmlidXRlKCdjeScpXHJcbiAgICAgICAgY29uc29sZS5sb2coYFNsaWRlICR7c2xpZGVOdW1iZXJ9IGRpbWVuc2lvbnMgZnJvbSBYTUw6YCwgeyBjeCwgY3kgfSlcclxuICAgICAgICBcclxuICAgICAgICBpZiAoY3ggJiYgY3kpIHtcclxuICAgICAgICAgIC8vIENvbnZlcnQgRU1VcyB0byBwaXhlbHNcclxuICAgICAgICAgIGNvbnN0IGVtdVRvUGl4ZWwgPSA5NiAvIDkxNDQwMFxyXG4gICAgICAgICAgd2lkdGggPSBwYXJzZUludChjeCkgKiBlbXVUb1BpeGVsXHJcbiAgICAgICAgICBoZWlnaHQgPSBwYXJzZUludChjeSkgKiBlbXVUb1BpeGVsXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU2xpZGUgJHtzbGlkZU51bWJlcn0gY29udmVydGVkIGRpbWVuc2lvbnM6YCwgeyB3aWR0aCwgaGVpZ2h0IH0pXHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gc2xkU3ogZm91bmQgaW4gc2xpZGUgJHtzbGlkZU51bWJlcn0sIHVzaW5nIGRlZmF1bHRzYClcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBzaGFwZXNcclxuICAgICAgY29uc3Qgb2JqZWN0cyA9IGF3YWl0IHRoaXMuZXh0cmFjdFNoYXBlcyhzbGlkZVhtbCwgc2xpZGVOdW1iZXIpXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gICAgICAgIG5hbWU6IGBTbGlkZSAke3NsaWRlTnVtYmVyfWAsXHJcbiAgICAgICAgd2lkdGg6IE1hdGgubWF4KHdpZHRoLCA4MDApLCAvLyBNaW5pbXVtIHdpZHRoXHJcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heChoZWlnaHQsIDYwMCksIC8vIE1pbmltdW0gaGVpZ2h0XHJcbiAgICAgICAgb2JqZWN0cyxcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgcmVhZGluZyBzbGlkZSBmcm9tIGZpbGUgJHtzbGlkZUZpbGVQYXRofTpgLCBlcnJvcilcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZXh0cmFjdFNoYXBlcyhzbGlkZVhtbDogRG9jdW1lbnQsIHNsaWRlTnVtYmVyOiBudW1iZXIpOiBQcm9taXNlPFNoYXBlT2JqZWN0W10+IHtcclxuICAgIGNvbnN0IG9iamVjdHM6IFNoYXBlT2JqZWN0W10gPSBbXVxyXG4gICAgXHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGluZyBzaGFwZXMgZnJvbSBzbGlkZSAke3NsaWRlTnVtYmVyfWApXHJcbiAgICAgIFxyXG4gICAgICAvLyBUcnkgbXVsdGlwbGUgYXBwcm9hY2hlcyB0byBmaW5kIHNoYXBlc1xyXG4gICAgICBcclxuICAgICAgLy8gQXBwcm9hY2ggMTogTG9vayBmb3Igc3BUcmVlID4gc3AgKHRyYWRpdGlvbmFsIHN0cnVjdHVyZSlcclxuICAgICAgLy8gVXNlIGEgbW9yZSByb2J1c3QgYXBwcm9hY2ggdG8gaGFuZGxlIG5hbWVzcGFjZXNcclxuICAgICAgbGV0IHNwVHJlZSA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUoc2xpZGVYbWwsICdzcFRyZWUnKVxyXG4gICAgICBpZiAoc3BUcmVlKSB7XHJcbiAgICAgICAgY29uc3QgdGV4dEJveGVzID0gdGhpcy5maW5kRWxlbWVudHNCeVRhZ05hbWUoc3BUcmVlLCAnc3AnKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke3RleHRCb3hlcy5sZW5ndGh9IHNoYXBlIGVsZW1lbnRzIGluIHNwVHJlZWApXHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0ZXh0Qm94ZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgIGNvbnN0IHRleHRCb3ggPSB0ZXh0Qm94ZXNbaV1cclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBQcm9jZXNzaW5nIHNoYXBlICR7aSArIDF9OmAsIHRleHRCb3gudGFnTmFtZSwgdGV4dEJveC5nZXRBdHRyaWJ1dGUoJ2lkJyksIHRleHRCb3guZ2V0QXR0cmlidXRlKCduYW1lJykpXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBwbGFjZWhvbGRlclxyXG4gICAgICAgICAgY29uc3QgbnZQciA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUodGV4dEJveCwgJ252UHInKVxyXG4gICAgICAgICAgY29uc3QgcGggPSBudlByID8gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShudlByLCAncGgnKSA6IG51bGxcclxuICAgICAgICAgIGlmIChwaCkge1xyXG4gICAgICAgICAgICBjb25zdCBwaFR5cGUgPSBwaC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgU2hhcGUgJHtpICsgMX0gaXMgYSBwbGFjZWhvbGRlciBvZiB0eXBlOiAke3BoVHlwZX1gKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgZ3JvdXBlZCBzaGFwZVxyXG4gICAgICAgICAgY29uc3QgZ3JwU3AgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHRleHRCb3gsICdncnBTcCcpXHJcbiAgICAgICAgICBpZiAoZ3JwU3ApIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFNoYXBlICR7aSArIDF9IGlzIGEgZ3JvdXBlZCBzaGFwZSwgZXh0cmFjdGluZyBncm91cGApXHJcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwT2JqZWN0ID0gdGhpcy5leHRyYWN0R3JvdXBlZFNoYXBlKGdycFNwLCBzbGlkZU51bWJlciwgaSlcclxuICAgICAgICAgICAgaWYgKGdyb3VwT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgb2JqZWN0cy5wdXNoKGdyb3VwT2JqZWN0KVxyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgZXh0cmFjdGVkIGdyb3VwZWQgc2hhcGUgJHtpICsgMX0gd2l0aCAke2dyb3VwT2JqZWN0LmNoaWxkcmVuPy5sZW5ndGggfHwgMH0gY2hpbGRyZW5gKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSB0ZXh0IHNoYXBlXHJcbiAgICAgICAgICBjb25zdCB0eEJvZHkgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHRleHRCb3gsICd0eEJvZHknKVxyXG4gICAgICAgICAgY29uc3QgaGFzVGV4dCA9IHR4Qm9keSAmJiB0aGlzLmZpbmRFbGVtZW50c0J5VGFnTmFtZSh0eEJvZHksICd0JykubGVuZ3RoID4gMFxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoaGFzVGV4dCkge1xyXG4gICAgICAgICAgICAvLyBGb3IgdGV4dCBzaGFwZXMsIGV4dHJhY3QgaW5kaXZpZHVhbCB0ZXh0IGVsZW1lbnRzIGluc3RlYWQgb2YgdGhlIG1haW4gc2hhcGVcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFNoYXBlICR7aSArIDF9IGhhcyB0ZXh0LCBleHRyYWN0aW5nIGluZGl2aWR1YWwgdGV4dCBlbGVtZW50c2ApXHJcbiAgICAgICAgICAgIGNvbnN0IHRleHRPYmplY3RzID0gdGhpcy5leHRyYWN0SW5kaXZpZHVhbFRleHRFbGVtZW50cyh0ZXh0Qm94LCBzbGlkZU51bWJlciwgaSlcclxuICAgICAgICAgICAgb2JqZWN0cy5wdXNoKC4uLnRleHRPYmplY3RzKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGVkICR7dGV4dE9iamVjdHMubGVuZ3RofSB0ZXh0IG9iamVjdHMgZnJvbSBzaGFwZSAke2kgKyAxfWApXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBGb3Igbm9uLXRleHQgc2hhcGVzLCBleHRyYWN0IGFzIGJhc2ljIHNoYXBlXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTaGFwZSAke2kgKyAxfSBoYXMgbm8gdGV4dCwgZXh0cmFjdGluZyBhcyBiYXNpYyBzaGFwZWApXHJcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5leHRyYWN0QmFzaWNTaGFwZSh0ZXh0Qm94LCBzbGlkZU51bWJlciwgaSlcclxuICAgICAgICAgICAgaWYgKHNoYXBlKSB7XHJcbiAgICAgICAgICAgICAgb2JqZWN0cy5wdXNoKHNoYXBlKVxyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTdWNjZXNzZnVsbHkgZXh0cmFjdGVkIGJhc2ljIHNoYXBlICR7aSArIDF9OmAsIHNoYXBlLnR5cGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBzcFRyZWUgZm91bmQgaW4gc2xpZGUnKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBBcHByb2FjaCAyOiBMb29rIGZvciBzaGFwZXMgZGlyZWN0bHkgaW4gdGhlIHNsaWRlXHJcbiAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUcnlpbmcgYWx0ZXJuYXRpdmUgc2hhcGUgZXh0cmFjdGlvbi4uLicpXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTG9vayBmb3IgYW55IHNwIGVsZW1lbnRzIGFueXdoZXJlIGluIHRoZSBzbGlkZVxyXG4gICAgICAgIGNvbnN0IGFsbFNwRWxlbWVudHMgPSB0aGlzLmZpbmRFbGVtZW50c0J5VGFnTmFtZShzbGlkZVhtbCwgJ3NwJylcclxuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHthbGxTcEVsZW1lbnRzLmxlbmd0aH0gc3AgZWxlbWVudHMgaW4gc2xpZGVgKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsU3BFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgY29uc3Qgc3BFbGVtZW50ID0gYWxsU3BFbGVtZW50c1tpXVxyXG4gICAgICAgICAgY29uc29sZS5sb2coYFByb2Nlc3Npbmcgc3AgZWxlbWVudCAke2kgKyAxfTpgLCBzcEVsZW1lbnQudGFnTmFtZSwgc3BFbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKSlcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGdyb3VwZWQgc2hhcGVzIGZpcnN0XHJcbiAgICAgICAgICBjb25zdCBncnBTcCA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUoc3BFbGVtZW50LCAnZ3JwU3AnKVxyXG4gICAgICAgICAgaWYgKGdycFNwKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBTUCBlbGVtZW50ICR7aSArIDF9IGlzIGEgZ3JvdXBlZCBzaGFwZWApXHJcbiAgICAgICAgICAgIGNvbnN0IGdyb3VwT2JqZWN0ID0gdGhpcy5leHRyYWN0R3JvdXBlZFNoYXBlKGdycFNwLCBzbGlkZU51bWJlciwgaSlcclxuICAgICAgICAgICAgaWYgKGdyb3VwT2JqZWN0KSB7XHJcbiAgICAgICAgICAgICAgb2JqZWN0cy5wdXNoKGdyb3VwT2JqZWN0KVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGNvbnRpbnVlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IHR4Qm9keSA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUoc3BFbGVtZW50LCAndHhCb2R5JylcclxuICAgICAgICAgIGNvbnN0IGhhc1RleHQgPSB0eEJvZHkgJiYgdGhpcy5maW5kRWxlbWVudHNCeVRhZ05hbWUodHhCb2R5LCAndCcpLmxlbmd0aCA+IDBcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGhhc1RleHQpIHtcclxuICAgICAgICAgICAgY29uc3QgdGV4dE9iamVjdHMgPSB0aGlzLmV4dHJhY3RJbmRpdmlkdWFsVGV4dEVsZW1lbnRzKHNwRWxlbWVudCwgc2xpZGVOdW1iZXIsIGkpXHJcbiAgICAgICAgICAgIG9iamVjdHMucHVzaCguLi50ZXh0T2JqZWN0cylcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gdGhpcy5leHRyYWN0QmFzaWNTaGFwZShzcEVsZW1lbnQsIHNsaWRlTnVtYmVyLCBpKVxyXG4gICAgICAgICAgICBpZiAoc2hhcGUpIHtcclxuICAgICAgICAgICAgICBvYmplY3RzLnB1c2goc2hhcGUpXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEFwcHJvYWNoIDM6IExvb2sgZm9yIHRleHQgZWxlbWVudHMgZGlyZWN0bHlcclxuICAgICAgaWYgKG9iamVjdHMubGVuZ3RoID09PSAwKSB7XHJcbiAgICAgICAgY29uc29sZS5sb2coJ1RyeWluZyBkaXJlY3QgdGV4dCBleHRyYWN0aW9uLi4uJylcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCB0ZXh0RWxlbWVudHMgPSB0aGlzLmZpbmRFbGVtZW50c0J5VGFnTmFtZShzbGlkZVhtbCwgJ3QnKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke3RleHRFbGVtZW50cy5sZW5ndGh9IHRleHQgZWxlbWVudHMgZGlyZWN0bHkgaW4gc2xpZGVgKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmICh0ZXh0RWxlbWVudHMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgLy8gQ3JlYXRlIGEgc2ltcGxlIHRleHQgb2JqZWN0IGZyb20gdGhlIGZpcnN0IHRleHQgZWxlbWVudFxyXG4gICAgICAgICAgY29uc3QgZmlyc3RUZXh0ID0gdGV4dEVsZW1lbnRzWzBdXHJcbiAgICAgICAgICBjb25zdCB0ZXh0Q29udGVudCA9IGZpcnN0VGV4dC50ZXh0Q29udGVudCB8fCAnVGV4dCdcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGluZyB0ZXh0IG9iamVjdCB3aXRoIGNvbnRlbnQ6IFwiJHt0ZXh0Q29udGVudH1cImApXHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGNvbnN0IHRleHRPYmplY3Q6IFNoYXBlT2JqZWN0ID0ge1xyXG4gICAgICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgICAgICAgdHlwZTogJ3RleHQnLFxyXG4gICAgICAgICAgICB0cmFuc2Zvcm06IHtcclxuICAgICAgICAgICAgICBsZWZ0OiAxMDAsXHJcbiAgICAgICAgICAgICAgdG9wOiAxMDAsXHJcbiAgICAgICAgICAgICAgd2lkdGg6IDMwMCxcclxuICAgICAgICAgICAgICBoZWlnaHQ6IDEwMCxcclxuICAgICAgICAgICAgICBhbmdsZTogMCxcclxuICAgICAgICAgICAgICBzY2FsZVg6IDEsXHJcbiAgICAgICAgICAgICAgc2NhbGVZOiAxLFxyXG4gICAgICAgICAgICAgIGZsaXBYOiBmYWxzZSxcclxuICAgICAgICAgICAgICBmbGlwWTogZmFsc2UsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcclxuICAgICAgICAgICAgICBmb250U2l6ZTogMTgsXHJcbiAgICAgICAgICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXHJcbiAgICAgICAgICAgICAgZm9udFN0eWxlOiAnbm9ybWFsJyxcclxuICAgICAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxyXG4gICAgICAgICAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgICAgICAgICAgdGV4dEFsaWduOiAnbGVmdCcsXHJcbiAgICAgICAgICAgICAgbGluZUhlaWdodDogMS4yLFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBjb250ZW50OiB0ZXh0Q29udGVudCxcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgb2JqZWN0cy5wdXNoKHRleHRPYmplY3QpXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnQ3JlYXRlZCBmYWxsYmFjayB0ZXh0IG9iamVjdCcpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IGltYWdlc1xyXG4gICAgICBjb25zdCBpbWFnZXMgPSB0aGlzLmZpbmRFbGVtZW50c0J5VGFnTmFtZShzbGlkZVhtbCwgJ3BpYycpXHJcbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2ltYWdlcy5sZW5ndGh9IGltYWdlIGVsZW1lbnRzYClcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbWFnZXMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBpbWFnZSA9IGltYWdlc1tpXVxyXG4gICAgICAgIGNvbnN0IHNoYXBlID0gYXdhaXQgdGhpcy5leHRyYWN0SW1hZ2UoaW1hZ2UsIHNsaWRlTnVtYmVyLCBpKVxyXG4gICAgICAgIGlmIChzaGFwZSkge1xyXG4gICAgICAgICAgb2JqZWN0cy5wdXNoKHNoYXBlKVxyXG4gICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBleHRyYWN0ZWQgaW1hZ2UgJHtpICsgMX1gKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYFRvdGFsIG9iamVjdHMgZXh0cmFjdGVkOiAke29iamVjdHMubGVuZ3RofWApXHJcbiAgICAgIGNvbnNvbGUubG9nKCdGaW5hbCBvYmplY3RzOicsIG9iamVjdHMubWFwKG9iaiA9PiAoeyB0eXBlOiBvYmoudHlwZSwgY29udGVudDogb2JqLmNvbnRlbnQsIHRyYW5zZm9ybTogb2JqLnRyYW5zZm9ybSB9KSkpXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBleHRyYWN0aW5nIHNoYXBlczonLCBlcnJvcilcclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG9iamVjdHNcclxuICB9XHJcblxyXG4gIC8vIEhlbHBlciBtZXRob2RzIHRvIGhhbmRsZSBYTUwgbmFtZXNwYWNlc1xyXG4gIHByaXZhdGUgZmluZEVsZW1lbnRCeVRhZ05hbWUocGFyZW50OiBFbGVtZW50IHwgRG9jdW1lbnQsIHRhZ05hbWU6IHN0cmluZyk6IEVsZW1lbnQgfCBudWxsIHtcclxuICAgIC8vIFRyeSBtdWx0aXBsZSBhcHByb2FjaGVzIHRvIGZpbmQgdGhlIGVsZW1lbnRcclxuICAgIGxldCBlbGVtZW50ID0gcGFyZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpWzBdXHJcbiAgICBpZiAoZWxlbWVudCkgcmV0dXJuIGVsZW1lbnRcclxuICAgIFxyXG4gICAgLy8gSWYgbm90IGZvdW5kLCB0cnkgd2l0aCBjb21tb24gbmFtZXNwYWNlIHByZWZpeGVzXHJcbiAgICBjb25zdCBwcmVmaXhlcyA9IFsncDonLCAnYTonLCAncjonLCAnJ11cclxuICAgIGZvciAoY29uc3QgcHJlZml4IG9mIHByZWZpeGVzKSB7XHJcbiAgICAgIGNvbnN0IGZ1bGxUYWdOYW1lID0gcHJlZml4ICsgdGFnTmFtZVxyXG4gICAgICBlbGVtZW50ID0gcGFyZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKGZ1bGxUYWdOYW1lKVswXVxyXG4gICAgICBpZiAoZWxlbWVudCkgcmV0dXJuIGVsZW1lbnRcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gTGFzdCByZXNvcnQ6IHNlYXJjaCBieSBwYXJ0aWFsIHRhZyBuYW1lXHJcbiAgICBjb25zdCBhbGxFbGVtZW50cyA9IHBhcmVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpXHJcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgIGNvbnN0IGVsID0gYWxsRWxlbWVudHNbaV1cclxuICAgICAgaWYgKGVsLnRhZ05hbWUuZW5kc1dpdGgodGFnTmFtZSkgfHwgZWwudGFnTmFtZS5pbmNsdWRlcyh0YWdOYW1lKSkge1xyXG4gICAgICAgIHJldHVybiBlbFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBudWxsXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGZpbmRFbGVtZW50c0J5VGFnTmFtZShwYXJlbnQ6IEVsZW1lbnQgfCBEb2N1bWVudCwgdGFnTmFtZTogc3RyaW5nKTogRWxlbWVudFtdIHtcclxuICAgIC8vIFRyeSBtdWx0aXBsZSBhcHByb2FjaGVzIHRvIGZpbmQgZWxlbWVudHNcclxuICAgIGxldCBlbGVtZW50cyA9IEFycmF5LmZyb20ocGFyZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKHRhZ05hbWUpKVxyXG4gICAgaWYgKGVsZW1lbnRzLmxlbmd0aCA+IDApIHJldHVybiBlbGVtZW50c1xyXG4gICAgXHJcbiAgICAvLyBJZiBub3QgZm91bmQsIHRyeSB3aXRoIGNvbW1vbiBuYW1lc3BhY2UgcHJlZml4ZXNcclxuICAgIGNvbnN0IHByZWZpeGVzID0gWydwOicsICdhOicsICdyOicsICcnXVxyXG4gICAgZm9yIChjb25zdCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcclxuICAgICAgY29uc3QgZnVsbFRhZ05hbWUgPSBwcmVmaXggKyB0YWdOYW1lXHJcbiAgICAgIGVsZW1lbnRzID0gQXJyYXkuZnJvbShwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZnVsbFRhZ05hbWUpKVxyXG4gICAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkgcmV0dXJuIGVsZW1lbnRzXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIExhc3QgcmVzb3J0OiBzZWFyY2ggYnkgcGFydGlhbCB0YWcgbmFtZVxyXG4gICAgY29uc3QgYWxsRWxlbWVudHMgPSBwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJyonKVxyXG4gICAgY29uc3QgbWF0Y2hpbmdFbGVtZW50czogRWxlbWVudFtdID0gW11cclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgZWwgPSBhbGxFbGVtZW50c1tpXVxyXG4gICAgICBpZiAoZWwudGFnTmFtZS5lbmRzV2l0aCh0YWdOYW1lKSB8fCBlbC50YWdOYW1lLmluY2x1ZGVzKHRhZ05hbWUpKSB7XHJcbiAgICAgICAgbWF0Y2hpbmdFbGVtZW50cy5wdXNoKGVsKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiBtYXRjaGluZ0VsZW1lbnRzXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGV4dHJhY3RJbWFnZShpbWFnZTogRWxlbWVudCwgc2xpZGVOdW1iZXI6IG51bWJlciwgaW5kZXg6IG51bWJlcik6IFByb21pc2U8U2hhcGVPYmplY3QgfCBudWxsPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGluZyBhY3R1YWwgaW1hZ2UgJHtpbmRleH0gZnJvbSBzbGlkZSAke3NsaWRlTnVtYmVyfWApXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzcFByID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShpbWFnZSwgJ3NwUHInKVxyXG4gICAgICBpZiAoIXNwUHIpIHJldHVybiBudWxsXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLmV4dHJhY3RUcmFuc2Zvcm0oc3BQcilcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgdGhlIGFjdHVhbCBpbWFnZSBkYXRhIGZyb20gdGhlIFBQVFhcclxuICAgICAgY29uc3QgYmxpcEZpbGwgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKGltYWdlLCAnYmxpcEZpbGwnKVxyXG4gICAgICBpZiAoYmxpcEZpbGwpIHtcclxuICAgICAgICBjb25zdCBibGlwID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShibGlwRmlsbCwgJ2JsaXAnKVxyXG4gICAgICAgIGlmIChibGlwKSB7XHJcbiAgICAgICAgICBjb25zdCBlbWJlZCA9IGJsaXAuZ2V0QXR0cmlidXRlKCdyOmVtYmVkJylcclxuICAgICAgICAgIGNvbnN0IGxpbmsgPSBibGlwLmdldEF0dHJpYnV0ZSgncjpsaW5rJylcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc29sZS5sb2coYEltYWdlICR7aW5kZXh9IGhhcyBlbWJlZDogJHtlbWJlZH0sIGxpbms6ICR7bGlua31gKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoZW1iZWQgfHwgbGluaykge1xyXG4gICAgICAgICAgICAvLyBUcnkgdG8gZmluZCB0aGUgYWN0dWFsIGltYWdlIGZpbGVcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2VJZCA9IGVtYmVkIHx8IGxpbmtcclxuICAgICAgICAgICAgY29uc3QgaW1hZ2VGaWxlID0gYXdhaXQgdGhpcy5maW5kSW1hZ2VGaWxlKGltYWdlSWQpXHJcbiAgICAgICAgICAgIFxyXG4gICAgICAgICAgICBpZiAoaW1hZ2VGaWxlKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIGFjdHVhbCBpbWFnZSBmaWxlOiAke2ltYWdlRmlsZS5uYW1lfWApXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gQ29udmVydCBpbWFnZSB0byBkYXRhIFVSTFxyXG4gICAgICAgICAgICAgIGNvbnN0IGltYWdlRGF0YSA9IGF3YWl0IGltYWdlRmlsZS5hc3luYygnYmFzZTY0JylcclxuICAgICAgICAgICAgICBjb25zdCBtaW1lVHlwZSA9IHRoaXMuZ2V0TWltZVR5cGUoaW1hZ2VGaWxlLm5hbWUpXHJcbiAgICAgICAgICAgICAgY29uc3QgZGF0YVVybCA9IGBkYXRhOiR7bWltZVR5cGV9O2Jhc2U2NCwke2ltYWdlRGF0YX1gXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gICAgICAgICAgICAgICAgdHlwZTogJ2ltYWdlJyxcclxuICAgICAgICAgICAgICAgIHRyYW5zZm9ybSxcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7fSxcclxuICAgICAgICAgICAgICAgIHNyYzogZGF0YVVybCxcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIElmIHdlIGNhbid0IGV4dHJhY3QgdGhlIGFjdHVhbCBpbWFnZSwgY3JlYXRlIGEgYmV0dGVyIHBsYWNlaG9sZGVyXHJcbiAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGV4dHJhY3QgYWN0dWFsIGltYWdlIGRhdGEgZm9yIGltYWdlICR7aW5kZXh9LCBjcmVhdGluZyBwbGFjZWhvbGRlcmApXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcclxuICAgICAgICB0cmFuc2Zvcm0sXHJcbiAgICAgICAgc3R5bGU6IHt9LFxyXG4gICAgICAgIHNyYzogYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtidG9hKCc8c3ZnIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxyZWN0IHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgZmlsbD1cIiNjY2NcIi8+PHRleHQgeD1cIjUwXCIgeT1cIjUwXCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIiBkeT1cIi4zZW1cIiBmb250LXNpemU9XCIxMlwiPkltYWdlPC90ZXh0Pjwvc3ZnPicpfWAsXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGV4dHJhY3RpbmcgaW1hZ2UgJHtpbmRleH06YCwgZXJyb3IpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGZpbmRJbWFnZUZpbGUoaW1hZ2VJZDogc3RyaW5nKTogUHJvbWlzZTxKU1ppcC5KU1ppcE9iamVjdCB8IG51bGw+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEZpcnN0IHRyeSB0byBmaW5kIHRoZSByZWxhdGlvbnNoaXAgZmlsZVxyXG4gICAgICBjb25zdCByZWxzRmlsZSA9IHRoaXMuemlwPy5maWxlKCdwcHQvX3JlbHMvcHJlc2VudGF0aW9uLnhtbC5yZWxzJylcclxuICAgICAgaWYgKHJlbHNGaWxlKSB7XHJcbiAgICAgICAgY29uc3QgcmVsc0NvbnRlbnQgPSBhd2FpdCByZWxzRmlsZS5hc3luYygndGV4dCcpXHJcbiAgICAgICAgY29uc3QgcmVsc1BhcnNlciA9IG5ldyBET01QYXJzZXIoKVxyXG4gICAgICAgIGNvbnN0IHJlbHNYbWwgPSByZWxzUGFyc2VyLnBhcnNlRnJvbVN0cmluZyhyZWxzQ29udGVudCwgJ3RleHQveG1sJylcclxuICAgICAgICBcclxuICAgICAgICBjb25zdCByZWxhdGlvbnNoaXAgPSByZWxzWG1sLnF1ZXJ5U2VsZWN0b3IoYFJlbGF0aW9uc2hpcFtJZD1cIiR7aW1hZ2VJZH1cIl1gKVxyXG4gICAgICAgIGlmIChyZWxhdGlvbnNoaXApIHtcclxuICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHJlbGF0aW9uc2hpcC5nZXRBdHRyaWJ1dGUoJ1RhcmdldCcpXHJcbiAgICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIC8vIENvbnZlcnQgcmVsYXRpdmUgcGF0aCB0byBhYnNvbHV0ZVxyXG4gICAgICAgICAgICBjb25zdCBpbWFnZVBhdGggPSB0YXJnZXQuc3RhcnRzV2l0aCgnLycpID8gdGFyZ2V0LnNsaWNlKDEpIDogYHBwdC8ke3RhcmdldH1gXHJcbiAgICAgICAgICAgIGNvbnN0IGltYWdlRmlsZSA9IHRoaXMuemlwPy5maWxlKGltYWdlUGF0aClcclxuICAgICAgICAgICAgaWYgKGltYWdlRmlsZSkge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBpbWFnZSBmaWxlIHZpYSByZWxhdGlvbnNoaXBzOiAke2ltYWdlUGF0aH1gKVxyXG4gICAgICAgICAgICAgIHJldHVybiBpbWFnZUZpbGVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gVHJ5IGNvbW1vbiBpbWFnZSBwYXRoc1xyXG4gICAgICBjb25zdCBjb21tb25QYXRocyA9IFtcclxuICAgICAgICBgcHB0L21lZGlhL2ltYWdlJHtpbWFnZUlkfS5wbmdgLFxyXG4gICAgICAgIGBwcHQvbWVkaWEvaW1hZ2Uke2ltYWdlSWR9LmpwZ2AsXHJcbiAgICAgICAgYHBwdC9tZWRpYS9pbWFnZSR7aW1hZ2VJZH0uanBlZ2AsXHJcbiAgICAgICAgYHBwdC9tZWRpYS9pbWFnZSR7aW1hZ2VJZH0uZ2lmYCxcclxuICAgICAgICBgcHB0L21lZGlhL2ltYWdlJHtpbWFnZUlkfS5ibXBgLFxyXG4gICAgICBdXHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGNvbnN0IHBhdGggb2YgY29tbW9uUGF0aHMpIHtcclxuICAgICAgICBjb25zdCBpbWFnZUZpbGUgPSB0aGlzLnppcD8uZmlsZShwYXRoKVxyXG4gICAgICAgIGlmIChpbWFnZUZpbGUpIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBpbWFnZSBmaWxlIHZpYSBjb21tb24gcGF0aDogJHtwYXRofWApXHJcbiAgICAgICAgICByZXR1cm4gaW1hZ2VGaWxlXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBTZWFyY2ggdGhyb3VnaCBhbGwgZmlsZXMgZm9yIGltYWdlc1xyXG4gICAgICBjb25zdCBhbGxGaWxlcyA9IE9iamVjdC5rZXlzKHRoaXMuemlwPy5maWxlcyB8fCB7fSlcclxuICAgICAgY29uc3QgaW1hZ2VGaWxlcyA9IGFsbEZpbGVzLmZpbHRlcihuYW1lID0+IFxyXG4gICAgICAgIG5hbWUuaW5jbHVkZXMoJ21lZGlhJykgJiYgXHJcbiAgICAgICAgKG5hbWUuZW5kc1dpdGgoJy5wbmcnKSB8fCBuYW1lLmVuZHNXaXRoKCcuanBnJykgfHwgbmFtZS5lbmRzV2l0aCgnLmpwZWcnKSB8fCBuYW1lLmVuZHNXaXRoKCcuZ2lmJykgfHwgbmFtZS5lbmRzV2l0aCgnLmJtcCcpKVxyXG4gICAgICApXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtpbWFnZUZpbGVzLmxlbmd0aH0gaW1hZ2UgZmlsZXMgaW4gbWVkaWEgZm9sZGVyOmAsIGltYWdlRmlsZXMpXHJcbiAgICAgIFxyXG4gICAgICAvLyBUcnkgdG8gZmluZCB0aGUgaW1hZ2UgYnkgSUQgaW4gdGhlIGZpbGVuYW1lXHJcbiAgICAgIGZvciAoY29uc3QgaW1hZ2VQYXRoIG9mIGltYWdlRmlsZXMpIHtcclxuICAgICAgICBpZiAoaW1hZ2VQYXRoLmluY2x1ZGVzKGltYWdlSWQpIHx8IGltYWdlUGF0aC5pbmNsdWRlcyhgaW1hZ2Uke2ltYWdlSWR9YCkpIHtcclxuICAgICAgICAgIGNvbnN0IGltYWdlRmlsZSA9IHRoaXMuemlwPy5maWxlKGltYWdlUGF0aClcclxuICAgICAgICAgIGlmIChpbWFnZUZpbGUpIHtcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIGltYWdlIGZpbGUgYnkgSUQgc2VhcmNoOiAke2ltYWdlUGF0aH1gKVxyXG4gICAgICAgICAgICByZXR1cm4gaW1hZ2VGaWxlXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmluZGluZyBpbWFnZSBmaWxlOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRNaW1lVHlwZShmaWxlbmFtZTogc3RyaW5nKTogc3RyaW5nIHtcclxuICAgIGNvbnN0IGV4dCA9IGZpbGVuYW1lLnNwbGl0KCcuJykucG9wKCk/LnRvTG93ZXJDYXNlKClcclxuICAgIHN3aXRjaCAoZXh0KSB7XHJcbiAgICAgIGNhc2UgJ3BuZyc6IHJldHVybiAnaW1hZ2UvcG5nJ1xyXG4gICAgICBjYXNlICdqcGcnOlxyXG4gICAgICBjYXNlICdqcGVnJzogcmV0dXJuICdpbWFnZS9qcGVnJ1xyXG4gICAgICBjYXNlICdnaWYnOiByZXR1cm4gJ2ltYWdlL2dpZidcclxuICAgICAgY2FzZSAnYm1wJzogcmV0dXJuICdpbWFnZS9ibXAnXHJcbiAgICAgIGNhc2UgJ3N2Zyc6IHJldHVybiAnaW1hZ2Uvc3ZnK3htbCdcclxuICAgICAgZGVmYXVsdDogcmV0dXJuICdpbWFnZS9wbmcnXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGV4dHJhY3RHcm91cGVkU2hhcGUoZ3JwU3A6IEVsZW1lbnQsIHNsaWRlTnVtYmVyOiBudW1iZXIsIGluZGV4OiBudW1iZXIpOiBQcm9taXNlPFNoYXBlT2JqZWN0IHwgbnVsbD4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYEV4dHJhY3RpbmcgZ3JvdXBlZCBzaGFwZSAke2luZGV4fSBmcm9tIHNsaWRlICR7c2xpZGVOdW1iZXJ9YClcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgdGhlIGdyb3VwJ3MgdHJhbnNmb3JtXHJcbiAgICAgIGNvbnN0IGdycFNwUHIgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKGdycFNwLCAnZ3JwU3BQcicpXHJcbiAgICAgIGNvbnN0IHRyYW5zZm9ybSA9IGdycFNwUHIgPyB0aGlzLmV4dHJhY3RUcmFuc2Zvcm0oZ3JwU3BQcikgOiB7XHJcbiAgICAgICAgbGVmdDogMCxcclxuICAgICAgICB0b3A6IDAsXHJcbiAgICAgICAgd2lkdGg6IDQwMCxcclxuICAgICAgICBoZWlnaHQ6IDMwMCxcclxuICAgICAgICBhbmdsZTogMCxcclxuICAgICAgICBzY2FsZVg6IDEsXHJcbiAgICAgICAgc2NhbGVZOiAxLFxyXG4gICAgICAgIGZsaXBYOiBmYWxzZSxcclxuICAgICAgICBmbGlwWTogZmFsc2UsXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgY2hpbGQgc2hhcGVzIGZyb20gdGhlIGdyb3VwXHJcbiAgICAgIGNvbnN0IGNoaWxkcmVuOiBTaGFwZU9iamVjdFtdID0gW11cclxuICAgICAgXHJcbiAgICAgIC8vIExvb2sgZm9yIHNwIGVsZW1lbnRzIHdpdGhpbiB0aGUgZ3JvdXBcclxuICAgICAgY29uc3QgY2hpbGRTcEVsZW1lbnRzID0gdGhpcy5maW5kRWxlbWVudHNCeVRhZ05hbWUoZ3JwU3AsICdzcCcpXHJcbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke2NoaWxkU3BFbGVtZW50cy5sZW5ndGh9IGNoaWxkIHNoYXBlcyBpbiBncm91cCAke2luZGV4fWApXHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNoaWxkU3BFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkU3AgPSBjaGlsZFNwRWxlbWVudHNbaV1cclxuICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBjaGlsZCBzaGFwZSAke2kgKyAxfSBpbiBncm91cCAke2luZGV4fWApXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgY2hpbGQgaGFzIHRleHRcclxuICAgICAgICBjb25zdCB0eEJvZHkgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKGNoaWxkU3AsICd0eEJvZHknKVxyXG4gICAgICAgIGNvbnN0IGhhc1RleHQgPSB0eEJvZHkgJiYgdGhpcy5maW5kRWxlbWVudHNCeVRhZ05hbWUodHhCb2R5LCAndCcpLmxlbmd0aCA+IDBcclxuICAgICAgICBcclxuICAgICAgICBpZiAoaGFzVGV4dCkge1xyXG4gICAgICAgICAgLy8gRXh0cmFjdCB0ZXh0IG9iamVjdHMgZnJvbSBjaGlsZFxyXG4gICAgICAgICAgY29uc3QgdGV4dE9iamVjdHMgPSB0aGlzLmV4dHJhY3RJbmRpdmlkdWFsVGV4dEVsZW1lbnRzKGNoaWxkU3AsIHNsaWRlTnVtYmVyLCBpKVxyXG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCguLi50ZXh0T2JqZWN0cylcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gRXh0cmFjdCBhcyBiYXNpYyBzaGFwZVxyXG4gICAgICAgICAgY29uc3QgY2hpbGRTaGFwZSA9IHRoaXMuZXh0cmFjdEJhc2ljU2hhcGUoY2hpbGRTcCwgc2xpZGVOdW1iZXIsIGkpXHJcbiAgICAgICAgICBpZiAoY2hpbGRTaGFwZSkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKGNoaWxkU2hhcGUpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBMb29rIGZvciBwaWMgZWxlbWVudHMgd2l0aGluIHRoZSBncm91cFxyXG4gICAgICBjb25zdCBjaGlsZFBpY0VsZW1lbnRzID0gdGhpcy5maW5kRWxlbWVudHNCeVRhZ05hbWUoZ3JwU3AsICdwaWMnKVxyXG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtjaGlsZFBpY0VsZW1lbnRzLmxlbmd0aH0gY2hpbGQgaW1hZ2VzIGluIGdyb3VwICR7aW5kZXh9YClcclxuICAgICAgXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2hpbGRQaWNFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGNoaWxkUGljID0gY2hpbGRQaWNFbGVtZW50c1tpXVxyXG4gICAgICAgIGNvbnN0IGNoaWxkSW1hZ2UgPSBhd2FpdCB0aGlzLmV4dHJhY3RJbWFnZShjaGlsZFBpYywgc2xpZGVOdW1iZXIsIGkpXHJcbiAgICAgICAgaWYgKGNoaWxkSW1hZ2UpIHtcclxuICAgICAgICAgIGNoaWxkcmVuLnB1c2goY2hpbGRJbWFnZSlcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIENyZWF0ZSB0aGUgZ3JvdXAgb2JqZWN0XHJcbiAgICAgIGNvbnN0IGdyb3VwT2JqZWN0OiBTaGFwZU9iamVjdCA9IHtcclxuICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgICB0eXBlOiAnZ3JvdXAnLFxyXG4gICAgICAgIHRyYW5zZm9ybSxcclxuICAgICAgICBzdHlsZToge30sXHJcbiAgICAgICAgY2hpbGRyZW4sXHJcbiAgICAgICAgZ3JvdXBJZDogYGdyb3VwLSR7c2xpZGVOdW1iZXJ9LSR7aW5kZXh9YCxcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBjcmVhdGVkIGdyb3VwIG9iamVjdCB3aXRoICR7Y2hpbGRyZW4ubGVuZ3RofSBjaGlsZHJlbmApXHJcbiAgICAgIHJldHVybiBncm91cE9iamVjdFxyXG4gICAgICBcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGV4dHJhY3RpbmcgZ3JvdXBlZCBzaGFwZSAke2luZGV4fTpgLCBlcnJvcilcclxuICAgICAgcmV0dXJuIG51bGxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZXh0cmFjdEJhc2ljU2hhcGUoc2hhcGU6IEVsZW1lbnQsIHNsaWRlTnVtYmVyOiBudW1iZXIsIGluZGV4OiBudW1iZXIpOiBTaGFwZU9iamVjdCB8IG51bGwge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYEV4dHJhY3RpbmcgYmFzaWMgc2hhcGUgJHtpbmRleCArIDF9IGZyb20gc2xpZGUgJHtzbGlkZU51bWJlcn1gKVxyXG4gICAgICBcclxuICAgICAgY29uc3Qgc3BQciA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUoc2hhcGUsICdzcFByJylcclxuICAgICAgaWYgKCFzcFByKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKGBObyBzcFByIGZvdW5kIGluIGJhc2ljIHNoYXBlICR7aW5kZXggKyAxfWApXHJcbiAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5leHRyYWN0VHJhbnNmb3JtKHNwUHIpXHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgdGhlIGFjdHVhbCBzaGFwZSB0eXBlIGZyb20gdGhlIFhNTCB3aXRoIGJldHRlciBkZXRlY3Rpb25cclxuICAgICAgbGV0IHByc3RHZW9tID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShzcFByLCAncHJzdEdlb20nKVxyXG4gICAgICBsZXQgc2hhcGVUeXBlOiAncmVjdGFuZ2xlJyB8ICdlbGxpcHNlJyB8ICdsaW5lJyA9ICdyZWN0YW5nbGUnXHJcbiAgICAgIFxyXG4gICAgICBpZiAocHJzdEdlb20pIHtcclxuICAgICAgICBjb25zdCBwcnN0ID0gcHJzdEdlb20uZ2V0QXR0cmlidXRlKCdwcnN0JylcclxuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgc2hhcGUgdHlwZSBpbiBYTUw6ICR7cHJzdH1gKVxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEVuaGFuY2VkIHNoYXBlIHR5cGUgZGV0ZWN0aW9uXHJcbiAgICAgICAgc3dpdGNoIChwcnN0KSB7XHJcbiAgICAgICAgICBjYXNlICdyZWN0JzpcclxuICAgICAgICAgIGNhc2UgJ3JvdW5kUmVjdCc6XHJcbiAgICAgICAgICBjYXNlICdzbmlwMVJlY3QnOlxyXG4gICAgICAgICAgY2FzZSAnc25pcDJSZWN0JzpcclxuICAgICAgICAgIGNhc2UgJ3NuaXBSb3VuZFJlY3QnOlxyXG4gICAgICAgICAgY2FzZSAncm91bmQxUmVjdCc6XHJcbiAgICAgICAgICBjYXNlICdyb3VuZDJSZWN0JzpcclxuICAgICAgICAgICAgc2hhcGVUeXBlID0gJ3JlY3RhbmdsZSdcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIGNhc2UgJ2VsbGlwc2UnOlxyXG4gICAgICAgICAgY2FzZSAnb3ZhbCc6XHJcbiAgICAgICAgICAgIHNoYXBlVHlwZSA9ICdlbGxpcHNlJ1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSAnbGluZSc6XHJcbiAgICAgICAgICBjYXNlICdzdHJhaWdodENvbm5lY3RvcjEnOlxyXG4gICAgICAgICAgY2FzZSAnc3RyYWlnaHRDb25uZWN0b3IyJzpcclxuICAgICAgICAgIGNhc2UgJ3N0cmFpZ2h0Q29ubmVjdG9yMyc6XHJcbiAgICAgICAgICBjYXNlICdzdHJhaWdodENvbm5lY3RvcjQnOlxyXG4gICAgICAgICAgY2FzZSAnc3RyYWlnaHRDb25uZWN0b3I1JzpcclxuICAgICAgICAgIGNhc2UgJ3N0cmFpZ2h0Q29ubmVjdG9yNic6XHJcbiAgICAgICAgICBjYXNlICdiZW50Q29ubmVjdG9yMic6XHJcbiAgICAgICAgICBjYXNlICdiZW50Q29ubmVjdG9yMyc6XHJcbiAgICAgICAgICBjYXNlICdiZW50Q29ubmVjdG9yNCc6XHJcbiAgICAgICAgICBjYXNlICdiZW50Q29ubmVjdG9yNSc6XHJcbiAgICAgICAgICAgIHNoYXBlVHlwZSA9ICdsaW5lJ1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFVua25vd24gc2hhcGUgdHlwZTogJHtwcnN0fSwgZGVmYXVsdGluZyB0byByZWN0YW5nbGVgKVxyXG4gICAgICAgICAgICBzaGFwZVR5cGUgPSAncmVjdGFuZ2xlJ1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICAvLyBUcnkgdG8gZGV0ZXJtaW5lIHNoYXBlIHR5cGUgZnJvbSBvdGhlciBwcm9wZXJ0aWVzXHJcbiAgICAgICAgY29uc3QgY3VzdEdlb20gPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHNwUHIsICdjdXN0R2VvbScpXHJcbiAgICAgICAgaWYgKGN1c3RHZW9tKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgY3VzdG9tIGdlb21ldHJ5LCBkZWZhdWx0aW5nIHRvIHJlY3RhbmdsZScpXHJcbiAgICAgICAgICBzaGFwZVR5cGUgPSAncmVjdGFuZ2xlJ1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnTm8gZ2VvbWV0cnkgZm91bmQsIGRlZmF1bHRpbmcgdG8gcmVjdGFuZ2xlJylcclxuICAgICAgICAgIHNoYXBlVHlwZSA9ICdyZWN0YW5nbGUnXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGVkIGJhc2ljIHNoYXBlOiB0eXBlPSR7c2hhcGVUeXBlfSwgdHJhbnNmb3JtPWAsIHRyYW5zZm9ybSlcclxuICAgICAgXHJcbiAgICAgIC8vIEZvciBiYXNpYyBzaGFwZXMsIHdlIG1pZ2h0IHN0aWxsIGhhdmUgc29tZSB0ZXh0IGNvbnRlbnQgKGxpa2UgcGxhY2Vob2xkZXJzKVxyXG4gICAgICBsZXQgY29udGVudCA9ICcnXHJcbiAgICAgIGNvbnN0IHR4Qm9keSA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUoc2hhcGUsICd0eEJvZHknKVxyXG4gICAgICBpZiAodHhCb2R5KSB7XHJcbiAgICAgICAgY29udGVudCA9IHRoaXMuZXh0cmFjdFRleHRDb250ZW50KHNoYXBlKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcGxhY2Vob2xkZXJcclxuICAgICAgY29uc3QgbnZQciA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUoc2hhcGUsICdudlByJylcclxuICAgICAgY29uc3QgcGggPSBudlByID8gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShudlByLCAncGgnKSA6IG51bGxcclxuICAgICAgaWYgKHBoKSB7XHJcbiAgICAgICAgY29uc3QgcGhUeXBlID0gcGguZ2V0QXR0cmlidXRlKCd0eXBlJylcclxuICAgICAgICBpZiAocGhUeXBlID09PSAndGl0bGUnKSB7XHJcbiAgICAgICAgICBjb250ZW50ID0gJ1RpdGxlIFBsYWNlaG9sZGVyJ1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGhUeXBlID09PSAnYm9keScpIHtcclxuICAgICAgICAgIGNvbnRlbnQgPSAnQm9keSBQbGFjZWhvbGRlcidcclxuICAgICAgICB9IGVsc2UgaWYgKHBoVHlwZSA9PT0gJ3BpYycpIHtcclxuICAgICAgICAgIGNvbnRlbnQgPSAnUGljdHVyZSBQbGFjZWhvbGRlcidcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgY29udGVudCA9ICdDb250ZW50IFBsYWNlaG9sZGVyJ1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gR2V0IHNoYXBlIG5hbWUgZm9yIGJldHRlciBpZGVudGlmaWNhdGlvblxyXG4gICAgICBjb25zdCBjTnZQciA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUoc2hhcGUsICdjTnZQcicpXHJcbiAgICAgIGNvbnN0IHNoYXBlTmFtZSA9IGNOdlByPy5nZXRBdHRyaWJ1dGUoJ25hbWUnKSB8fCBgU2hhcGUgJHtpbmRleCArIDF9YFxyXG4gICAgICBjb25zb2xlLmxvZyhgU2hhcGUgbmFtZTogJHtzaGFwZU5hbWV9YClcclxuICAgICAgXHJcbiAgICAgIC8vIEVuaGFuY2VkIHN0eWxpbmcgYmFzZWQgb24gc2hhcGUgdHlwZVxyXG4gICAgICBjb25zdCBzdHlsZTogYW55ID0ge1xyXG4gICAgICAgIGZpbGw6IHNoYXBlVHlwZSA9PT0gJ2xpbmUnID8gJ3RyYW5zcGFyZW50JyA6ICcjZTVlN2ViJywgLy8gRGVmYXVsdCBsaWdodCBncmF5IGZpbGwgZm9yIHNoYXBlc1xyXG4gICAgICAgIHN0cm9rZTogJyM2YjcyODAnLCAvLyBEZWZhdWx0IGJvcmRlciBjb2xvclxyXG4gICAgICAgIHN0cm9rZVdpZHRoOiBzaGFwZVR5cGUgPT09ICdsaW5lJyA/IDIgOiAxLFxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBBZGQgY29ybmVyIHJhZGl1cyBmb3Igcm91bmRlZCByZWN0YW5nbGVzXHJcbiAgICAgIGlmIChzaGFwZVR5cGUgPT09ICdyZWN0YW5nbGUnICYmIHByc3RHZW9tPy5nZXRBdHRyaWJ1dGUoJ3Byc3QnKT8uaW5jbHVkZXMoJ3JvdW5kJykpIHtcclxuICAgICAgICBzdHlsZS5yeCA9IDEwXHJcbiAgICAgICAgc3R5bGUucnkgPSAxMFxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gICAgICAgIHR5cGU6IHNoYXBlVHlwZSxcclxuICAgICAgICB0cmFuc2Zvcm0sXHJcbiAgICAgICAgc3R5bGUsXHJcbiAgICAgICAgY29udGVudDogY29udGVudCB8fCB1bmRlZmluZWQsIC8vIE9ubHkgaW5jbHVkZSBjb250ZW50IGlmIGl0IGV4aXN0c1xyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBleHRyYWN0aW5nIGJhc2ljIHNoYXBlOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBleHRyYWN0VHJhbnNmb3JtKHNwUHI6IEVsZW1lbnQpOiBUcmFuc2Zvcm0ge1xyXG4gICAgLy8gRGVidWcgdGhlIHNwUHIgZWxlbWVudCBzdHJ1Y3R1cmVcclxuICAgIGNvbnNvbGUubG9nKCdFeHRyYWN0aW5nIHRyYW5zZm9ybSBmcm9tIHNwUHI6Jywgc3BQci5vdXRlckhUTUwuc3Vic3RyaW5nKDAsIDUwMCkgKyAnLi4uJylcclxuICAgIFxyXG4gICAgLy8gVHJ5IHRvIGZpbmQgeGZybSBlbGVtZW50IHdpdGggYmV0dGVyIG5hbWVzcGFjZSBoYW5kbGluZ1xyXG4gICAgbGV0IHhmcm0gPSBzcFByLmdldEVsZW1lbnRzQnlUYWdOYW1lKCd4ZnJtJylbMF1cclxuICAgIGlmICgheGZybSkge1xyXG4gICAgICAvLyBUcnkgd2l0aCBuYW1lc3BhY2UgcHJlZml4ZXNcclxuICAgICAgeGZybSA9IHNwUHIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2E6eGZybScpWzBdXHJcbiAgICB9XHJcbiAgICBpZiAoIXhmcm0pIHtcclxuICAgICAgLy8gVHJ5IHNlYXJjaGluZyBieSBwYXJ0aWFsIHRhZyBuYW1lXHJcbiAgICAgIGNvbnN0IGFsbEVsZW1lbnRzID0gc3BQci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBlbCA9IGFsbEVsZW1lbnRzW2ldXHJcbiAgICAgICAgaWYgKGVsLnRhZ05hbWUuaW5jbHVkZXMoJ3hmcm0nKSkge1xyXG4gICAgICAgICAgeGZybSA9IGVsXHJcbiAgICAgICAgICBicmVha1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnRm91bmQgeGZybSBlbGVtZW50OicsIHhmcm0/Lm91dGVySFRNTClcclxuICAgIFxyXG4gICAgaWYgKHhmcm0pIHtcclxuICAgICAgLy8gRmluZCBvZmZzZXQsIGV4dGVudCwgYW5kIHJvdGF0aW9uIHdpdGggYmV0dGVyIG5hbWVzcGFjZSBoYW5kbGluZ1xyXG4gICAgICBsZXQgb2ZmID0geGZybS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnb2ZmJylbMF1cclxuICAgICAgaWYgKCFvZmYpIG9mZiA9IHhmcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2E6b2ZmJylbMF1cclxuICAgICAgXHJcbiAgICAgIGxldCBleHQgPSB4ZnJtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdleHQnKVswXVxyXG4gICAgICBpZiAoIWV4dCkgZXh0ID0geGZybS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYTpleHQnKVswXVxyXG4gICAgICBcclxuICAgICAgbGV0IHJvdCA9IHhmcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3JvdCcpWzBdXHJcbiAgICAgIGlmICghcm90KSByb3QgPSB4ZnJtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhOnJvdCcpWzBdXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnVHJhbnNmb3JtIGVsZW1lbnRzIC0gb2ZmOicsIG9mZj8ub3V0ZXJIVE1MLCAnZXh0OicsIGV4dD8ub3V0ZXJIVE1MLCAncm90OicsIHJvdD8ub3V0ZXJIVE1MKVxyXG4gICAgICBcclxuICAgICAgLy8gQ29udmVydCBFTVVzIHRvIHBpeGVscyB3aXRoIGJldHRlciBzY2FsaW5nXHJcbiAgICAgIC8vIDEgRU1VID0gMS85MTQ0MDAgaW5jaCwgMSBpbmNoID0gOTYgcGl4ZWxzIChzdGFuZGFyZCBEUEkpXHJcbiAgICAgIC8vIFNvIDEgRU1VID0gOTYvOTE0NDAwID0gMC4wMDAxMDUgcGl4ZWxzXHJcbiAgICAgIC8vIEZvciBiZXR0ZXIgdmlzaWJpbGl0eSwgd2UnbGwgc2NhbGUgdGhpcyB1cFxyXG4gICAgICBjb25zdCBlbXVUb1BpeGVsID0gOTYgLyA5MTQ0MDBcclxuICAgICAgY29uc3Qgc2NhbGVGYWN0b3IgPSAxIC8vIEFkanVzdCB0aGlzIHRvIG1ha2Ugc2hhcGVzIGJpZ2dlci9zbWFsbGVyXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBsZWZ0ID0gcGFyc2VJbnQob2ZmPy5nZXRBdHRyaWJ1dGUoJ3gnKSB8fCAnMCcpICogZW11VG9QaXhlbCAqIHNjYWxlRmFjdG9yXHJcbiAgICAgIGNvbnN0IHRvcCA9IHBhcnNlSW50KG9mZj8uZ2V0QXR0cmlidXRlKCd5JykgfHwgJzAnKSAqIGVtdVRvUGl4ZWwgKiBzY2FsZUZhY3RvclxyXG4gICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KGV4dD8uZ2V0QXR0cmlidXRlKCdjeCcpIHx8ICcxMDAwMDAwJykgKiBlbXVUb1BpeGVsICogc2NhbGVGYWN0b3JcclxuICAgICAgY29uc3QgaGVpZ2h0ID0gcGFyc2VJbnQoZXh0Py5nZXRBdHRyaWJ1dGUoJ2N5JykgfHwgJzEwMDAwMDAnKSAqIGVtdVRvUGl4ZWwgKiBzY2FsZUZhY3RvclxyXG4gICAgICBjb25zdCBhbmdsZSA9IHBhcnNlSW50KHJvdD8uZ2V0QXR0cmlidXRlKCd2YWwnKSB8fCAnMCcpIC8gNjAwMDAgLy8gQ29udmVydCA2MGt0aHMgdG8gZGVncmVlc1xyXG4gICAgICBcclxuICAgICAgY29uc3QgdHJhbnNmb3JtID0ge1xyXG4gICAgICAgIGxlZnQ6IE1hdGgubWF4KDAsIGxlZnQpLFxyXG4gICAgICAgIHRvcDogTWF0aC5tYXgoMCwgdG9wKSxcclxuICAgICAgICB3aWR0aDogTWF0aC5tYXgoNTAsIHdpZHRoKSwgLy8gTWluaW11bSB3aWR0aCBvZiA1MHB4XHJcbiAgICAgICAgaGVpZ2h0OiBNYXRoLm1heCg1MCwgaGVpZ2h0KSwgLy8gTWluaW11bSBoZWlnaHQgb2YgNTBweFxyXG4gICAgICAgIGFuZ2xlLFxyXG4gICAgICAgIHNjYWxlWDogMSxcclxuICAgICAgICBzY2FsZVk6IDEsXHJcbiAgICAgICAgZmxpcFg6IGZhbHNlLFxyXG4gICAgICAgIGZsaXBZOiBmYWxzZSxcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ0V4dHJhY3RlZCB0cmFuc2Zvcm0gKEVNVSB2YWx1ZXMpOicsIHtcclxuICAgICAgICBlbXVMZWZ0OiBvZmY/LmdldEF0dHJpYnV0ZSgneCcpLFxyXG4gICAgICAgIGVtdVRvcDogb2ZmPy5nZXRBdHRyaWJ1dGUoJ3knKSxcclxuICAgICAgICBlbXVXaWR0aDogZXh0Py5nZXRBdHRyaWJ1dGUoJ2N4JyksXHJcbiAgICAgICAgZW11SGVpZ2h0OiBleHQ/LmdldEF0dHJpYnV0ZSgnY3knKVxyXG4gICAgICB9KVxyXG4gICAgICBjb25zb2xlLmxvZygnQ29udmVydGVkIHRyYW5zZm9ybSAocGl4ZWxzKTonLCB0cmFuc2Zvcm0pXHJcbiAgICAgIHJldHVybiB0cmFuc2Zvcm1cclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS53YXJuKCdObyB4ZnJtIGZvdW5kLCB1c2luZyBkZWZhdWx0IHRyYW5zZm9ybScpXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBsZWZ0OiAxMDAsXHJcbiAgICAgIHRvcDogMTAwLFxyXG4gICAgICB3aWR0aDogMjAwLFxyXG4gICAgICBoZWlnaHQ6IDE1MCxcclxuICAgICAgYW5nbGU6IDAsXHJcbiAgICAgIHNjYWxlWDogMSxcclxuICAgICAgc2NhbGVZOiAxLFxyXG4gICAgICBmbGlwWDogZmFsc2UsXHJcbiAgICAgIGZsaXBZOiBmYWxzZSxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZXh0cmFjdFRleHRDb250ZW50KHRleHRCb3g6IEVsZW1lbnQpOiBzdHJpbmcge1xyXG4gICAgLy8gVHJ5IG11bHRpcGxlIGFwcHJvYWNoZXMgdG8gZmluZCB0ZXh0IGNvbnRlbnRcclxuICAgIGxldCBjb250ZW50ID0gJydcclxuICAgIFxyXG4gICAgLy8gRmlyc3QgdHJ5OiBsb29rIGZvciB0ZXh0IGluIHR4Qm9keSA+IHAgPiByID4gdFxyXG4gICAgY29uc3QgdHhCb2R5ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZSh0ZXh0Qm94LCAndHhCb2R5JylcclxuICAgIGlmICh0eEJvZHkpIHtcclxuICAgICAgY29uc3QgcGFyYWdyYXBocyA9IHRoaXMuZmluZEVsZW1lbnRzQnlUYWdOYW1lKHR4Qm9keSwgJ3AnKVxyXG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHtwYXJhZ3JhcGhzLmxlbmd0aH0gcGFyYWdyYXBocyBpbiB0ZXh0IGJveGApXHJcbiAgICAgIFxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFncmFwaHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBjb25zdCBwYXJhZ3JhcGggPSBwYXJhZ3JhcGhzW2ldXHJcbiAgICAgICAgY29uc3QgdGV4dFJ1bnMgPSB0aGlzLmZpbmRFbGVtZW50c0J5VGFnTmFtZShwYXJhZ3JhcGgsICdyJylcclxuICAgICAgICBjb25zb2xlLmxvZyhgUGFyYWdyYXBoICR7aSArIDF9IGhhcyAke3RleHRSdW5zLmxlbmd0aH0gdGV4dCBydW5zYClcclxuICAgICAgICBcclxuICAgICAgICBsZXQgcGFyYWdyYXBoVGV4dCA9ICcnXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXh0UnVucy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgY29uc3QgdGV4dFJ1biA9IHRleHRSdW5zW2pdXHJcbiAgICAgICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUodGV4dFJ1biwgJ3QnKVxyXG4gICAgICAgICAgaWYgKHRleHRFbGVtZW50ICYmIHRleHRFbGVtZW50LnRleHRDb250ZW50KSB7XHJcbiAgICAgICAgICAgIHBhcmFncmFwaFRleHQgKz0gdGV4dEVsZW1lbnQudGV4dENvbnRlbnRcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFRleHQgcnVuICR7aiArIDF9OiBcIiR7dGV4dEVsZW1lbnQudGV4dENvbnRlbnR9XCJgKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBBZGQgcGFyYWdyYXBoIHRleHQgdG8gY29udGVudFxyXG4gICAgICAgIGlmIChwYXJhZ3JhcGhUZXh0KSB7XHJcbiAgICAgICAgICBpZiAoY29udGVudCkgY29udGVudCArPSAnXFxuJyAvLyBBZGQgbGluZSBicmVhayBiZXR3ZWVuIHBhcmFncmFwaHNcclxuICAgICAgICAgIGNvbnRlbnQgKz0gcGFyYWdyYXBoVGV4dFxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTZWNvbmQgdHJ5OiBsb29rIGZvciB0ZXh0IGRpcmVjdGx5IGluIHRoZSB0ZXh0Qm94XHJcbiAgICBpZiAoIWNvbnRlbnQpIHtcclxuICAgICAgY29uc3QgdGV4dEVsZW1lbnRzID0gdGhpcy5maW5kRWxlbWVudHNCeVRhZ05hbWUodGV4dEJveCwgJ3QnKVxyXG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHt0ZXh0RWxlbWVudHMubGVuZ3RofSB0ZXh0IGVsZW1lbnRzIGRpcmVjdGx5IGluIHRleHQgYm94YClcclxuICAgICAgXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRleHRFbGVtZW50c1tpXVxyXG4gICAgICAgIGlmIChlbGVtZW50LnRleHRDb250ZW50KSB7XHJcbiAgICAgICAgICBpZiAoY29udGVudCkgY29udGVudCArPSAnXFxuJ1xyXG4gICAgICAgICAgY29udGVudCArPSBlbGVtZW50LnRleHRDb250ZW50XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgRGlyZWN0IHRleHQgZWxlbWVudCAke2kgKyAxfTogXCIke2VsZW1lbnQudGV4dENvbnRlbnR9XCJgKVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBUaGlyZCB0cnk6IGxvb2sgZm9yIGFueSB0ZXh0IGNvbnRlbnQgaW4gdGhlIGVsZW1lbnRcclxuICAgIGlmICghY29udGVudCkge1xyXG4gICAgICBjb250ZW50ID0gdGV4dEJveC50ZXh0Q29udGVudCB8fCAnJ1xyXG4gICAgICBjb25zb2xlLmxvZyhgRmFsbGJhY2sgdGV4dCBjb250ZW50OiBcIiR7Y29udGVudH1cImApXHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKGBGaW5hbCBleHRyYWN0ZWQgdGV4dCBjb250ZW50OiBcIiR7Y29udGVudH1cImApXHJcbiAgICByZXR1cm4gY29udGVudCB8fCAnVGV4dCBCb3gnXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGV4dHJhY3RUZXh0U3R5bGUodGV4dEJveDogRWxlbWVudCk6IFBhcnRpYWw8VGV4dFN0eWxlPiB7XHJcbiAgICBjb25zdCBkZWZSUHIgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHRleHRCb3gsICdkZWZSUHInKVxyXG4gICAgXHJcbiAgICBpZiAoZGVmUlByKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgZm9udEZhbWlseTogZGVmUlByLmdldEF0dHJpYnV0ZSgndHlwZWZhY2UnKSB8fCAnQXJpYWwnLFxyXG4gICAgICAgIGZvbnRTaXplOiBwYXJzZUludChkZWZSUHIuZ2V0QXR0cmlidXRlKCdzeicpIHx8ICcxODAwJykgLyAxMDAsIC8vIENvbnZlcnQgMTAwdGhzIHRvIHBvaW50c1xyXG4gICAgICAgIGZvbnRXZWlnaHQ6IGRlZlJQci5nZXRBdHRyaWJ1dGUoJ2InKSA9PT0gJzEnID8gJ2JvbGQnIDogJ25vcm1hbCcsXHJcbiAgICAgICAgZm9udFN0eWxlOiBkZWZSUHIuZ2V0QXR0cmlidXRlKCdpJykgPT09ICcxJyA/ICdpdGFsaWMnIDogJ25vcm1hbCcsXHJcbiAgICAgICAgdGV4dERlY29yYXRpb246IGRlZlJQci5nZXRBdHRyaWJ1dGUoJ3UnKSA9PT0gJzEnID8gJ3VuZGVybGluZScgOiAnbm9uZScsXHJcbiAgICAgICAgY29sb3I6IHRoaXMuZXh0cmFjdENvbG9yKGRlZlJQciksXHJcbiAgICAgICAgdGV4dEFsaWduOiAnbGVmdCcsXHJcbiAgICAgICAgbGluZUhlaWdodDogMS4yLFxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXHJcbiAgICAgIGZvbnRTaXplOiAxOCxcclxuICAgICAgZm9udFdlaWdodDogJ25vcm1hbCcsXHJcbiAgICAgIGZvbnRTdHlsZTogJ25vcm1hbCcsXHJcbiAgICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXHJcbiAgICAgIGNvbG9yOiAnIzAwMDAwMCcsXHJcbiAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxyXG4gICAgICBsaW5lSGVpZ2h0OiAxLjIsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGV4dHJhY3RDb2xvcihkZWZSUHI6IEVsZW1lbnQpOiBzdHJpbmcge1xyXG4gICAgY29uc3Qgc29saWRGaWxsID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShkZWZSUHIsICdzb2xpZEZpbGwnKVxyXG4gICAgaWYgKHNvbGlkRmlsbCkge1xyXG4gICAgICBjb25zdCBzcmdiQ2xyID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShzb2xpZEZpbGwsICdzcmdiQ2xyJylcclxuICAgICAgaWYgKHNyZ2JDbHIpIHtcclxuICAgICAgICBjb25zdCB2YWwgPSBzcmdiQ2xyLmdldEF0dHJpYnV0ZSgndmFsJylcclxuICAgICAgICBpZiAodmFsKSB7XHJcbiAgICAgICAgICByZXR1cm4gYCMke3ZhbH1gXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gJyMwMDAwMDAnXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGRldGVybWluZVNoYXBlVHlwZShzcFByOiBFbGVtZW50KTogJ3JlY3RhbmdsZScgfCAnZWxsaXBzZScgfCAnbGluZScge1xyXG4gICAgLy8gVHJ5IHRvIGZpbmQgcHJzdEdlb20gZWxlbWVudCB3aXRoIGJldHRlciBuYW1lc3BhY2UgaGFuZGxpbmdcclxuICAgIGxldCBwcnN0R2VvbSA9IHNwUHIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3Byc3RHZW9tJylbMF1cclxuICAgIGlmICghcHJzdEdlb20pIHtcclxuICAgICAgcHJzdEdlb20gPSBzcFByLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhOnByc3RHZW9tJylbMF1cclxuICAgIH1cclxuICAgIFxyXG4gICAgaWYgKHByc3RHZW9tKSB7XHJcbiAgICAgIGNvbnN0IHByc3QgPSBwcnN0R2VvbS5nZXRBdHRyaWJ1dGUoJ3Byc3QnKVxyXG4gICAgICBjb25zb2xlLmxvZyhgRm91bmQgc2hhcGUgdHlwZTogJHtwcnN0fWApXHJcbiAgICAgIFxyXG4gICAgICBzd2l0Y2ggKHByc3QpIHtcclxuICAgICAgICBjYXNlICdyZWN0JzpcclxuICAgICAgICBjYXNlICdyb3VuZFJlY3QnOlxyXG4gICAgICAgICAgcmV0dXJuICdyZWN0YW5nbGUnXHJcbiAgICAgICAgY2FzZSAnZWxsaXBzZSc6XHJcbiAgICAgICAgY2FzZSAnb3ZhbCc6XHJcbiAgICAgICAgICByZXR1cm4gJ2VsbGlwc2UnXHJcbiAgICAgICAgY2FzZSAnbGluZSc6XHJcbiAgICAgICAgY2FzZSAnc3RyYWlnaHRDb25uZWN0b3IxJzpcclxuICAgICAgICAgIHJldHVybiAnbGluZSdcclxuICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgY29uc29sZS5sb2coYFVua25vd24gc2hhcGUgdHlwZTogJHtwcnN0fSwgZGVmYXVsdGluZyB0byByZWN0YW5nbGVgKVxyXG4gICAgICAgICAgcmV0dXJuICdyZWN0YW5nbGUnXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gSWYgbm8gcHJzdEdlb20gZm91bmQsIHRyeSB0byBkZXRlcm1pbmUgZnJvbSBvdGhlciBwcm9wZXJ0aWVzXHJcbiAgICBjb25zb2xlLmxvZygnTm8gcHJzdEdlb20gZm91bmQsIGRlZmF1bHRpbmcgdG8gcmVjdGFuZ2xlJylcclxuICAgIHJldHVybiAncmVjdGFuZ2xlJ1xyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBjcmVhdGVEZWZhdWx0U2xpZGUoKTogU2xpZGUge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgICAgIG5hbWU6ICdTbGlkZSAxJyxcclxuICAgICAgd2lkdGg6IDk2MCxcclxuICAgICAgaGVpZ2h0OiA1NDAsXHJcbiAgICAgIG9iamVjdHM6IFtcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgICAgIHR5cGU6ICd0ZXh0JyxcclxuICAgICAgICAgIHRyYW5zZm9ybToge1xyXG4gICAgICAgICAgICBsZWZ0OiAxMDAsXHJcbiAgICAgICAgICAgIHRvcDogMTAwLFxyXG4gICAgICAgICAgICB3aWR0aDogMzAwLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IDEwMCxcclxuICAgICAgICAgICAgYW5nbGU6IDAsXHJcbiAgICAgICAgICAgIHNjYWxlWDogMSxcclxuICAgICAgICAgICAgc2NhbGVZOiAxLFxyXG4gICAgICAgICAgICBmbGlwWDogZmFsc2UsXHJcbiAgICAgICAgICAgIGZsaXBZOiBmYWxzZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBzdHlsZToge1xyXG4gICAgICAgICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogMjQsXHJcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdib2xkJyxcclxuICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcclxuICAgICAgICAgICAgdGV4dEFsaWduOiAnbGVmdCcsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAgY29udGVudDogJ1dlbGNvbWUgdG8gUFBUWCBFZGl0b3InLFxyXG4gICAgICAgIH1cclxuICAgICAgXSxcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZXh0cmFjdEluZGl2aWR1YWxUZXh0RWxlbWVudHModGV4dEJveDogRWxlbWVudCwgc2xpZGVOdW1iZXI6IG51bWJlciwgc2hhcGVJbmRleDogbnVtYmVyKTogU2hhcGVPYmplY3RbXSB7XHJcbiAgICBjb25zdCB0ZXh0T2JqZWN0czogU2hhcGVPYmplY3RbXSA9IFtdXHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IHR4Qm9keSA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUodGV4dEJveCwgJ3R4Qm9keScpXHJcbiAgICAgIGlmICghdHhCb2R5KSByZXR1cm4gdGV4dE9iamVjdHNcclxuICAgICAgXHJcbiAgICAgIC8vIEdldCB0aGUgYmFzZSB0cmFuc2Zvcm0gZnJvbSB0aGUgc2hhcGVcclxuICAgICAgY29uc3Qgc3BQciA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUodGV4dEJveCwgJ3NwUHInKVxyXG4gICAgICBjb25zdCBiYXNlVHJhbnNmb3JtID0gc3BQciA/IHRoaXMuZXh0cmFjdFRyYW5zZm9ybShzcFByKSA6IHtcclxuICAgICAgICBsZWZ0OiAxMDAsXHJcbiAgICAgICAgdG9wOiAxMDAsXHJcbiAgICAgICAgd2lkdGg6IDMwMCxcclxuICAgICAgICBoZWlnaHQ6IDE1MCxcclxuICAgICAgICBhbmdsZTogMCxcclxuICAgICAgICBzY2FsZVg6IDEsXHJcbiAgICAgICAgc2NhbGVZOiAxLFxyXG4gICAgICAgIGZsaXBYOiBmYWxzZSxcclxuICAgICAgICBmbGlwWTogZmFsc2UsXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHBhcmFncmFwaHMgPSB0aGlzLmZpbmRFbGVtZW50c0J5VGFnTmFtZSh0eEJvZHksICdwJylcclxuICAgICAgY29uc29sZS5sb2coYEV4dHJhY3RpbmcgJHtwYXJhZ3JhcGhzLmxlbmd0aH0gaW5kaXZpZHVhbCB0ZXh0IGVsZW1lbnRzIGZyb20gc2hhcGUgJHtzaGFwZUluZGV4ICsgMX1gKVxyXG4gICAgICBcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwYXJhZ3JhcGhzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgcGFyYWdyYXBoID0gcGFyYWdyYXBoc1tpXVxyXG4gICAgICAgIGNvbnN0IHRleHRSdW5zID0gdGhpcy5maW5kRWxlbWVudHNCeVRhZ05hbWUocGFyYWdyYXBoLCAncicpXHJcbiAgICAgICAgXHJcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCB0ZXh0UnVucy5sZW5ndGg7IGorKykge1xyXG4gICAgICAgICAgY29uc3QgdGV4dFJ1biA9IHRleHRSdW5zW2pdXHJcbiAgICAgICAgICBjb25zdCB0ZXh0RWxlbWVudCA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUodGV4dFJ1biwgJ3QnKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAodGV4dEVsZW1lbnQgJiYgdGV4dEVsZW1lbnQudGV4dENvbnRlbnQgJiYgdGV4dEVsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gdGV4dEVsZW1lbnQudGV4dENvbnRlbnQudHJpbSgpXHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBDcmVhdGluZyBpbmRpdmlkdWFsIHRleHQgb2JqZWN0OiBcIiR7dGV4dENvbnRlbnR9XCJgKVxyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgLy8gR2V0IHRleHQgc3R5bGUgZnJvbSB0aGlzIHNwZWNpZmljIHJ1blxyXG4gICAgICAgICAgICBjb25zdCByUHIgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHRleHRSdW4sICdyUHInKVxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0U3R5bGUgPSByUHIgPyB0aGlzLmV4dHJhY3RUZXh0U3R5bGVGcm9tUnVuKHJQcikgOiB0aGlzLmV4dHJhY3RUZXh0U3R5bGUodGV4dEJveClcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBiYXNlZCBvbiBwYXJhZ3JhcGggYW5kIHRleHQgcnVuIGluZGV4XHJcbiAgICAgICAgICAgIC8vIFRoaXMgY3JlYXRlcyBhIG1vcmUgbmF0dXJhbCB0ZXh0IGxheW91dFxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0TGVmdCA9IGJhc2VUcmFuc2Zvcm0ubGVmdCArIChpICogMTApXHJcbiAgICAgICAgICAgIGNvbnN0IHRleHRUb3AgPSBiYXNlVHJhbnNmb3JtLnRvcCArIChpICogMzApICsgKGogKiAyMClcclxuICAgICAgICAgICAgY29uc3QgdGV4dFdpZHRoID0gTWF0aC5tYXgoMjAwLCB0ZXh0Q29udGVudC5sZW5ndGggKiA4KSAvLyBXaWR0aCBiYXNlZCBvbiB0ZXh0IGxlbmd0aFxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0SGVpZ2h0ID0gMzBcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIC8vIENyZWF0ZSBhIHNlcGFyYXRlIHRleHQgb2JqZWN0IGZvciB0aGlzIHRleHQgZWxlbWVudFxyXG4gICAgICAgICAgICBjb25zdCB0ZXh0T2JqZWN0OiBTaGFwZU9iamVjdCA9IHtcclxuICAgICAgICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgICAgICAgICB0eXBlOiAndGV4dCcsXHJcbiAgICAgICAgICAgICAgdHJhbnNmb3JtOiB7XHJcbiAgICAgICAgICAgICAgICBsZWZ0OiB0ZXh0TGVmdCxcclxuICAgICAgICAgICAgICAgIHRvcDogdGV4dFRvcCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB0ZXh0V2lkdGgsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6IHRleHRIZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBhbmdsZTogYmFzZVRyYW5zZm9ybS5hbmdsZSxcclxuICAgICAgICAgICAgICAgIHNjYWxlWDogYmFzZVRyYW5zZm9ybS5zY2FsZVgsXHJcbiAgICAgICAgICAgICAgICBzY2FsZVk6IGJhc2VUcmFuc2Zvcm0uc2NhbGVZLFxyXG4gICAgICAgICAgICAgICAgZmxpcFg6IGJhc2VUcmFuc2Zvcm0uZmxpcFgsXHJcbiAgICAgICAgICAgICAgICBmbGlwWTogYmFzZVRyYW5zZm9ybS5mbGlwWSxcclxuICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgIHN0eWxlOiB0ZXh0U3R5bGUsXHJcbiAgICAgICAgICAgICAgY29udGVudDogdGV4dENvbnRlbnQsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIHRleHRPYmplY3RzLnB1c2godGV4dE9iamVjdClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGV4dHJhY3RpbmcgaW5kaXZpZHVhbCB0ZXh0IGVsZW1lbnRzOicsIGVycm9yKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gdGV4dE9iamVjdHNcclxuICB9XHJcbiAgXHJcbiAgcHJpdmF0ZSBleHRyYWN0VGV4dFN0eWxlRnJvbVJ1bihyUHI6IEVsZW1lbnQpOiBQYXJ0aWFsPFRleHRTdHlsZT4ge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZm9udEZhbWlseTogclByLmdldEF0dHJpYnV0ZSgndHlwZWZhY2UnKSB8fCAnQXJpYWwnLFxyXG4gICAgICBmb250U2l6ZTogcGFyc2VJbnQoclByLmdldEF0dHJpYnV0ZSgnc3onKSB8fCAnMTgwMCcpIC8gMTAwLFxyXG4gICAgICBmb250V2VpZ2h0OiByUHIuZ2V0QXR0cmlidXRlKCdiJykgPT09ICcxJyA/ICdib2xkJyA6ICdub3JtYWwnLFxyXG4gICAgICBmb250U3R5bGU6IHJQci5nZXRBdHRyaWJ1dGUoJ2knKSA9PT0gJzEnID8gJ2l0YWxpYycgOiAnbm9ybWFsJyxcclxuICAgICAgdGV4dERlY29yYXRpb246IHJQci5nZXRBdHRyaWJ1dGUoJ3UnKSA9PT0gJzEnID8gJ3VuZGVybGluZScgOiAnbm9uZScsXHJcbiAgICAgIGNvbG9yOiB0aGlzLmV4dHJhY3RDb2xvcihyUHIpLFxyXG4gICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcclxuICAgICAgbGluZUhlaWdodDogMS4yLFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuIl0sIm5hbWVzIjpbIkpTWmlwIiwiUFBUWFBhcnNlciIsInBhcnNlRmlsZSIsImZpbGUiLCJjb25zb2xlIiwibG9nIiwiemlwIiwibG9hZEFzeW5jIiwiZmlsZU5hbWVzIiwiT2JqZWN0Iiwia2V5cyIsImZpbGVzIiwic2xpZGVzIiwicmVhZFNsaWRlcyIsInByb3BlcnRpZXMiLCJyZWFkUHJlc2VudGF0aW9uUHJvcHMiLCJpZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJuYW1lIiwicmVwbGFjZSIsIm1ldGFkYXRhIiwiZXJyb3IiLCJjb3JlUHJvcHMiLCJjb250ZW50IiwiYXN5bmMiLCJwYXJzZXIiLCJET01QYXJzZXIiLCJ4bWwiLCJwYXJzZUZyb21TdHJpbmciLCJhdXRob3JFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImF1dGhvciIsInRleHRDb250ZW50IiwidW5kZWZpbmVkIiwid2FybiIsInByZXNlbnRhdGlvbiIsInN1YnN0cmluZyIsInNsaWRlSWRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJsZW5ndGgiLCJzbGlkZUZpbGVzIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwic29ydCIsImkiLCJzbGlkZUZpbGUiLCJzbGlkZU51bWJlciIsInNsaWRlIiwicmVhZFNsaWRlRnJvbUZpbGUiLCJwdXNoIiwic2xpZGVJZCIsImdldEF0dHJpYnV0ZSIsInJlYWRTbGlkZSIsImNyZWF0ZURlZmF1bHRTbGlkZSIsInNsaWRlUmVsIiwicmVsWG1sIiwicmVsQ29udGVudCIsInJlbFBhcnNlciIsInNsaWRlVGFyZ2V0Iiwic2xpZGVQYXRoIiwic3BsaXQiLCJwb3AiLCJ0YXJnZXRTbGlkZSIsInNsaWRlQ29udGVudCIsInNsaWRlUGFyc2VyIiwic2xpZGVYbWwiLCJzbGRTeiIsIndpZHRoIiwicGFyc2VJbnQiLCJoZWlnaHQiLCJvYmplY3RzIiwiZXh0cmFjdFNoYXBlcyIsInNsaWRlRmlsZVBhdGgiLCJjeCIsImN5IiwiZW11VG9QaXhlbCIsIk1hdGgiLCJtYXgiLCJzcFRyZWUiLCJmaW5kRWxlbWVudEJ5VGFnTmFtZSIsInRleHRCb3hlcyIsImZpbmRFbGVtZW50c0J5VGFnTmFtZSIsInRleHRCb3giLCJ0YWdOYW1lIiwibnZQciIsInBoIiwicGhUeXBlIiwiZ3JwU3AiLCJncm91cE9iamVjdCIsImV4dHJhY3RHcm91cGVkU2hhcGUiLCJjaGlsZHJlbiIsInR4Qm9keSIsImhhc1RleHQiLCJ0ZXh0T2JqZWN0cyIsImV4dHJhY3RJbmRpdmlkdWFsVGV4dEVsZW1lbnRzIiwic2hhcGUiLCJleHRyYWN0QmFzaWNTaGFwZSIsInR5cGUiLCJhbGxTcEVsZW1lbnRzIiwic3BFbGVtZW50IiwidGV4dEVsZW1lbnRzIiwiZmlyc3RUZXh0IiwidGV4dE9iamVjdCIsInRyYW5zZm9ybSIsImxlZnQiLCJ0b3AiLCJhbmdsZSIsInNjYWxlWCIsInNjYWxlWSIsImZsaXBYIiwiZmxpcFkiLCJzdHlsZSIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJmb250U3R5bGUiLCJ0ZXh0RGVjb3JhdGlvbiIsImNvbG9yIiwidGV4dEFsaWduIiwibGluZUhlaWdodCIsImltYWdlcyIsImltYWdlIiwiZXh0cmFjdEltYWdlIiwibWFwIiwib2JqIiwicGFyZW50IiwiZWxlbWVudCIsInByZWZpeGVzIiwicHJlZml4IiwiZnVsbFRhZ05hbWUiLCJhbGxFbGVtZW50cyIsImVsIiwiaW5jbHVkZXMiLCJlbGVtZW50cyIsIkFycmF5IiwiZnJvbSIsIm1hdGNoaW5nRWxlbWVudHMiLCJpbmRleCIsInNwUHIiLCJleHRyYWN0VHJhbnNmb3JtIiwiYmxpcEZpbGwiLCJibGlwIiwiZW1iZWQiLCJsaW5rIiwiaW1hZ2VJZCIsImltYWdlRmlsZSIsImZpbmRJbWFnZUZpbGUiLCJpbWFnZURhdGEiLCJtaW1lVHlwZSIsImdldE1pbWVUeXBlIiwiZGF0YVVybCIsInNyYyIsImJ0b2EiLCJyZWxzRmlsZSIsInJlbHNDb250ZW50IiwicmVsc1BhcnNlciIsInJlbHNYbWwiLCJyZWxhdGlvbnNoaXAiLCJ0YXJnZXQiLCJpbWFnZVBhdGgiLCJzbGljZSIsImNvbW1vblBhdGhzIiwicGF0aCIsImFsbEZpbGVzIiwiaW1hZ2VGaWxlcyIsImZpbGVuYW1lIiwiZXh0IiwidG9Mb3dlckNhc2UiLCJncnBTcFByIiwiY2hpbGRTcEVsZW1lbnRzIiwiY2hpbGRTcCIsImNoaWxkU2hhcGUiLCJjaGlsZFBpY0VsZW1lbnRzIiwiY2hpbGRQaWMiLCJjaGlsZEltYWdlIiwiZ3JvdXBJZCIsInByc3RHZW9tIiwic2hhcGVUeXBlIiwicHJzdCIsImN1c3RHZW9tIiwiZXh0cmFjdFRleHRDb250ZW50IiwiY052UHIiLCJzaGFwZU5hbWUiLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJyeCIsInJ5Iiwib3V0ZXJIVE1MIiwieGZybSIsIm9mZiIsInJvdCIsInNjYWxlRmFjdG9yIiwiZW11TGVmdCIsImVtdVRvcCIsImVtdVdpZHRoIiwiZW11SGVpZ2h0IiwicGFyYWdyYXBocyIsInBhcmFncmFwaCIsInRleHRSdW5zIiwicGFyYWdyYXBoVGV4dCIsImoiLCJ0ZXh0UnVuIiwidGV4dEVsZW1lbnQiLCJleHRyYWN0VGV4dFN0eWxlIiwiZGVmUlByIiwiZXh0cmFjdENvbG9yIiwic29saWRGaWxsIiwic3JnYkNsciIsInZhbCIsImRldGVybWluZVNoYXBlVHlwZSIsInNoYXBlSW5kZXgiLCJiYXNlVHJhbnNmb3JtIiwidHJpbSIsInJQciIsInRleHRTdHlsZSIsImV4dHJhY3RUZXh0U3R5bGVGcm9tUnVuIiwidGV4dExlZnQiLCJ0ZXh0VG9wIiwidGV4dFdpZHRoIiwidGV4dEhlaWdodCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/pptxParser.ts\n"));

/***/ })

});