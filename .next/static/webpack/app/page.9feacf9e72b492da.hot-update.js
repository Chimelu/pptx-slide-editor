"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./src/utils/pptxParser.ts":
/*!*********************************!*\
  !*** ./src/utils/pptxParser.ts ***!
  \*********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PPTXParser: function() { return /* binding */ PPTXParser; }\n/* harmony export */ });\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! jszip */ \"(app-pages-browser)/./node_modules/jszip/dist/jszip.min.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_0__);\n\nclass PPTXParser {\n    async parseFile(file) {\n        try {\n            console.log(\"Starting PPTX parsing...\");\n            // Load the ZIP file\n            this.zip = await jszip__WEBPACK_IMPORTED_MODULE_0___default().loadAsync(file);\n            console.log(\"ZIP file loaded successfully\");\n            // List all files for debugging\n            const fileNames = Object.keys(this.zip.files);\n            console.log(\"Files in ZIP:\", fileNames);\n            // Parse the document\n            const slides = await this.readSlides();\n            const properties = await this.readPresentationProps();\n            console.log(\"Parsing completed successfully\");\n            return {\n                id: crypto.randomUUID(),\n                name: file.name.replace(\".pptx\", \"\"),\n                slides,\n                metadata: properties\n            };\n        } catch (error) {\n            console.error(\"Error parsing PPTX file:\", error);\n            throw error;\n        }\n    }\n    async readPresentationProps() {\n        try {\n            var _this_zip;\n            const coreProps = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(\"docProps/core.xml\");\n            if (coreProps) {\n                const content = await coreProps.async(\"text\");\n                const parser = new DOMParser();\n                const xml = parser.parseFromString(content, \"text/xml\");\n                const authorElement = xml.querySelector(\"dc\\\\:creator, creator\");\n                return {\n                    author: (authorElement === null || authorElement === void 0 ? void 0 : authorElement.textContent) || undefined\n                };\n            }\n        } catch (error) {\n            console.warn(\"Could not read presentation properties:\", error);\n        }\n        return {};\n    }\n    async readSlides() {\n        const slides = [];\n        try {\n            var _this_zip;\n            // Get slide count from presentation.xml\n            const presentation = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(\"ppt/presentation.xml\");\n            if (presentation) {\n                const content = await presentation.async(\"text\");\n                console.log(\"Presentation XML content:\", content.substring(0, 500) + \"...\");\n                const parser = new DOMParser();\n                const xml = parser.parseFromString(content, \"text/xml\");\n                // Try multiple approaches to find slides\n                let slideIds = xml.getElementsByTagName(\"sldId\");\n                console.log(\"Found \".concat(slideIds.length, \" slides using 'sldId' tag\"));\n                // If no slides found, try alternative approaches\n                if (slideIds.length === 0) {\n                    var _this_zip1;\n                    // Try looking for slides in the slides folder directly\n                    const slideFiles = Object.keys(((_this_zip1 = this.zip) === null || _this_zip1 === void 0 ? void 0 : _this_zip1.files) || {}).filter((name)=>name.startsWith(\"ppt/slides/slide\") && name.endsWith(\".xml\")).sort();\n                    console.log(\"Found slide files directly:\", slideFiles);\n                    if (slideFiles.length > 0) {\n                        // Create slides from the files we found\n                        for(let i = 0; i < slideFiles.length; i++){\n                            const slideFile = slideFiles[i];\n                            const slideNumber = i + 1;\n                            console.log(\"Processing slide file: \".concat(slideFile));\n                            const slide = await this.readSlideFromFile(slideFile, slideNumber);\n                            if (slide) {\n                                slides.push(slide);\n                                console.log(\"Successfully loaded slide \".concat(slideNumber, \" from file\"));\n                            }\n                        }\n                    }\n                } else {\n                    // Process slides using the traditional method\n                    for(let i = 0; i < slideIds.length; i++){\n                        const slideId = slideIds[i].getAttribute(\"r:id\");\n                        console.log(\"Processing slide \".concat(i + 1, \" with ID: \").concat(slideId));\n                        if (slideId) {\n                            const slide = await this.readSlide(slideId, i + 1);\n                            if (slide) {\n                                slides.push(slide);\n                                console.log(\"Successfully loaded slide \".concat(i + 1));\n                            } else {\n                                console.warn(\"Failed to load slide \".concat(i + 1));\n                            }\n                        }\n                    }\n                }\n            } else {\n                console.warn(\"Could not find presentation.xml\");\n            }\n        } catch (error) {\n            console.error(\"Error reading slides:\", error);\n            // Create a default slide if parsing fails\n            slides.push(this.createDefaultSlide());\n        }\n        console.log(\"Total slides loaded: \".concat(slides.length));\n        return slides.length > 0 ? slides : [\n            this.createDefaultSlide()\n        ];\n    }\n    async readSlide(slideId, slideNumber) {\n        try {\n            var _this_zip;\n            // Try to find the slide file directly first\n            let slideFile = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(\"ppt/slides/slide\".concat(slideNumber, \".xml\"));\n            // If not found, try to find it through relationships\n            if (!slideFile) {\n                var _this_zip1;\n                const slideRel = (_this_zip1 = this.zip) === null || _this_zip1 === void 0 ? void 0 : _this_zip1.file(\"ppt/slides/_rels/slide\".concat(slideNumber, \".xml.rels\"));\n                if (slideRel) {\n                    var _relXml_querySelector;\n                    const relContent = await slideRel.async(\"text\");\n                    const relParser = new DOMParser();\n                    const relXml = relParser.parseFromString(relContent, \"text/xml\");\n                    const slideTarget = (_relXml_querySelector = relXml.querySelector('Relationship[Id=\"'.concat(slideId, '\"]'))) === null || _relXml_querySelector === void 0 ? void 0 : _relXml_querySelector.getAttribute(\"Target\");\n                    if (slideTarget) {\n                        var _this_zip2;\n                        const slidePath = \"ppt/slides/\".concat(slideTarget.split(\"/\").pop());\n                        slideFile = (_this_zip2 = this.zip) === null || _this_zip2 === void 0 ? void 0 : _this_zip2.file(slidePath);\n                    }\n                }\n            }\n            // If still not found, try to find any slide file\n            if (!slideFile) {\n                var _this_zip3;\n                const slideFiles = Object.keys(((_this_zip3 = this.zip) === null || _this_zip3 === void 0 ? void 0 : _this_zip3.files) || {}).filter((name)=>name.startsWith(\"ppt/slides/slide\") && name.endsWith(\".xml\")).sort();\n                if (slideFiles.length > 0) {\n                    var _this_zip4;\n                    const targetSlide = slideFiles[slideNumber - 1] || slideFiles[0];\n                    slideFile = (_this_zip4 = this.zip) === null || _this_zip4 === void 0 ? void 0 : _this_zip4.file(targetSlide);\n                }\n            }\n            if (!slideFile) {\n                console.warn(\"Could not find slide file for slide \".concat(slideNumber));\n                return null;\n            }\n            const slideContent = await slideFile.async(\"text\");\n            const slideParser = new DOMParser();\n            const slideXml = slideParser.parseFromString(slideContent, \"text/xml\");\n            // Extract slide dimensions\n            const sldSz = slideXml.getElementsByTagName(\"sldSz\")[0];\n            const width = parseInt((sldSz === null || sldSz === void 0 ? void 0 : sldSz.getAttribute(\"cx\")) || \"9144000\") / 12700 // Convert EMUs to pixels\n            ;\n            const height = parseInt((sldSz === null || sldSz === void 0 ? void 0 : sldSz.getAttribute(\"cy\")) || \"6858000\") / 12700;\n            // Extract shapes\n            const objects = await this.extractShapes(slideXml, slideNumber);\n            return {\n                id: crypto.randomUUID(),\n                name: \"Slide \".concat(slideNumber),\n                width,\n                height,\n                objects\n            };\n        } catch (error) {\n            console.error(\"Error reading slide \".concat(slideNumber, \":\"), error);\n            return null;\n        }\n    }\n    async readSlideFromFile(slideFilePath, slideNumber) {\n        try {\n            var _this_zip;\n            const slideFile = (_this_zip = this.zip) === null || _this_zip === void 0 ? void 0 : _this_zip.file(slideFilePath);\n            if (!slideFile) {\n                console.warn(\"Could not find slide file: \".concat(slideFilePath));\n                return null;\n            }\n            const slideContent = await slideFile.async(\"text\");\n            console.log(\"Slide \".concat(slideNumber, \" XML content:\"), slideContent.substring(0, 1000) + \"...\");\n            const slideParser = new DOMParser();\n            const slideXml = slideParser.parseFromString(slideContent, \"text/xml\");\n            // Extract slide dimensions\n            const sldSz = slideXml.getElementsByTagName(\"sldSz\")[0];\n            const width = parseInt((sldSz === null || sldSz === void 0 ? void 0 : sldSz.getAttribute(\"cx\")) || \"9144000\") / 12700 // Convert EMUs to pixels\n            ;\n            const height = parseInt((sldSz === null || sldSz === void 0 ? void 0 : sldSz.getAttribute(\"cy\")) || \"6858000\") / 12700;\n            // Extract shapes\n            const objects = await this.extractShapes(slideXml, slideNumber);\n            return {\n                id: crypto.randomUUID(),\n                name: \"Slide \".concat(slideNumber),\n                width,\n                height,\n                objects\n            };\n        } catch (error) {\n            console.error(\"Error reading slide from file \".concat(slideFilePath, \":\"), error);\n            return null;\n        }\n    }\n    async extractShapes(slideXml, slideNumber) {\n        const objects = [];\n        try {\n            console.log(\"Extracting shapes from slide \".concat(slideNumber));\n            // Try multiple approaches to find shapes\n            // Approach 1: Look for spTree > sp (traditional structure)\n            // Use a more robust approach to handle namespaces\n            let spTree = this.findElementByTagName(slideXml, \"spTree\");\n            if (spTree) {\n                const textBoxes = this.findElementsByTagName(spTree, \"sp\");\n                console.log(\"Found \".concat(textBoxes.length, \" shape elements in spTree\"));\n                for(let i = 0; i < textBoxes.length; i++){\n                    const textBox = textBoxes[i];\n                    console.log(\"Processing shape \".concat(i + 1, \":\"), textBox.tagName, textBox.getAttribute(\"id\"), textBox.getAttribute(\"name\"));\n                    // Check if this is a placeholder\n                    const nvPr = this.findElementByTagName(textBox, \"nvPr\");\n                    const ph = nvPr ? this.findElementByTagName(nvPr, \"ph\") : null;\n                    if (ph) {\n                        const phType = ph.getAttribute(\"type\");\n                        console.log(\"Shape \".concat(i + 1, \" is a placeholder of type: \").concat(phType));\n                    }\n                    const shape = this.extractTextBox(textBox, slideNumber, i);\n                    if (shape) {\n                        objects.push(shape);\n                        console.log(\"Successfully extracted shape \".concat(i + 1, \":\"), shape.type, shape.content || \"no content\");\n                    } else {\n                        console.warn(\"Failed to extract shape \".concat(i + 1));\n                    }\n                }\n            } else {\n                console.warn(\"No spTree found in slide\");\n            }\n            // Approach 2: Look for shapes directly in the slide\n            if (objects.length === 0) {\n                console.log(\"Trying alternative shape extraction...\");\n                // Look for any sp elements anywhere in the slide\n                const allSpElements = this.findElementsByTagName(slideXml, \"sp\");\n                console.log(\"Found \".concat(allSpElements.length, \" sp elements in slide\"));\n                for(let i = 0; i < allSpElements.length; i++){\n                    const spElement = allSpElements[i];\n                    console.log(\"Processing sp element \".concat(i + 1, \":\"), spElement.tagName, spElement.getAttribute(\"id\"));\n                    const shape = this.extractTextBox(spElement, slideNumber, i);\n                    if (shape) {\n                        objects.push(shape);\n                        console.log(\"Successfully extracted sp element \".concat(i + 1, \":\"), shape.type, shape.content || \"no content\");\n                    }\n                }\n            }\n            // Approach 3: Look for text elements directly\n            if (objects.length === 0) {\n                console.log(\"Trying direct text extraction...\");\n                const textElements = this.findElementsByTagName(slideXml, \"t\");\n                console.log(\"Found \".concat(textElements.length, \" text elements directly in slide\"));\n                if (textElements.length > 0) {\n                    // Create a simple text object from the first text element\n                    const firstText = textElements[0];\n                    const textContent = firstText.textContent || \"Text\";\n                    console.log('Creating text object with content: \"'.concat(textContent, '\"'));\n                    const textObject = {\n                        id: crypto.randomUUID(),\n                        type: \"text\",\n                        transform: {\n                            left: 100,\n                            top: 100,\n                            width: 300,\n                            height: 100,\n                            angle: 0,\n                            scaleX: 1,\n                            scaleY: 1,\n                            flipX: false,\n                            flipY: false\n                        },\n                        style: {\n                            fontFamily: \"Arial\",\n                            fontSize: 18,\n                            fontWeight: \"normal\",\n                            fontStyle: \"normal\",\n                            textDecoration: \"none\",\n                            color: \"#000000\",\n                            textAlign: \"left\",\n                            lineHeight: 1.2\n                        },\n                        content: textContent\n                    };\n                    objects.push(textObject);\n                    console.log(\"Created fallback text object\");\n                }\n            }\n            // Extract images\n            const images = this.findElementsByTagName(slideXml, \"pic\");\n            console.log(\"Found \".concat(images.length, \" image elements\"));\n            for(let i = 0; i < images.length; i++){\n                const image = images[i];\n                const shape = this.extractImage(image, slideNumber, i);\n                if (shape) {\n                    objects.push(shape);\n                    console.log(\"Successfully extracted image \".concat(i + 1));\n                }\n            }\n            console.log(\"Total objects extracted: \".concat(objects.length));\n            console.log(\"Final objects:\", objects.map((obj)=>({\n                    type: obj.type,\n                    content: obj.content,\n                    transform: obj.transform\n                })));\n        } catch (error) {\n            console.error(\"Error extracting shapes:\", error);\n        }\n        return objects;\n    }\n    // Helper methods to handle XML namespaces\n    findElementByTagName(parent, tagName) {\n        // Try multiple approaches to find the element\n        let element = parent.getElementsByTagName(tagName)[0];\n        if (element) return element;\n        // If not found, try with common namespace prefixes\n        const prefixes = [\n            \"p:\",\n            \"a:\",\n            \"r:\",\n            \"\"\n        ];\n        for (const prefix of prefixes){\n            const fullTagName = prefix + tagName;\n            element = parent.getElementsByTagName(fullTagName)[0];\n            if (element) return element;\n        }\n        // Last resort: search by partial tag name\n        const allElements = parent.getElementsByTagName(\"*\");\n        for(let i = 0; i < allElements.length; i++){\n            const el = allElements[i];\n            if (el.tagName.endsWith(tagName) || el.tagName.includes(tagName)) {\n                return el;\n            }\n        }\n        return null;\n    }\n    findElementsByTagName(parent, tagName) {\n        // Try multiple approaches to find elements\n        let elements = Array.from(parent.getElementsByTagName(tagName));\n        if (elements.length > 0) return elements;\n        // If not found, try with common namespace prefixes\n        const prefixes = [\n            \"p:\",\n            \"a:\",\n            \"r:\",\n            \"\"\n        ];\n        for (const prefix of prefixes){\n            const fullTagName = prefix + tagName;\n            elements = Array.from(parent.getElementsByTagName(fullTagName));\n            if (elements.length > 0) return elements;\n        }\n        // Last resort: search by partial tag name\n        const allElements = parent.getElementsByTagName(\"*\");\n        const matchingElements = [];\n        for(let i = 0; i < allElements.length; i++){\n            const el = allElements[i];\n            if (el.tagName.endsWith(tagName) || el.tagName.includes(tagName)) {\n                matchingElements.push(el);\n            }\n        }\n        return matchingElements;\n    }\n    extractTextBox(textBox, slideNumber, index) {\n        try {\n            console.log(\"Extracting text box \".concat(index + 1, \" from slide \").concat(slideNumber));\n            console.log(\"Text box element:\", textBox.outerHTML.substring(0, 500) + \"...\");\n            const spPr = this.findElementByTagName(textBox, \"spPr\");\n            if (!spPr) {\n                console.warn(\"No spPr found in text box \".concat(index + 1));\n                return null;\n            }\n            // Check if this is actually a text shape or a different type\n            const txBody = this.findElementByTagName(textBox, \"txBody\");\n            const hasText = txBody && this.findElementsByTagName(txBody, \"t\").length > 0;\n            // Check if this is a placeholder or shape with text\n            const nvPr = this.findElementByTagName(textBox, \"nvPr\");\n            const ph = nvPr ? this.findElementByTagName(nvPr, \"ph\") : null;\n            const isPlaceholder = ph && ph.getAttribute(\"type\");\n            // Check the actual shape type from spPr\n            const prstGeom = spPr.getElementsByTagName(\"prstGeom\")[0] || spPr.getElementsByTagName(\"a:prstGeom\")[0];\n            const shapeType = prstGeom === null || prstGeom === void 0 ? void 0 : prstGeom.getAttribute(\"prst\");\n            console.log(\"Shape \".concat(index + 1, \" - hasText: \").concat(hasText, \", isPlaceholder: \").concat(isPlaceholder, \", shapeType: \").concat(shapeType));\n            // If this is a rectangle, ellipse, or other shape (not text), extract as basic shape\n            if (shapeType && [\n                \"rect\",\n                \"roundRect\",\n                \"ellipse\",\n                \"oval\",\n                \"line\"\n            ].includes(shapeType)) {\n                console.log(\"Shape \".concat(index + 1, \" is a \").concat(shapeType, \", treating as basic shape\"));\n                return this.extractBasicShape(textBox, slideNumber, index);\n            }\n            // If this has no text and is not a placeholder, treat as basic shape\n            if (!hasText && !isPlaceholder) {\n                console.log(\"Shape \".concat(index + 1, \" has no text and is not a placeholder, treating as basic shape\"));\n                return this.extractBasicShape(textBox, slideNumber, index);\n            }\n            const transform = this.extractTransform(spPr);\n            const textContent = this.extractTextContent(textBox);\n            const textStyle = this.extractTextStyle(textBox);\n            console.log('Extracted text box: content=\"'.concat(textContent, '\", transform='), transform);\n            return {\n                id: crypto.randomUUID(),\n                type: \"text\",\n                transform,\n                style: textStyle,\n                content: textContent\n            };\n        } catch (error) {\n            console.error(\"Error extracting text box:\", error);\n            return null;\n        }\n    }\n    extractImage(image, slideNumber, index) {\n        try {\n            const spPr = this.findElementByTagName(image, \"spPr\");\n            if (!spPr) return null;\n            const transform = this.extractTransform(spPr);\n            // For now, we'll create a placeholder image\n            // In a real implementation, you'd extract the actual image data\n            return {\n                id: crypto.randomUUID(),\n                type: \"image\",\n                transform,\n                style: {},\n                src: \"data:image/svg+xml;base64,\".concat(btoa('<svg width=\"100\" height=\"100\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"100\" height=\"100\" fill=\"#ccc\"/><text x=\"50\" y=\"50\" text-anchor=\"middle\" dy=\".3em\">Image</text></svg>'))\n            };\n        } catch (error) {\n            console.error(\"Error extracting image:\", error);\n            return null;\n        }\n    }\n    extractBasicShape(shape, slideNumber, index) {\n        try {\n            console.log(\"Extracting basic shape \".concat(index + 1, \" from slide \").concat(slideNumber));\n            const spPr = this.findElementByTagName(shape, \"spPr\");\n            if (!spPr) {\n                console.warn(\"No spPr found in basic shape \".concat(index + 1));\n                return null;\n            }\n            const transform = this.extractTransform(spPr);\n            // Get the actual shape type from the XML\n            let prstGeom = spPr.getElementsByTagName(\"prstGeom\")[0];\n            if (!prstGeom) {\n                prstGeom = spPr.getElementsByTagName(\"a:prstGeom\")[0];\n            }\n            let shapeType = \"rectangle\";\n            if (prstGeom) {\n                const prst = prstGeom.getAttribute(\"prst\");\n                console.log(\"Found shape type in XML: \".concat(prst));\n                switch(prst){\n                    case \"rect\":\n                    case \"roundRect\":\n                        shapeType = \"rectangle\";\n                        break;\n                    case \"ellipse\":\n                    case \"oval\":\n                        shapeType = \"ellipse\";\n                        break;\n                    case \"line\":\n                    case \"straightConnector1\":\n                        shapeType = \"line\";\n                        break;\n                    default:\n                        console.log(\"Unknown shape type: \".concat(prst, \", defaulting to rectangle\"));\n                        shapeType = \"rectangle\";\n                }\n            }\n            console.log(\"Extracted basic shape: type=\".concat(shapeType, \", transform=\"), transform);\n            // For basic shapes, we might still have some text content (like placeholders)\n            let content = \"\";\n            const txBody = this.findElementByTagName(shape, \"txBody\");\n            if (txBody) {\n                content = this.extractTextContent(shape);\n            }\n            // Check if this is a placeholder\n            const nvPr = this.findElementByTagName(shape, \"nvPr\");\n            const ph = nvPr ? this.findElementByTagName(nvPr, \"ph\") : null;\n            if (ph) {\n                const phType = ph.getAttribute(\"type\");\n                if (phType === \"title\") {\n                    content = \"Title Placeholder\";\n                } else if (phType === \"body\") {\n                    content = \"Body Placeholder\";\n                } else if (phType === \"pic\") {\n                    content = \"Picture Placeholder\";\n                } else {\n                    content = \"Content Placeholder\";\n                }\n            }\n            // Get shape name for better identification\n            const cNvPr = this.findElementByTagName(shape, \"cNvPr\");\n            const shapeName = (cNvPr === null || cNvPr === void 0 ? void 0 : cNvPr.getAttribute(\"name\")) || \"Shape \".concat(index + 1);\n            console.log(\"Shape name: \".concat(shapeName));\n            return {\n                id: crypto.randomUUID(),\n                type: shapeType,\n                transform,\n                style: {\n                    fill: shapeType === \"line\" ? \"transparent\" : \"#e5e7eb\",\n                    stroke: \"#6b7280\",\n                    strokeWidth: shapeType === \"line\" ? 2 : 1\n                },\n                content: content || undefined\n            };\n        } catch (error) {\n            console.error(\"Error extracting basic shape:\", error);\n            return null;\n        }\n    }\n    extractTransform(spPr) {\n        // Debug the spPr element structure\n        console.log(\"Extracting transform from spPr:\", spPr.outerHTML.substring(0, 500) + \"...\");\n        // Try to find xfrm element with better namespace handling\n        let xfrm = spPr.getElementsByTagName(\"xfrm\")[0];\n        if (!xfrm) {\n            // Try with namespace prefixes\n            xfrm = spPr.getElementsByTagName(\"a:xfrm\")[0];\n        }\n        if (!xfrm) {\n            // Try searching by partial tag name\n            const allElements = spPr.getElementsByTagName(\"*\");\n            for(let i = 0; i < allElements.length; i++){\n                const el = allElements[i];\n                if (el.tagName.includes(\"xfrm\")) {\n                    xfrm = el;\n                    break;\n                }\n            }\n        }\n        console.log(\"Found xfrm element:\", xfrm === null || xfrm === void 0 ? void 0 : xfrm.outerHTML);\n        if (xfrm) {\n            // Find offset, extent, and rotation with better namespace handling\n            let off = xfrm.getElementsByTagName(\"off\")[0];\n            if (!off) off = xfrm.getElementsByTagName(\"a:off\")[0];\n            let ext = xfrm.getElementsByTagName(\"ext\")[0];\n            if (!ext) ext = xfrm.getElementsByTagName(\"a:ext\")[0];\n            let rot = xfrm.getElementsByTagName(\"rot\")[0];\n            if (!rot) rot = xfrm.getElementsByTagName(\"a:rot\")[0];\n            console.log(\"Transform elements - off:\", off === null || off === void 0 ? void 0 : off.outerHTML, \"ext:\", ext === null || ext === void 0 ? void 0 : ext.outerHTML, \"rot:\", rot === null || rot === void 0 ? void 0 : rot.outerHTML);\n            // Convert EMUs to pixels with better scaling\n            // 1 EMU = 1/914400 inch, 1 inch = 96 pixels (standard DPI)\n            // So 1 EMU = 96/914400 = 0.000105 pixels\n            // For better visibility, we'll scale this up\n            const emuToPixel = 96 / 914400;\n            const scaleFactor = 1 // Adjust this to make shapes bigger/smaller\n            ;\n            const left = parseInt((off === null || off === void 0 ? void 0 : off.getAttribute(\"x\")) || \"0\") * emuToPixel * scaleFactor;\n            const top = parseInt((off === null || off === void 0 ? void 0 : off.getAttribute(\"y\")) || \"0\") * emuToPixel * scaleFactor;\n            const width = parseInt((ext === null || ext === void 0 ? void 0 : ext.getAttribute(\"cx\")) || \"1000000\") * emuToPixel * scaleFactor;\n            const height = parseInt((ext === null || ext === void 0 ? void 0 : ext.getAttribute(\"cy\")) || \"1000000\") * emuToPixel * scaleFactor;\n            const angle = parseInt((rot === null || rot === void 0 ? void 0 : rot.getAttribute(\"val\")) || \"0\") / 60000 // Convert 60kths to degrees\n            ;\n            const transform = {\n                left: Math.max(0, left),\n                top: Math.max(0, top),\n                width: Math.max(50, width),\n                height: Math.max(50, height),\n                angle,\n                scaleX: 1,\n                scaleY: 1,\n                flipX: false,\n                flipY: false\n            };\n            console.log(\"Extracted transform (EMU values):\", {\n                emuLeft: off === null || off === void 0 ? void 0 : off.getAttribute(\"x\"),\n                emuTop: off === null || off === void 0 ? void 0 : off.getAttribute(\"y\"),\n                emuWidth: ext === null || ext === void 0 ? void 0 : ext.getAttribute(\"cx\"),\n                emuHeight: ext === null || ext === void 0 ? void 0 : ext.getAttribute(\"cy\")\n            });\n            console.log(\"Converted transform (pixels):\", transform);\n            return transform;\n        }\n        console.warn(\"No xfrm found, using default transform\");\n        return {\n            left: 100,\n            top: 100,\n            width: 200,\n            height: 150,\n            angle: 0,\n            scaleX: 1,\n            scaleY: 1,\n            flipX: false,\n            flipY: false\n        };\n    }\n    extractTextContent(textBox) {\n        // Try multiple approaches to find text content\n        let content = \"\";\n        // First try: look for text in txBody > p > r > t\n        const txBody = this.findElementByTagName(textBox, \"txBody\");\n        if (txBody) {\n            const paragraphs = this.findElementsByTagName(txBody, \"p\");\n            for(let i = 0; i < paragraphs.length; i++){\n                const paragraph = paragraphs[i];\n                const textRuns = this.findElementsByTagName(paragraph, \"r\");\n                for(let j = 0; j < textRuns.length; j++){\n                    const textRun = textRuns[j];\n                    const textElement = this.findElementByTagName(textRun, \"t\");\n                    if (textElement && textElement.textContent) {\n                        content += textElement.textContent;\n                    }\n                }\n                // Add line break between paragraphs\n                if (i < paragraphs.length - 1) {\n                    content += \"\\n\";\n                }\n            }\n        }\n        // Second try: look for text directly in the textBox\n        if (!content) {\n            const textElements = this.findElementsByTagName(textBox, \"t\");\n            for(let i = 0; i < textElements.length; i++){\n                const element = textElements[i];\n                if (element.textContent) {\n                    content += element.textContent;\n                }\n            }\n        }\n        // Third try: look for any text content in the element\n        if (!content) {\n            content = textBox.textContent || \"\";\n        }\n        console.log('Extracted text content: \"'.concat(content, '\"'));\n        return content || \"Text Box\";\n    }\n    extractTextStyle(textBox) {\n        const defRPr = this.findElementByTagName(textBox, \"defRPr\");\n        if (defRPr) {\n            return {\n                fontFamily: defRPr.getAttribute(\"typeface\") || \"Arial\",\n                fontSize: parseInt(defRPr.getAttribute(\"sz\") || \"1800\") / 100,\n                fontWeight: defRPr.getAttribute(\"b\") === \"1\" ? \"bold\" : \"normal\",\n                fontStyle: defRPr.getAttribute(\"i\") === \"1\" ? \"italic\" : \"normal\",\n                textDecoration: defRPr.getAttribute(\"u\") === \"1\" ? \"underline\" : \"none\",\n                color: this.extractColor(defRPr),\n                textAlign: \"left\",\n                lineHeight: 1.2\n            };\n        }\n        return {\n            fontFamily: \"Arial\",\n            fontSize: 18,\n            fontWeight: \"normal\",\n            fontStyle: \"normal\",\n            textDecoration: \"none\",\n            color: \"#000000\",\n            textAlign: \"left\",\n            lineHeight: 1.2\n        };\n    }\n    extractColor(defRPr) {\n        const solidFill = this.findElementByTagName(defRPr, \"solidFill\");\n        if (solidFill) {\n            const srgbClr = this.findElementByTagName(solidFill, \"srgbClr\");\n            if (srgbClr) {\n                const val = srgbClr.getAttribute(\"val\");\n                if (val) {\n                    return \"#\".concat(val);\n                }\n            }\n        }\n        return \"#000000\";\n    }\n    determineShapeType(spPr) {\n        // Try to find prstGeom element with better namespace handling\n        let prstGeom = spPr.getElementsByTagName(\"prstGeom\")[0];\n        if (!prstGeom) {\n            prstGeom = spPr.getElementsByTagName(\"a:prstGeom\")[0];\n        }\n        if (prstGeom) {\n            const prst = prstGeom.getAttribute(\"prst\");\n            console.log(\"Found shape type: \".concat(prst));\n            switch(prst){\n                case \"rect\":\n                case \"roundRect\":\n                    return \"rectangle\";\n                case \"ellipse\":\n                case \"oval\":\n                    return \"ellipse\";\n                case \"line\":\n                case \"straightConnector1\":\n                    return \"line\";\n                default:\n                    console.log(\"Unknown shape type: \".concat(prst, \", defaulting to rectangle\"));\n                    return \"rectangle\";\n            }\n        }\n        // If no prstGeom found, try to determine from other properties\n        console.log(\"No prstGeom found, defaulting to rectangle\");\n        return \"rectangle\";\n    }\n    createDefaultSlide() {\n        return {\n            id: crypto.randomUUID(),\n            name: \"Slide 1\",\n            width: 960,\n            height: 540,\n            objects: [\n                {\n                    id: crypto.randomUUID(),\n                    type: \"text\",\n                    transform: {\n                        left: 100,\n                        top: 100,\n                        width: 300,\n                        height: 100,\n                        angle: 0,\n                        scaleX: 1,\n                        scaleY: 1,\n                        flipX: false,\n                        flipY: false\n                    },\n                    style: {\n                        fontFamily: \"Arial\",\n                        fontSize: 24,\n                        fontWeight: \"bold\",\n                        color: \"#000000\",\n                        textAlign: \"left\"\n                    },\n                    content: \"Welcome to PPTX Editor\"\n                }\n            ]\n        };\n    }\n    constructor(){\n        this.zip = null;\n    }\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL3NyYy91dGlscy9wcHR4UGFyc2VyLnRzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF5QjtBQUdsQixNQUFNQztJQUdYLE1BQU1DLFVBQVVDLElBQVUsRUFBeUI7UUFDakQsSUFBSTtZQUNGQyxRQUFRQyxHQUFHLENBQUM7WUFFWixvQkFBb0I7WUFDcEIsSUFBSSxDQUFDQyxHQUFHLEdBQUcsTUFBTU4sc0RBQWUsQ0FBQ0c7WUFDakNDLFFBQVFDLEdBQUcsQ0FBQztZQUVaLCtCQUErQjtZQUMvQixNQUFNRyxZQUFZQyxPQUFPQyxJQUFJLENBQUMsSUFBSSxDQUFDSixHQUFHLENBQUNLLEtBQUs7WUFDNUNQLFFBQVFDLEdBQUcsQ0FBQyxpQkFBaUJHO1lBRTdCLHFCQUFxQjtZQUNyQixNQUFNSSxTQUFTLE1BQU0sSUFBSSxDQUFDQyxVQUFVO1lBQ3BDLE1BQU1DLGFBQWEsTUFBTSxJQUFJLENBQUNDLHFCQUFxQjtZQUVuRFgsUUFBUUMsR0FBRyxDQUFDO1lBRVosT0FBTztnQkFDTFcsSUFBSUMsT0FBT0MsVUFBVTtnQkFDckJDLE1BQU1oQixLQUFLZ0IsSUFBSSxDQUFDQyxPQUFPLENBQUMsU0FBUztnQkFDakNSO2dCQUNBUyxVQUFVUDtZQUNaO1FBQ0YsRUFBRSxPQUFPUSxPQUFPO1lBQ2RsQixRQUFRa0IsS0FBSyxDQUFDLDRCQUE0QkE7WUFDMUMsTUFBTUE7UUFDUjtJQUNGO0lBRUEsTUFBY1Asd0JBQXNEO1FBQ2xFLElBQUk7Z0JBQ2dCO1lBQWxCLE1BQU1RLGFBQVksZ0JBQUksQ0FBQ2pCLEdBQUcsY0FBUiwwQ0FBVUgsSUFBSSxDQUFDO1lBQ2pDLElBQUlvQixXQUFXO2dCQUNiLE1BQU1DLFVBQVUsTUFBTUQsVUFBVUUsS0FBSyxDQUFDO2dCQUN0QyxNQUFNQyxTQUFTLElBQUlDO2dCQUNuQixNQUFNQyxNQUFNRixPQUFPRyxlQUFlLENBQUNMLFNBQVM7Z0JBRTVDLE1BQU1NLGdCQUFnQkYsSUFBSUcsYUFBYSxDQUFDO2dC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QU9DLFVBQVU7b0JBQ3JCb0UsTUFBTTtvQkFDTk0sV0FBVzt3QkFDVEMsTUFBTTt3QkFDTkMsS0FBSzt3QkFDTHpCLE9BQU87d0JBQ1BFLFFBQVE7d0JBQ1J3QixPQUFPO3dCQUNQQyxRQUFRO3dCQUNSQyxRQUFRO3dCQUNSQyxPQUFPO3dCQUNQQyxPQUFPO29CQUNUO29CQUNBQyxPQUFPO3dCQUNMQyxZQUFZO3dCQUNaQyxVQUFVO3dCQUNWQyxZQUFZO3dCQUNaRyxPQUFPO3dCQUNQQyxXQUFXO29CQUNiO29CQUNBbkYsU0FBUztnQkFDWDthQUNEO1FBQ0g7SUFDRjs7YUFqeUJRbEIsTUFBb0I7O0FBa3lCOUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vc3JjL3V0aWxzL3BwdHhQYXJzZXIudHM/ZTE4ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgSlNaaXAgZnJvbSAnanN6aXAnXHJcbmltcG9ydCB7IFBQVFhEb2N1bWVudCwgU2xpZGUsIFNoYXBlT2JqZWN0LCBUcmFuc2Zvcm0sIFRleHRTdHlsZSB9IGZyb20gJ0AvdHlwZXMvcHB0eCdcclxuXHJcbmV4cG9ydCBjbGFzcyBQUFRYUGFyc2VyIHtcclxuICBwcml2YXRlIHppcDogSlNaaXAgfCBudWxsID0gbnVsbFxyXG5cclxuICBhc3luYyBwYXJzZUZpbGUoZmlsZTogRmlsZSk6IFByb21pc2U8UFBUWERvY3VtZW50PiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygnU3RhcnRpbmcgUFBUWCBwYXJzaW5nLi4uJylcclxuICAgICAgXHJcbiAgICAgIC8vIExvYWQgdGhlIFpJUCBmaWxlXHJcbiAgICAgIHRoaXMuemlwID0gYXdhaXQgSlNaaXAubG9hZEFzeW5jKGZpbGUpXHJcbiAgICAgIGNvbnNvbGUubG9nKCdaSVAgZmlsZSBsb2FkZWQgc3VjY2Vzc2Z1bGx5JylcclxuICAgICAgXHJcbiAgICAgIC8vIExpc3QgYWxsIGZpbGVzIGZvciBkZWJ1Z2dpbmdcclxuICAgICAgY29uc3QgZmlsZU5hbWVzID0gT2JqZWN0LmtleXModGhpcy56aXAuZmlsZXMpXHJcbiAgICAgIGNvbnNvbGUubG9nKCdGaWxlcyBpbiBaSVA6JywgZmlsZU5hbWVzKVxyXG4gICAgICBcclxuICAgICAgLy8gUGFyc2UgdGhlIGRvY3VtZW50XHJcbiAgICAgIGNvbnN0IHNsaWRlcyA9IGF3YWl0IHRoaXMucmVhZFNsaWRlcygpXHJcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhd2FpdCB0aGlzLnJlYWRQcmVzZW50YXRpb25Qcm9wcygpXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnUGFyc2luZyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5JylcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgICAgICAgbmFtZTogZmlsZS5uYW1lLnJlcGxhY2UoJy5wcHR4JywgJycpLFxyXG4gICAgICAgIHNsaWRlcyxcclxuICAgICAgICBtZXRhZGF0YTogcHJvcGVydGllcyxcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBQUFRYIGZpbGU6JywgZXJyb3IpXHJcbiAgICAgIHRocm93IGVycm9yXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHJlYWRQcmVzZW50YXRpb25Qcm9wcygpOiBQcm9taXNlPHsgYXV0aG9yPzogc3RyaW5nIH0+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNvcmVQcm9wcyA9IHRoaXMuemlwPy5maWxlKCdkb2NQcm9wcy9jb3JlLnhtbCcpXHJcbiAgICAgIGlmIChjb3JlUHJvcHMpIHtcclxuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgY29yZVByb3BzLmFzeW5jKCd0ZXh0JylcclxuICAgICAgICBjb25zdCBwYXJzZXIgPSBuZXcgRE9NUGFyc2VyKClcclxuICAgICAgICBjb25zdCB4bWwgPSBwYXJzZXIucGFyc2VGcm9tU3RyaW5nKGNvbnRlbnQsICd0ZXh0L3htbCcpXHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc3QgYXV0aG9yRWxlbWVudCA9IHhtbC5xdWVyeVNlbGVjdG9yKCdkY1xcXFw6Y3JlYXRvciwgY3JlYXRvcicpXHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgIGF1dGhvcjogYXV0aG9yRWxlbWVudD8udGV4dENvbnRlbnQgfHwgdW5kZWZpbmVkXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLndhcm4oJ0NvdWxkIG5vdCByZWFkIHByZXNlbnRhdGlvbiBwcm9wZXJ0aWVzOicsIGVycm9yKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4ge31cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmVhZFNsaWRlcygpOiBQcm9taXNlPFNsaWRlW10+IHtcclxuICAgIGNvbnN0IHNsaWRlczogU2xpZGVbXSA9IFtdXHJcbiAgICBcclxuICAgIHRyeSB7XHJcbiAgICAgIC8vIEdldCBzbGlkZSBjb3VudCBmcm9tIHByZXNlbnRhdGlvbi54bWxcclxuICAgICAgY29uc3QgcHJlc2VudGF0aW9uID0gdGhpcy56aXA/LmZpbGUoJ3BwdC9wcmVzZW50YXRpb24ueG1sJylcclxuICAgICAgaWYgKHByZXNlbnRhdGlvbikge1xyXG4gICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCBwcmVzZW50YXRpb24uYXN5bmMoJ3RleHQnKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKCdQcmVzZW50YXRpb24gWE1MIGNvbnRlbnQ6JywgY29udGVudC5zdWJzdHJpbmcoMCwgNTAwKSArICcuLi4nKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBET01QYXJzZXIoKVxyXG4gICAgICAgIGNvbnN0IHhtbCA9IHBhcnNlci5wYXJzZUZyb21TdHJpbmcoY29udGVudCwgJ3RleHQveG1sJylcclxuICAgICAgICBcclxuICAgICAgICAvLyBUcnkgbXVsdGlwbGUgYXBwcm9hY2hlcyB0byBmaW5kIHNsaWRlc1xyXG4gICAgICAgIGxldCBzbGlkZUlkcyA9IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2xkSWQnKVxyXG4gICAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCAke3NsaWRlSWRzLmxlbmd0aH0gc2xpZGVzIHVzaW5nICdzbGRJZCcgdGFnYClcclxuICAgICAgICBcclxuICAgICAgICAvLyBJZiBubyBzbGlkZXMgZm91bmQsIHRyeSBhbHRlcm5hdGl2ZSBhcHByb2FjaGVzXHJcbiAgICAgICAgaWYgKHNsaWRlSWRzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgICAgLy8gVHJ5IGxvb2tpbmcgZm9yIHNsaWRlcyBpbiB0aGUgc2xpZGVzIGZvbGRlciBkaXJlY3RseVxyXG4gICAgICAgICAgY29uc3Qgc2xpZGVGaWxlcyA9IE9iamVjdC5rZXlzKHRoaXMuemlwPy5maWxlcyB8fCB7fSlcclxuICAgICAgICAgICAgLmZpbHRlcihuYW1lID0+IG5hbWUuc3RhcnRzV2l0aCgncHB0L3NsaWRlcy9zbGlkZScpICYmIG5hbWUuZW5kc1dpdGgoJy54bWwnKSlcclxuICAgICAgICAgICAgLnNvcnQoKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zb2xlLmxvZygnRm91bmQgc2xpZGUgZmlsZXMgZGlyZWN0bHk6Jywgc2xpZGVGaWxlcylcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKHNsaWRlRmlsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICAvLyBDcmVhdGUgc2xpZGVzIGZyb20gdGhlIGZpbGVzIHdlIGZvdW5kXHJcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xpZGVGaWxlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IHNsaWRlRmlsZSA9IHNsaWRlRmlsZXNbaV1cclxuICAgICAgICAgICAgICBjb25zdCBzbGlkZU51bWJlciA9IGkgKyAxXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYFByb2Nlc3Npbmcgc2xpZGUgZmlsZTogJHtzbGlkZUZpbGV9YClcclxuICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICBjb25zdCBzbGlkZSA9IGF3YWl0IHRoaXMucmVhZFNsaWRlRnJvbUZpbGUoc2xpZGVGaWxlLCBzbGlkZU51bWJlcilcclxuICAgICAgICAgICAgICBpZiAoc2xpZGUpIHtcclxuICAgICAgICAgICAgICAgIHNsaWRlcy5wdXNoKHNsaWRlKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBsb2FkZWQgc2xpZGUgJHtzbGlkZU51bWJlcn0gZnJvbSBmaWxlYClcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgLy8gUHJvY2VzcyBzbGlkZXMgdXNpbmcgdGhlIHRyYWRpdGlvbmFsIG1ldGhvZFxyXG4gICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzbGlkZUlkcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjb25zdCBzbGlkZUlkID0gc2xpZGVJZHNbaV0uZ2V0QXR0cmlidXRlKCdyOmlkJylcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFByb2Nlc3Npbmcgc2xpZGUgJHtpICsgMX0gd2l0aCBJRDogJHtzbGlkZUlkfWApXHJcbiAgICAgICAgICAgIGlmIChzbGlkZUlkKSB7XHJcbiAgICAgICAgICAgICAgY29uc3Qgc2xpZGUgPSBhd2FpdCB0aGlzLnJlYWRTbGlkZShzbGlkZUlkLCBpICsgMSlcclxuICAgICAgICAgICAgICBpZiAoc2xpZGUpIHtcclxuICAgICAgICAgICAgICAgIHNsaWRlcy5wdXNoKHNsaWRlKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBsb2FkZWQgc2xpZGUgJHtpICsgMX1gKVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBsb2FkIHNsaWRlICR7aSArIDF9YClcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdDb3VsZCBub3QgZmluZCBwcmVzZW50YXRpb24ueG1sJylcclxuICAgICAgfVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVhZGluZyBzbGlkZXM6JywgZXJyb3IpXHJcbiAgICAgIC8vIENyZWF0ZSBhIGRlZmF1bHQgc2xpZGUgaWYgcGFyc2luZyBmYWlsc1xyXG4gICAgICBzbGlkZXMucHVzaCh0aGlzLmNyZWF0ZURlZmF1bHRTbGlkZSgpKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhgVG90YWwgc2xpZGVzIGxvYWRlZDogJHtzbGlkZXMubGVuZ3RofWApXHJcbiAgICByZXR1cm4gc2xpZGVzLmxlbmd0aCA+IDAgPyBzbGlkZXMgOiBbdGhpcy5jcmVhdGVEZWZhdWx0U2xpZGUoKV1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgcmVhZFNsaWRlKHNsaWRlSWQ6IHN0cmluZywgc2xpZGVOdW1iZXI6IG51bWJlcik6IFByb21pc2U8U2xpZGUgfCBudWxsPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBUcnkgdG8gZmluZCB0aGUgc2xpZGUgZmlsZSBkaXJlY3RseSBmaXJzdFxyXG4gICAgICBsZXQgc2xpZGVGaWxlID0gdGhpcy56aXA/LmZpbGUoYHBwdC9zbGlkZXMvc2xpZGUke3NsaWRlTnVtYmVyfS54bWxgKVxyXG4gICAgICBcclxuICAgICAgLy8gSWYgbm90IGZvdW5kLCB0cnkgdG8gZmluZCBpdCB0aHJvdWdoIHJlbGF0aW9uc2hpcHNcclxuICAgICAgaWYgKCFzbGlkZUZpbGUpIHtcclxuICAgICAgICBjb25zdCBzbGlkZVJlbCA9IHRoaXMuemlwPy5maWxlKGBwcHQvc2xpZGVzL19yZWxzL3NsaWRlJHtzbGlkZU51bWJlcn0ueG1sLnJlbHNgKVxyXG4gICAgICAgIGlmIChzbGlkZVJlbCkge1xyXG4gICAgICAgICAgY29uc3QgcmVsQ29udGVudCA9IGF3YWl0IHNsaWRlUmVsLmFzeW5jKCd0ZXh0JylcclxuICAgICAgICAgIGNvbnN0IHJlbFBhcnNlciA9IG5ldyBET01QYXJzZXIoKVxyXG4gICAgICAgICAgY29uc3QgcmVsWG1sID0gcmVsUGFyc2VyLnBhcnNlRnJvbVN0cmluZyhyZWxDb250ZW50LCAndGV4dC94bWwnKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBjb25zdCBzbGlkZVRhcmdldCA9IHJlbFhtbC5xdWVyeVNlbGVjdG9yKGBSZWxhdGlvbnNoaXBbSWQ9XCIke3NsaWRlSWR9XCJdYCk/LmdldEF0dHJpYnV0ZSgnVGFyZ2V0JylcclxuICAgICAgICAgIGlmIChzbGlkZVRhcmdldCkge1xyXG4gICAgICAgICAgICBjb25zdCBzbGlkZVBhdGggPSBgcHB0L3NsaWRlcy8ke3NsaWRlVGFyZ2V0LnNwbGl0KCcvJykucG9wKCl9YFxyXG4gICAgICAgICAgICBzbGlkZUZpbGUgPSB0aGlzLnppcD8uZmlsZShzbGlkZVBhdGgpXHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBJZiBzdGlsbCBub3QgZm91bmQsIHRyeSB0byBmaW5kIGFueSBzbGlkZSBmaWxlXHJcbiAgICAgIGlmICghc2xpZGVGaWxlKSB7XHJcbiAgICAgICAgY29uc3Qgc2xpZGVGaWxlcyA9IE9iamVjdC5rZXlzKHRoaXMuemlwPy5maWxlcyB8fCB7fSlcclxuICAgICAgICAgIC5maWx0ZXIobmFtZSA9PiBuYW1lLnN0YXJ0c1dpdGgoJ3BwdC9zbGlkZXMvc2xpZGUnKSAmJiBuYW1lLmVuZHNXaXRoKCcueG1sJykpXHJcbiAgICAgICAgICAuc29ydCgpXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHNsaWRlRmlsZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc3QgdGFyZ2V0U2xpZGUgPSBzbGlkZUZpbGVzW3NsaWRlTnVtYmVyIC0gMV0gfHwgc2xpZGVGaWxlc1swXVxyXG4gICAgICAgICAgc2xpZGVGaWxlID0gdGhpcy56aXA/LmZpbGUodGFyZ2V0U2xpZGUpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXNsaWRlRmlsZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgc2xpZGUgZmlsZSBmb3Igc2xpZGUgJHtzbGlkZU51bWJlcn1gKVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHNsaWRlQ29udGVudCA9IGF3YWl0IHNsaWRlRmlsZS5hc3luYygndGV4dCcpXHJcbiAgICAgIGNvbnN0IHNsaWRlUGFyc2VyID0gbmV3IERPTVBhcnNlcigpXHJcbiAgICAgIGNvbnN0IHNsaWRlWG1sID0gc2xpZGVQYXJzZXIucGFyc2VGcm9tU3RyaW5nKHNsaWRlQ29udGVudCwgJ3RleHQveG1sJylcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3Qgc2xpZGUgZGltZW5zaW9uc1xyXG4gICAgICBjb25zdCBzbGRTeiA9IHNsaWRlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzbGRTeicpWzBdXHJcbiAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQoc2xkU3o/LmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAnOTE0NDAwMCcpIC8gMTI3MDAgLy8gQ29udmVydCBFTVVzIHRvIHBpeGVsc1xyXG4gICAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUludChzbGRTej8uZ2V0QXR0cmlidXRlKCdjeScpIHx8ICc2ODU4MDAwJykgLyAxMjcwMFxyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBzaGFwZXNcclxuICAgICAgY29uc3Qgb2JqZWN0cyA9IGF3YWl0IHRoaXMuZXh0cmFjdFNoYXBlcyhzbGlkZVhtbCwgc2xpZGVOdW1iZXIpXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gICAgICAgIG5hbWU6IGBTbGlkZSAke3NsaWRlTnVtYmVyfWAsXHJcbiAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgIG9iamVjdHMsXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlYWRpbmcgc2xpZGUgJHtzbGlkZU51bWJlcn06YCwgZXJyb3IpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHJlYWRTbGlkZUZyb21GaWxlKHNsaWRlRmlsZVBhdGg6IHN0cmluZywgc2xpZGVOdW1iZXI6IG51bWJlcik6IFByb21pc2U8U2xpZGUgfCBudWxsPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzbGlkZUZpbGUgPSB0aGlzLnppcD8uZmlsZShzbGlkZUZpbGVQYXRoKVxyXG4gICAgICBpZiAoIXNsaWRlRmlsZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgQ291bGQgbm90IGZpbmQgc2xpZGUgZmlsZTogJHtzbGlkZUZpbGVQYXRofWApXHJcbiAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3Qgc2xpZGVDb250ZW50ID0gYXdhaXQgc2xpZGVGaWxlLmFzeW5jKCd0ZXh0JylcclxuICAgICAgY29uc29sZS5sb2coYFNsaWRlICR7c2xpZGVOdW1iZXJ9IFhNTCBjb250ZW50OmAsIHNsaWRlQ29udGVudC5zdWJzdHJpbmcoMCwgMTAwMCkgKyAnLi4uJylcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHNsaWRlUGFyc2VyID0gbmV3IERPTVBhcnNlcigpXHJcbiAgICAgIGNvbnN0IHNsaWRlWG1sID0gc2xpZGVQYXJzZXIucGFyc2VGcm9tU3RyaW5nKHNsaWRlQ29udGVudCwgJ3RleHQveG1sJylcclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3Qgc2xpZGUgZGltZW5zaW9uc1xyXG4gICAgICBjb25zdCBzbGRTeiA9IHNsaWRlWG1sLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdzbGRTeicpWzBdXHJcbiAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQoc2xkU3o/LmdldEF0dHJpYnV0ZSgnY3gnKSB8fCAnOTE0NDAwMCcpIC8gMTI3MDAgLy8gQ29udmVydCBFTVVzIHRvIHBpeGVsc1xyXG4gICAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUludChzbGRTej8uZ2V0QXR0cmlidXRlKCdjeScpIHx8ICc2ODU4MDAwJykgLyAxMjcwMFxyXG4gICAgICBcclxuICAgICAgLy8gRXh0cmFjdCBzaGFwZXNcclxuICAgICAgY29uc3Qgb2JqZWN0cyA9IGF3YWl0IHRoaXMuZXh0cmFjdFNoYXBlcyhzbGlkZVhtbCwgc2xpZGVOdW1iZXIpXHJcbiAgICAgIFxyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gICAgICAgIG5hbWU6IGBTbGlkZSAke3NsaWRlTnVtYmVyfWAsXHJcbiAgICAgICAgd2lkdGgsXHJcbiAgICAgICAgaGVpZ2h0LFxyXG4gICAgICAgIG9iamVjdHMsXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHJlYWRpbmcgc2xpZGUgZnJvbSBmaWxlICR7c2xpZGVGaWxlUGF0aH06YCwgZXJyb3IpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGV4dHJhY3RTaGFwZXMoc2xpZGVYbWw6IERvY3VtZW50LCBzbGlkZU51bWJlcjogbnVtYmVyKTogUHJvbWlzZTxTaGFwZU9iamVjdFtdPiB7XHJcbiAgICBjb25zdCBvYmplY3RzOiBTaGFwZU9iamVjdFtdID0gW11cclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coYEV4dHJhY3Rpbmcgc2hhcGVzIGZyb20gc2xpZGUgJHtzbGlkZU51bWJlcn1gKVxyXG4gICAgICBcclxuICAgICAgLy8gVHJ5IG11bHRpcGxlIGFwcHJvYWNoZXMgdG8gZmluZCBzaGFwZXNcclxuICAgICAgXHJcbiAgICAgIC8vIEFwcHJvYWNoIDE6IExvb2sgZm9yIHNwVHJlZSA+IHNwICh0cmFkaXRpb25hbCBzdHJ1Y3R1cmUpXHJcbiAgICAgIC8vIFVzZSBhIG1vcmUgcm9idXN0IGFwcHJvYWNoIHRvIGhhbmRsZSBuYW1lc3BhY2VzXHJcbiAgICAgIGxldCBzcFRyZWUgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHNsaWRlWG1sLCAnc3BUcmVlJylcclxuICAgICAgaWYgKHNwVHJlZSkge1xyXG4gICAgICAgIGNvbnN0IHRleHRCb3hlcyA9IHRoaXMuZmluZEVsZW1lbnRzQnlUYWdOYW1lKHNwVHJlZSwgJ3NwJylcclxuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHt0ZXh0Qm94ZXMubGVuZ3RofSBzaGFwZSBlbGVtZW50cyBpbiBzcFRyZWVgKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dEJveGVzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCB0ZXh0Qm94ID0gdGV4dEJveGVzW2ldXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgUHJvY2Vzc2luZyBzaGFwZSAke2kgKyAxfTpgLCB0ZXh0Qm94LnRhZ05hbWUsIHRleHRCb3guZ2V0QXR0cmlidXRlKCdpZCcpLCB0ZXh0Qm94LmdldEF0dHJpYnV0ZSgnbmFtZScpKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcGxhY2Vob2xkZXJcclxuICAgICAgICAgIGNvbnN0IG52UHIgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHRleHRCb3gsICdudlByJylcclxuICAgICAgICAgIGNvbnN0IHBoID0gbnZQciA/IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUobnZQciwgJ3BoJykgOiBudWxsXHJcbiAgICAgICAgICBpZiAocGgpIHtcclxuICAgICAgICAgICAgY29uc3QgcGhUeXBlID0gcGguZ2V0QXR0cmlidXRlKCd0eXBlJylcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFNoYXBlICR7aSArIDF9IGlzIGEgcGxhY2Vob2xkZXIgb2YgdHlwZTogJHtwaFR5cGV9YClcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmV4dHJhY3RUZXh0Qm94KHRleHRCb3gsIHNsaWRlTnVtYmVyLCBpKVxyXG4gICAgICAgICAgaWYgKHNoYXBlKSB7XHJcbiAgICAgICAgICAgIG9iamVjdHMucHVzaChzaGFwZSlcclxuICAgICAgICAgICAgY29uc29sZS5sb2coYFN1Y2Nlc3NmdWxseSBleHRyYWN0ZWQgc2hhcGUgJHtpICsgMX06YCwgc2hhcGUudHlwZSwgc2hhcGUuY29udGVudCB8fCAnbm8gY29udGVudCcpXHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEZhaWxlZCB0byBleHRyYWN0IHNoYXBlICR7aSArIDF9YClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdObyBzcFRyZWUgZm91bmQgaW4gc2xpZGUnKVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBBcHByb2FjaCAyOiBMb29rIGZvciBzaGFwZXMgZGlyZWN0bHkgaW4gdGhlIHNsaWRlXHJcbiAgICAgIGlmIChvYmplY3RzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCdUcnlpbmcgYWx0ZXJuYXRpdmUgc2hhcGUgZXh0cmFjdGlvbi4uLicpXHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gTG9vayBmb3IgYW55IHNwIGVsZW1lbnRzIGFueXdoZXJlIGluIHRoZSBzbGlkZVxyXG4gICAgICAgIGNvbnN0IGFsbFNwRWxlbWVudHMgPSB0aGlzLmZpbmRFbGVtZW50c0J5VGFnTmFtZShzbGlkZVhtbCwgJ3NwJylcclxuICAgICAgICBjb25zb2xlLmxvZyhgRm91bmQgJHthbGxTcEVsZW1lbnRzLmxlbmd0aH0gc3AgZWxlbWVudHMgaW4gc2xpZGVgKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsU3BFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgY29uc3Qgc3BFbGVtZW50ID0gYWxsU3BFbGVtZW50c1tpXVxyXG4gICAgICAgICAgY29uc29sZS5sb2coYFByb2Nlc3Npbmcgc3AgZWxlbWVudCAke2kgKyAxfTpgLCBzcEVsZW1lbnQudGFnTmFtZSwgc3BFbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKSlcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmV4dHJhY3RUZXh0Qm94KHNwRWxlbWVudCwgc2xpZGVOdW1iZXIsIGkpXHJcbiAgICAgICAgICBpZiAoc2hhcGUpIHtcclxuICAgICAgICAgICAgb2JqZWN0cy5wdXNoKHNoYXBlKVxyXG4gICAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGV4dHJhY3RlZCBzcCBlbGVtZW50ICR7aSArIDF9OmAsIHNoYXBlLnR5cGUsIHNoYXBlLmNvbnRlbnQgfHwgJ25vIGNvbnRlbnQnKVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQXBwcm9hY2ggMzogTG9vayBmb3IgdGV4dCBlbGVtZW50cyBkaXJlY3RseVxyXG4gICAgICBpZiAob2JqZWN0cy5sZW5ndGggPT09IDApIHtcclxuICAgICAgICBjb25zb2xlLmxvZygnVHJ5aW5nIGRpcmVjdCB0ZXh0IGV4dHJhY3Rpb24uLi4nKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGNvbnN0IHRleHRFbGVtZW50cyA9IHRoaXMuZmluZEVsZW1lbnRzQnlUYWdOYW1lKHNsaWRlWG1sLCAndCcpXHJcbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7dGV4dEVsZW1lbnRzLmxlbmd0aH0gdGV4dCBlbGVtZW50cyBkaXJlY3RseSBpbiBzbGlkZWApXHJcbiAgICAgICAgXHJcbiAgICAgICAgaWYgKHRleHRFbGVtZW50cy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAvLyBDcmVhdGUgYSBzaW1wbGUgdGV4dCBvYmplY3QgZnJvbSB0aGUgZmlyc3QgdGV4dCBlbGVtZW50XHJcbiAgICAgICAgICBjb25zdCBmaXJzdFRleHQgPSB0ZXh0RWxlbWVudHNbMF1cclxuICAgICAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gZmlyc3RUZXh0LnRleHRDb250ZW50IHx8ICdUZXh0J1xyXG4gICAgICAgICAgY29uc29sZS5sb2coYENyZWF0aW5nIHRleHQgb2JqZWN0IHdpdGggY29udGVudDogXCIke3RleHRDb250ZW50fVwiYClcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgY29uc3QgdGV4dE9iamVjdDogU2hhcGVPYmplY3QgPSB7XHJcbiAgICAgICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gICAgICAgICAgICB0eXBlOiAndGV4dCcsXHJcbiAgICAgICAgICAgIHRyYW5zZm9ybToge1xyXG4gICAgICAgICAgICAgIGxlZnQ6IDEwMCxcclxuICAgICAgICAgICAgICB0b3A6IDEwMCxcclxuICAgICAgICAgICAgICB3aWR0aDogMzAwLFxyXG4gICAgICAgICAgICAgIGhlaWdodDogMTAwLFxyXG4gICAgICAgICAgICAgIGFuZ2xlOiAwLFxyXG4gICAgICAgICAgICAgIHNjYWxlWDogMSxcclxuICAgICAgICAgICAgICBzY2FsZVk6IDEsXHJcbiAgICAgICAgICAgICAgZmxpcFg6IGZhbHNlLFxyXG4gICAgICAgICAgICAgIGZsaXBZOiBmYWxzZSxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgc3R5bGU6IHtcclxuICAgICAgICAgICAgICBmb250RmFtaWx5OiAnQXJpYWwnLFxyXG4gICAgICAgICAgICAgIGZvbnRTaXplOiAxOCxcclxuICAgICAgICAgICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcclxuICAgICAgICAgICAgICBmb250U3R5bGU6ICdub3JtYWwnLFxyXG4gICAgICAgICAgICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgY29sb3I6ICcjMDAwMDAwJyxcclxuICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcclxuICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAxLjIsXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBvYmplY3RzLnB1c2godGV4dE9iamVjdClcclxuICAgICAgICAgIGNvbnNvbGUubG9nKCdDcmVhdGVkIGZhbGxiYWNrIHRleHQgb2JqZWN0JylcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgaW1hZ2VzXHJcbiAgICAgIGNvbnN0IGltYWdlcyA9IHRoaXMuZmluZEVsZW1lbnRzQnlUYWdOYW1lKHNsaWRlWG1sLCAncGljJylcclxuICAgICAgY29uc29sZS5sb2coYEZvdW5kICR7aW1hZ2VzLmxlbmd0aH0gaW1hZ2UgZWxlbWVudHNgKVxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGltYWdlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGltYWdlID0gaW1hZ2VzW2ldXHJcbiAgICAgICAgY29uc3Qgc2hhcGUgPSB0aGlzLmV4dHJhY3RJbWFnZShpbWFnZSwgc2xpZGVOdW1iZXIsIGkpXHJcbiAgICAgICAgaWYgKHNoYXBlKSB7XHJcbiAgICAgICAgICBvYmplY3RzLnB1c2goc2hhcGUpXHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgU3VjY2Vzc2Z1bGx5IGV4dHJhY3RlZCBpbWFnZSAke2kgKyAxfWApXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhgVG90YWwgb2JqZWN0cyBleHRyYWN0ZWQ6ICR7b2JqZWN0cy5sZW5ndGh9YClcclxuICAgICAgY29uc29sZS5sb2coJ0ZpbmFsIG9iamVjdHM6Jywgb2JqZWN0cy5tYXAob2JqID0+ICh7IHR5cGU6IG9iai50eXBlLCBjb250ZW50OiBvYmouY29udGVudCwgdHJhbnNmb3JtOiBvYmoudHJhbnNmb3JtIH0pKSlcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGV4dHJhY3Rpbmcgc2hhcGVzOicsIGVycm9yKVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICByZXR1cm4gb2JqZWN0c1xyXG4gIH1cclxuXHJcbiAgLy8gSGVscGVyIG1ldGhvZHMgdG8gaGFuZGxlIFhNTCBuYW1lc3BhY2VzXHJcbiAgcHJpdmF0ZSBmaW5kRWxlbWVudEJ5VGFnTmFtZShwYXJlbnQ6IEVsZW1lbnQgfCBEb2N1bWVudCwgdGFnTmFtZTogc3RyaW5nKTogRWxlbWVudCB8IG51bGwge1xyXG4gICAgLy8gVHJ5IG11bHRpcGxlIGFwcHJvYWNoZXMgdG8gZmluZCB0aGUgZWxlbWVudFxyXG4gICAgbGV0IGVsZW1lbnQgPSBwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSlbMF1cclxuICAgIGlmIChlbGVtZW50KSByZXR1cm4gZWxlbWVudFxyXG4gICAgXHJcbiAgICAvLyBJZiBub3QgZm91bmQsIHRyeSB3aXRoIGNvbW1vbiBuYW1lc3BhY2UgcHJlZml4ZXNcclxuICAgIGNvbnN0IHByZWZpeGVzID0gWydwOicsICdhOicsICdyOicsICcnXVxyXG4gICAgZm9yIChjb25zdCBwcmVmaXggb2YgcHJlZml4ZXMpIHtcclxuICAgICAgY29uc3QgZnVsbFRhZ05hbWUgPSBwcmVmaXggKyB0YWdOYW1lXHJcbiAgICAgIGVsZW1lbnQgPSBwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoZnVsbFRhZ05hbWUpWzBdXHJcbiAgICAgIGlmIChlbGVtZW50KSByZXR1cm4gZWxlbWVudFxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBMYXN0IHJlc29ydDogc2VhcmNoIGJ5IHBhcnRpYWwgdGFnIG5hbWVcclxuICAgIGNvbnN0IGFsbEVsZW1lbnRzID0gcGFyZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJylcclxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYWxsRWxlbWVudHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgY29uc3QgZWwgPSBhbGxFbGVtZW50c1tpXVxyXG4gICAgICBpZiAoZWwudGFnTmFtZS5lbmRzV2l0aCh0YWdOYW1lKSB8fCBlbC50YWdOYW1lLmluY2x1ZGVzKHRhZ05hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuIGVsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG51bGxcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZmluZEVsZW1lbnRzQnlUYWdOYW1lKHBhcmVudDogRWxlbWVudCB8IERvY3VtZW50LCB0YWdOYW1lOiBzdHJpbmcpOiBFbGVtZW50W10ge1xyXG4gICAgLy8gVHJ5IG11bHRpcGxlIGFwcHJvYWNoZXMgdG8gZmluZCBlbGVtZW50c1xyXG4gICAgbGV0IGVsZW1lbnRzID0gQXJyYXkuZnJvbShwYXJlbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUodGFnTmFtZSkpXHJcbiAgICBpZiAoZWxlbWVudHMubGVuZ3RoID4gMCkgcmV0dXJuIGVsZW1lbnRzXHJcbiAgICBcclxuICAgIC8vIElmIG5vdCBmb3VuZCwgdHJ5IHdpdGggY29tbW9uIG5hbWVzcGFjZSBwcmVmaXhlc1xyXG4gICAgY29uc3QgcHJlZml4ZXMgPSBbJ3A6JywgJ2E6JywgJ3I6JywgJyddXHJcbiAgICBmb3IgKGNvbnN0IHByZWZpeCBvZiBwcmVmaXhlcykge1xyXG4gICAgICBjb25zdCBmdWxsVGFnTmFtZSA9IHByZWZpeCArIHRhZ05hbWVcclxuICAgICAgZWxlbWVudHMgPSBBcnJheS5mcm9tKHBhcmVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShmdWxsVGFnTmFtZSkpXHJcbiAgICAgIGlmIChlbGVtZW50cy5sZW5ndGggPiAwKSByZXR1cm4gZWxlbWVudHNcclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gTGFzdCByZXNvcnQ6IHNlYXJjaCBieSBwYXJ0aWFsIHRhZyBuYW1lXHJcbiAgICBjb25zdCBhbGxFbGVtZW50cyA9IHBhcmVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnKicpXHJcbiAgICBjb25zdCBtYXRjaGluZ0VsZW1lbnRzOiBFbGVtZW50W10gPSBbXVxyXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICBjb25zdCBlbCA9IGFsbEVsZW1lbnRzW2ldXHJcbiAgICAgIGlmIChlbC50YWdOYW1lLmVuZHNXaXRoKHRhZ05hbWUpIHx8IGVsLnRhZ05hbWUuaW5jbHVkZXModGFnTmFtZSkpIHtcclxuICAgICAgICBtYXRjaGluZ0VsZW1lbnRzLnB1c2goZWwpXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIG1hdGNoaW5nRWxlbWVudHNcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZXh0cmFjdFRleHRCb3godGV4dEJveDogRWxlbWVudCwgc2xpZGVOdW1iZXI6IG51bWJlciwgaW5kZXg6IG51bWJlcik6IFNoYXBlT2JqZWN0IHwgbnVsbCB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGluZyB0ZXh0IGJveCAke2luZGV4ICsgMX0gZnJvbSBzbGlkZSAke3NsaWRlTnVtYmVyfWApXHJcbiAgICAgIGNvbnNvbGUubG9nKCdUZXh0IGJveCBlbGVtZW50OicsIHRleHRCb3gub3V0ZXJIVE1MLnN1YnN0cmluZygwLCA1MDApICsgJy4uLicpXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzcFByID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZSh0ZXh0Qm94LCAnc3BQcicpXHJcbiAgICAgIGlmICghc3BQcikge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgTm8gc3BQciBmb3VuZCBpbiB0ZXh0IGJveCAke2luZGV4ICsgMX1gKVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYWN0dWFsbHkgYSB0ZXh0IHNoYXBlIG9yIGEgZGlmZmVyZW50IHR5cGVcclxuICAgICAgY29uc3QgdHhCb2R5ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZSh0ZXh0Qm94LCAndHhCb2R5JylcclxuICAgICAgY29uc3QgaGFzVGV4dCA9IHR4Qm9keSAmJiB0aGlzLmZpbmRFbGVtZW50c0J5VGFnTmFtZSh0eEJvZHksICd0JykubGVuZ3RoID4gMFxyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgdGhpcyBpcyBhIHBsYWNlaG9sZGVyIG9yIHNoYXBlIHdpdGggdGV4dFxyXG4gICAgICBjb25zdCBudlByID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZSh0ZXh0Qm94LCAnbnZQcicpXHJcbiAgICAgIGNvbnN0IHBoID0gbnZQciA/IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUobnZQciwgJ3BoJykgOiBudWxsXHJcbiAgICAgIGNvbnN0IGlzUGxhY2Vob2xkZXIgPSBwaCAmJiBwaC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKVxyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgdGhlIGFjdHVhbCBzaGFwZSB0eXBlIGZyb20gc3BQclxyXG4gICAgICBjb25zdCBwcnN0R2VvbSA9IHNwUHIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3Byc3RHZW9tJylbMF0gfHwgc3BQci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYTpwcnN0R2VvbScpWzBdXHJcbiAgICAgIGNvbnN0IHNoYXBlVHlwZSA9IHByc3RHZW9tPy5nZXRBdHRyaWJ1dGUoJ3Byc3QnKVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYFNoYXBlICR7aW5kZXggKyAxfSAtIGhhc1RleHQ6ICR7aGFzVGV4dH0sIGlzUGxhY2Vob2xkZXI6ICR7aXNQbGFjZWhvbGRlcn0sIHNoYXBlVHlwZTogJHtzaGFwZVR5cGV9YClcclxuICAgICAgXHJcbiAgICAgIC8vIElmIHRoaXMgaXMgYSByZWN0YW5nbGUsIGVsbGlwc2UsIG9yIG90aGVyIHNoYXBlIChub3QgdGV4dCksIGV4dHJhY3QgYXMgYmFzaWMgc2hhcGVcclxuICAgICAgaWYgKHNoYXBlVHlwZSAmJiBbJ3JlY3QnLCAncm91bmRSZWN0JywgJ2VsbGlwc2UnLCAnb3ZhbCcsICdsaW5lJ10uaW5jbHVkZXMoc2hhcGVUeXBlKSkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKGBTaGFwZSAke2luZGV4ICsgMX0gaXMgYSAke3NoYXBlVHlwZX0sIHRyZWF0aW5nIGFzIGJhc2ljIHNoYXBlYClcclxuICAgICAgICByZXR1cm4gdGhpcy5leHRyYWN0QmFzaWNTaGFwZSh0ZXh0Qm94LCBzbGlkZU51bWJlciwgaW5kZXgpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIElmIHRoaXMgaGFzIG5vIHRleHQgYW5kIGlzIG5vdCBhIHBsYWNlaG9sZGVyLCB0cmVhdCBhcyBiYXNpYyBzaGFwZVxyXG4gICAgICBpZiAoIWhhc1RleHQgJiYgIWlzUGxhY2Vob2xkZXIpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhgU2hhcGUgJHtpbmRleCArIDF9IGhhcyBubyB0ZXh0IGFuZCBpcyBub3QgYSBwbGFjZWhvbGRlciwgdHJlYXRpbmcgYXMgYmFzaWMgc2hhcGVgKVxyXG4gICAgICAgIHJldHVybiB0aGlzLmV4dHJhY3RCYXNpY1NoYXBlKHRleHRCb3gsIHNsaWRlTnVtYmVyLCBpbmRleClcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5leHRyYWN0VHJhbnNmb3JtKHNwUHIpXHJcbiAgICAgIGNvbnN0IHRleHRDb250ZW50ID0gdGhpcy5leHRyYWN0VGV4dENvbnRlbnQodGV4dEJveClcclxuICAgICAgY29uc3QgdGV4dFN0eWxlID0gdGhpcy5leHRyYWN0VGV4dFN0eWxlKHRleHRCb3gpXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGVkIHRleHQgYm94OiBjb250ZW50PVwiJHt0ZXh0Q29udGVudH1cIiwgdHJhbnNmb3JtPWAsIHRyYW5zZm9ybSlcclxuICAgICAgXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgICAgICAgdHlwZTogJ3RleHQnLFxyXG4gICAgICAgIHRyYW5zZm9ybSxcclxuICAgICAgICBzdHlsZTogdGV4dFN0eWxlLFxyXG4gICAgICAgIGNvbnRlbnQ6IHRleHRDb250ZW50LFxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBleHRyYWN0aW5nIHRleHQgYm94OicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBleHRyYWN0SW1hZ2UoaW1hZ2U6IEVsZW1lbnQsIHNsaWRlTnVtYmVyOiBudW1iZXIsIGluZGV4OiBudW1iZXIpOiBTaGFwZU9iamVjdCB8IG51bGwge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3Qgc3BQciA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUoaW1hZ2UsICdzcFByJylcclxuICAgICAgaWYgKCFzcFByKSByZXR1cm4gbnVsbFxyXG4gICAgICBcclxuICAgICAgY29uc3QgdHJhbnNmb3JtID0gdGhpcy5leHRyYWN0VHJhbnNmb3JtKHNwUHIpXHJcbiAgICAgIFxyXG4gICAgICAvLyBGb3Igbm93LCB3ZSdsbCBjcmVhdGUgYSBwbGFjZWhvbGRlciBpbWFnZVxyXG4gICAgICAvLyBJbiBhIHJlYWwgaW1wbGVtZW50YXRpb24sIHlvdSdkIGV4dHJhY3QgdGhlIGFjdHVhbCBpbWFnZSBkYXRhXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IGNyeXB0by5yYW5kb21VVUlEKCksXHJcbiAgICAgICAgdHlwZTogJ2ltYWdlJyxcclxuICAgICAgICB0cmFuc2Zvcm0sXHJcbiAgICAgICAgc3R5bGU6IHt9LFxyXG4gICAgICAgIHNyYzogYGRhdGE6aW1hZ2Uvc3ZnK3htbDtiYXNlNjQsJHtidG9hKCc8c3ZnIHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgeG1sbnM9XCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiPjxyZWN0IHdpZHRoPVwiMTAwXCIgaGVpZ2h0PVwiMTAwXCIgZmlsbD1cIiNjY2NcIi8+PHRleHQgeD1cIjUwXCIgeT1cIjUwXCIgdGV4dC1hbmNob3I9XCJtaWRkbGVcIiBkeT1cIi4zZW1cIj5JbWFnZTwvdGV4dD48L3N2Zz4nKX1gLFxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBleHRyYWN0aW5nIGltYWdlOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBleHRyYWN0QmFzaWNTaGFwZShzaGFwZTogRWxlbWVudCwgc2xpZGVOdW1iZXI6IG51bWJlciwgaW5kZXg6IG51bWJlcik6IFNoYXBlT2JqZWN0IHwgbnVsbCB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZyhgRXh0cmFjdGluZyBiYXNpYyBzaGFwZSAke2luZGV4ICsgMX0gZnJvbSBzbGlkZSAke3NsaWRlTnVtYmVyfWApXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCBzcFByID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShzaGFwZSwgJ3NwUHInKVxyXG4gICAgICBpZiAoIXNwUHIpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oYE5vIHNwUHIgZm91bmQgaW4gYmFzaWMgc2hhcGUgJHtpbmRleCArIDF9YClcclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSB0aGlzLmV4dHJhY3RUcmFuc2Zvcm0oc3BQcilcclxuICAgICAgXHJcbiAgICAgIC8vIEdldCB0aGUgYWN0dWFsIHNoYXBlIHR5cGUgZnJvbSB0aGUgWE1MXHJcbiAgICAgIGxldCBwcnN0R2VvbSA9IHNwUHIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3Byc3RHZW9tJylbMF1cclxuICAgICAgaWYgKCFwcnN0R2VvbSkge1xyXG4gICAgICAgIHByc3RHZW9tID0gc3BQci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYTpwcnN0R2VvbScpWzBdXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGxldCBzaGFwZVR5cGU6ICdyZWN0YW5nbGUnIHwgJ2VsbGlwc2UnIHwgJ2xpbmUnID0gJ3JlY3RhbmdsZSdcclxuICAgICAgaWYgKHByc3RHZW9tKSB7XHJcbiAgICAgICAgY29uc3QgcHJzdCA9IHByc3RHZW9tLmdldEF0dHJpYnV0ZSgncHJzdCcpXHJcbiAgICAgICAgY29uc29sZS5sb2coYEZvdW5kIHNoYXBlIHR5cGUgaW4gWE1MOiAke3Byc3R9YClcclxuICAgICAgICBcclxuICAgICAgICBzd2l0Y2ggKHByc3QpIHtcclxuICAgICAgICAgIGNhc2UgJ3JlY3QnOlxyXG4gICAgICAgICAgY2FzZSAncm91bmRSZWN0JzpcclxuICAgICAgICAgICAgc2hhcGVUeXBlID0gJ3JlY3RhbmdsZSdcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIGNhc2UgJ2VsbGlwc2UnOlxyXG4gICAgICAgICAgY2FzZSAnb3ZhbCc6XHJcbiAgICAgICAgICAgIHNoYXBlVHlwZSA9ICdlbGxpcHNlJ1xyXG4gICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgY2FzZSAnbGluZSc6XHJcbiAgICAgICAgICBjYXNlICdzdHJhaWdodENvbm5lY3RvcjEnOlxyXG4gICAgICAgICAgICBzaGFwZVR5cGUgPSAnbGluZSdcclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGBVbmtub3duIHNoYXBlIHR5cGU6ICR7cHJzdH0sIGRlZmF1bHRpbmcgdG8gcmVjdGFuZ2xlYClcclxuICAgICAgICAgICAgc2hhcGVUeXBlID0gJ3JlY3RhbmdsZSdcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKGBFeHRyYWN0ZWQgYmFzaWMgc2hhcGU6IHR5cGU9JHtzaGFwZVR5cGV9LCB0cmFuc2Zvcm09YCwgdHJhbnNmb3JtKVxyXG4gICAgICBcclxuICAgICAgLy8gRm9yIGJhc2ljIHNoYXBlcywgd2UgbWlnaHQgc3RpbGwgaGF2ZSBzb21lIHRleHQgY29udGVudCAobGlrZSBwbGFjZWhvbGRlcnMpXHJcbiAgICAgIGxldCBjb250ZW50ID0gJydcclxuICAgICAgY29uc3QgdHhCb2R5ID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShzaGFwZSwgJ3R4Qm9keScpXHJcbiAgICAgIGlmICh0eEJvZHkpIHtcclxuICAgICAgICBjb250ZW50ID0gdGhpcy5leHRyYWN0VGV4dENvbnRlbnQoc2hhcGUpXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBwbGFjZWhvbGRlclxyXG4gICAgICBjb25zdCBudlByID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShzaGFwZSwgJ252UHInKVxyXG4gICAgICBjb25zdCBwaCA9IG52UHIgPyB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKG52UHIsICdwaCcpIDogbnVsbFxyXG4gICAgICBpZiAocGgpIHtcclxuICAgICAgICBjb25zdCBwaFR5cGUgPSBwaC5nZXRBdHRyaWJ1dGUoJ3R5cGUnKVxyXG4gICAgICAgIGlmIChwaFR5cGUgPT09ICd0aXRsZScpIHtcclxuICAgICAgICAgIGNvbnRlbnQgPSAnVGl0bGUgUGxhY2Vob2xkZXInXHJcbiAgICAgICAgfSBlbHNlIGlmIChwaFR5cGUgPT09ICdib2R5Jykge1xyXG4gICAgICAgICAgY29udGVudCA9ICdCb2R5IFBsYWNlaG9sZGVyJ1xyXG4gICAgICAgIH0gZWxzZSBpZiAocGhUeXBlID09PSAncGljJykge1xyXG4gICAgICAgICAgY29udGVudCA9ICdQaWN0dXJlIFBsYWNlaG9sZGVyJ1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBjb250ZW50ID0gJ0NvbnRlbnQgUGxhY2Vob2xkZXInXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgc2hhcGUgbmFtZSBmb3IgYmV0dGVyIGlkZW50aWZpY2F0aW9uXHJcbiAgICAgIGNvbnN0IGNOdlByID0gdGhpcy5maW5kRWxlbWVudEJ5VGFnTmFtZShzaGFwZSwgJ2NOdlByJylcclxuICAgICAgY29uc3Qgc2hhcGVOYW1lID0gY052UHI/LmdldEF0dHJpYnV0ZSgnbmFtZScpIHx8IGBTaGFwZSAke2luZGV4ICsgMX1gXHJcbiAgICAgIGNvbnNvbGUubG9nKGBTaGFwZSBuYW1lOiAke3NoYXBlTmFtZX1gKVxyXG4gICAgICBcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgICB0eXBlOiBzaGFwZVR5cGUsXHJcbiAgICAgICAgdHJhbnNmb3JtLFxyXG4gICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICBmaWxsOiBzaGFwZVR5cGUgPT09ICdsaW5lJyA/ICd0cmFuc3BhcmVudCcgOiAnI2U1ZTdlYicsIC8vIERlZmF1bHQgbGlnaHQgZ3JheSBmaWxsIGZvciBzaGFwZXNcclxuICAgICAgICAgIHN0cm9rZTogJyM2YjcyODAnLCAvLyBEZWZhdWx0IGJvcmRlciBjb2xvclxyXG4gICAgICAgICAgc3Ryb2tlV2lkdGg6IHNoYXBlVHlwZSA9PT0gJ2xpbmUnID8gMiA6IDEsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBjb250ZW50OiBjb250ZW50IHx8IHVuZGVmaW5lZCwgLy8gT25seSBpbmNsdWRlIGNvbnRlbnQgaWYgaXQgZXhpc3RzXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGV4dHJhY3RpbmcgYmFzaWMgc2hhcGU6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGV4dHJhY3RUcmFuc2Zvcm0oc3BQcjogRWxlbWVudCk6IFRyYW5zZm9ybSB7XHJcbiAgICAvLyBEZWJ1ZyB0aGUgc3BQciBlbGVtZW50IHN0cnVjdHVyZVxyXG4gICAgY29uc29sZS5sb2coJ0V4dHJhY3RpbmcgdHJhbnNmb3JtIGZyb20gc3BQcjonLCBzcFByLm91dGVySFRNTC5zdWJzdHJpbmcoMCwgNTAwKSArICcuLi4nKVxyXG4gICAgXHJcbiAgICAvLyBUcnkgdG8gZmluZCB4ZnJtIGVsZW1lbnQgd2l0aCBiZXR0ZXIgbmFtZXNwYWNlIGhhbmRsaW5nXHJcbiAgICBsZXQgeGZybSA9IHNwUHIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3hmcm0nKVswXVxyXG4gICAgaWYgKCF4ZnJtKSB7XHJcbiAgICAgIC8vIFRyeSB3aXRoIG5hbWVzcGFjZSBwcmVmaXhlc1xyXG4gICAgICB4ZnJtID0gc3BQci5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYTp4ZnJtJylbMF1cclxuICAgIH1cclxuICAgIGlmICgheGZybSkge1xyXG4gICAgICAvLyBUcnkgc2VhcmNoaW5nIGJ5IHBhcnRpYWwgdGFnIG5hbWVcclxuICAgICAgY29uc3QgYWxsRWxlbWVudHMgPSBzcFByLmdldEVsZW1lbnRzQnlUYWdOYW1lKCcqJylcclxuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbGxFbGVtZW50cy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IGVsID0gYWxsRWxlbWVudHNbaV1cclxuICAgICAgICBpZiAoZWwudGFnTmFtZS5pbmNsdWRlcygneGZybScpKSB7XHJcbiAgICAgICAgICB4ZnJtID0gZWxcclxuICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdGb3VuZCB4ZnJtIGVsZW1lbnQ6JywgeGZybT8ub3V0ZXJIVE1MKVxyXG4gICAgXHJcbiAgICBpZiAoeGZybSkge1xyXG4gICAgICAvLyBGaW5kIG9mZnNldCwgZXh0ZW50LCBhbmQgcm90YXRpb24gd2l0aCBiZXR0ZXIgbmFtZXNwYWNlIGhhbmRsaW5nXHJcbiAgICAgIGxldCBvZmYgPSB4ZnJtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdvZmYnKVswXVxyXG4gICAgICBpZiAoIW9mZikgb2ZmID0geGZybS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYTpvZmYnKVswXVxyXG4gICAgICBcclxuICAgICAgbGV0IGV4dCA9IHhmcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2V4dCcpWzBdXHJcbiAgICAgIGlmICghZXh0KSBleHQgPSB4ZnJtLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhOmV4dCcpWzBdXHJcbiAgICAgIFxyXG4gICAgICBsZXQgcm90ID0geGZybS5nZXRFbGVtZW50c0J5VGFnTmFtZSgncm90JylbMF1cclxuICAgICAgaWYgKCFyb3QpIHJvdCA9IHhmcm0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2E6cm90JylbMF1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCdUcmFuc2Zvcm0gZWxlbWVudHMgLSBvZmY6Jywgb2ZmPy5vdXRlckhUTUwsICdleHQ6JywgZXh0Py5vdXRlckhUTUwsICdyb3Q6Jywgcm90Py5vdXRlckhUTUwpXHJcbiAgICAgIFxyXG4gICAgICAvLyBDb252ZXJ0IEVNVXMgdG8gcGl4ZWxzIHdpdGggYmV0dGVyIHNjYWxpbmdcclxuICAgICAgLy8gMSBFTVUgPSAxLzkxNDQwMCBpbmNoLCAxIGluY2ggPSA5NiBwaXhlbHMgKHN0YW5kYXJkIERQSSlcclxuICAgICAgLy8gU28gMSBFTVUgPSA5Ni85MTQ0MDAgPSAwLjAwMDEwNSBwaXhlbHNcclxuICAgICAgLy8gRm9yIGJldHRlciB2aXNpYmlsaXR5LCB3ZSdsbCBzY2FsZSB0aGlzIHVwXHJcbiAgICAgIGNvbnN0IGVtdVRvUGl4ZWwgPSA5NiAvIDkxNDQwMFxyXG4gICAgICBjb25zdCBzY2FsZUZhY3RvciA9IDEgLy8gQWRqdXN0IHRoaXMgdG8gbWFrZSBzaGFwZXMgYmlnZ2VyL3NtYWxsZXJcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGxlZnQgPSBwYXJzZUludChvZmY/LmdldEF0dHJpYnV0ZSgneCcpIHx8ICcwJykgKiBlbXVUb1BpeGVsICogc2NhbGVGYWN0b3JcclxuICAgICAgY29uc3QgdG9wID0gcGFyc2VJbnQob2ZmPy5nZXRBdHRyaWJ1dGUoJ3knKSB8fCAnMCcpICogZW11VG9QaXhlbCAqIHNjYWxlRmFjdG9yXHJcbiAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQoZXh0Py5nZXRBdHRyaWJ1dGUoJ2N4JykgfHwgJzEwMDAwMDAnKSAqIGVtdVRvUGl4ZWwgKiBzY2FsZUZhY3RvclxyXG4gICAgICBjb25zdCBoZWlnaHQgPSBwYXJzZUludChleHQ/LmdldEF0dHJpYnV0ZSgnY3knKSB8fCAnMTAwMDAwMCcpICogZW11VG9QaXhlbCAqIHNjYWxlRmFjdG9yXHJcbiAgICAgIGNvbnN0IGFuZ2xlID0gcGFyc2VJbnQocm90Py5nZXRBdHRyaWJ1dGUoJ3ZhbCcpIHx8ICcwJykgLyA2MDAwMCAvLyBDb252ZXJ0IDYwa3RocyB0byBkZWdyZWVzXHJcbiAgICAgIFxyXG4gICAgICBjb25zdCB0cmFuc2Zvcm0gPSB7XHJcbiAgICAgICAgbGVmdDogTWF0aC5tYXgoMCwgbGVmdCksXHJcbiAgICAgICAgdG9wOiBNYXRoLm1heCgwLCB0b3ApLFxyXG4gICAgICAgIHdpZHRoOiBNYXRoLm1heCg1MCwgd2lkdGgpLCAvLyBNaW5pbXVtIHdpZHRoIG9mIDUwcHhcclxuICAgICAgICBoZWlnaHQ6IE1hdGgubWF4KDUwLCBoZWlnaHQpLCAvLyBNaW5pbXVtIGhlaWdodCBvZiA1MHB4XHJcbiAgICAgICAgYW5nbGUsXHJcbiAgICAgICAgc2NhbGVYOiAxLFxyXG4gICAgICAgIHNjYWxlWTogMSxcclxuICAgICAgICBmbGlwWDogZmFsc2UsXHJcbiAgICAgICAgZmxpcFk6IGZhbHNlLFxyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZygnRXh0cmFjdGVkIHRyYW5zZm9ybSAoRU1VIHZhbHVlcyk6Jywge1xyXG4gICAgICAgIGVtdUxlZnQ6IG9mZj8uZ2V0QXR0cmlidXRlKCd4JyksXHJcbiAgICAgICAgZW11VG9wOiBvZmY/LmdldEF0dHJpYnV0ZSgneScpLFxyXG4gICAgICAgIGVtdVdpZHRoOiBleHQ/LmdldEF0dHJpYnV0ZSgnY3gnKSxcclxuICAgICAgICBlbXVIZWlnaHQ6IGV4dD8uZ2V0QXR0cmlidXRlKCdjeScpXHJcbiAgICAgIH0pXHJcbiAgICAgIGNvbnNvbGUubG9nKCdDb252ZXJ0ZWQgdHJhbnNmb3JtIChwaXhlbHMpOicsIHRyYW5zZm9ybSlcclxuICAgICAgcmV0dXJuIHRyYW5zZm9ybVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLndhcm4oJ05vIHhmcm0gZm91bmQsIHVzaW5nIGRlZmF1bHQgdHJhbnNmb3JtJylcclxuICAgIHJldHVybiB7XHJcbiAgICAgIGxlZnQ6IDEwMCxcclxuICAgICAgdG9wOiAxMDAsXHJcbiAgICAgIHdpZHRoOiAyMDAsXHJcbiAgICAgIGhlaWdodDogMTUwLFxyXG4gICAgICBhbmdsZTogMCxcclxuICAgICAgc2NhbGVYOiAxLFxyXG4gICAgICBzY2FsZVk6IDEsXHJcbiAgICAgIGZsaXBYOiBmYWxzZSxcclxuICAgICAgZmxpcFk6IGZhbHNlLFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBleHRyYWN0VGV4dENvbnRlbnQodGV4dEJveDogRWxlbWVudCk6IHN0cmluZyB7XHJcbiAgICAvLyBUcnkgbXVsdGlwbGUgYXBwcm9hY2hlcyB0byBmaW5kIHRleHQgY29udGVudFxyXG4gICAgbGV0IGNvbnRlbnQgPSAnJ1xyXG4gICAgXHJcbiAgICAvLyBGaXJzdCB0cnk6IGxvb2sgZm9yIHRleHQgaW4gdHhCb2R5ID4gcCA+IHIgPiB0XHJcbiAgICBjb25zdCB0eEJvZHkgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHRleHRCb3gsICd0eEJvZHknKVxyXG4gICAgaWYgKHR4Qm9keSkge1xyXG4gICAgICBjb25zdCBwYXJhZ3JhcGhzID0gdGhpcy5maW5kRWxlbWVudHNCeVRhZ05hbWUodHhCb2R5LCAncCcpXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcGFyYWdyYXBocy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHBhcmFncmFwaCA9IHBhcmFncmFwaHNbaV1cclxuICAgICAgICBjb25zdCB0ZXh0UnVucyA9IHRoaXMuZmluZEVsZW1lbnRzQnlUYWdOYW1lKHBhcmFncmFwaCwgJ3InKVxyXG4gICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgdGV4dFJ1bnMubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICAgIGNvbnN0IHRleHRSdW4gPSB0ZXh0UnVuc1tqXVxyXG4gICAgICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHRleHRSdW4sICd0JylcclxuICAgICAgICAgIGlmICh0ZXh0RWxlbWVudCAmJiB0ZXh0RWxlbWVudC50ZXh0Q29udGVudCkge1xyXG4gICAgICAgICAgICBjb250ZW50ICs9IHRleHRFbGVtZW50LnRleHRDb250ZW50XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIEFkZCBsaW5lIGJyZWFrIGJldHdlZW4gcGFyYWdyYXBoc1xyXG4gICAgICAgIGlmIChpIDwgcGFyYWdyYXBocy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICBjb250ZW50ICs9ICdcXG4nXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNlY29uZCB0cnk6IGxvb2sgZm9yIHRleHQgZGlyZWN0bHkgaW4gdGhlIHRleHRCb3hcclxuICAgIGlmICghY29udGVudCkge1xyXG4gICAgICBjb25zdCB0ZXh0RWxlbWVudHMgPSB0aGlzLmZpbmRFbGVtZW50c0J5VGFnTmFtZSh0ZXh0Qm94LCAndCcpXHJcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dEVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgY29uc3QgZWxlbWVudCA9IHRleHRFbGVtZW50c1tpXVxyXG4gICAgICAgIGlmIChlbGVtZW50LnRleHRDb250ZW50KSB7XHJcbiAgICAgICAgICBjb250ZW50ICs9IGVsZW1lbnQudGV4dENvbnRlbnRcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgLy8gVGhpcmQgdHJ5OiBsb29rIGZvciBhbnkgdGV4dCBjb250ZW50IGluIHRoZSBlbGVtZW50XHJcbiAgICBpZiAoIWNvbnRlbnQpIHtcclxuICAgICAgY29udGVudCA9IHRleHRCb3gudGV4dENvbnRlbnQgfHwgJydcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYEV4dHJhY3RlZCB0ZXh0IGNvbnRlbnQ6IFwiJHtjb250ZW50fVwiYClcclxuICAgIHJldHVybiBjb250ZW50IHx8ICdUZXh0IEJveCdcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZXh0cmFjdFRleHRTdHlsZSh0ZXh0Qm94OiBFbGVtZW50KTogUGFydGlhbDxUZXh0U3R5bGU+IHtcclxuICAgIGNvbnN0IGRlZlJQciA9IHRoaXMuZmluZEVsZW1lbnRCeVRhZ05hbWUodGV4dEJveCwgJ2RlZlJQcicpXHJcbiAgICBcclxuICAgIGlmIChkZWZSUHIpIHtcclxuICAgICAgcmV0dXJuIHtcclxuICAgICAgICBmb250RmFtaWx5OiBkZWZSUHIuZ2V0QXR0cmlidXRlKCd0eXBlZmFjZScpIHx8ICdBcmlhbCcsXHJcbiAgICAgICAgZm9udFNpemU6IHBhcnNlSW50KGRlZlJQci5nZXRBdHRyaWJ1dGUoJ3N6JykgfHwgJzE4MDAnKSAvIDEwMCwgLy8gQ29udmVydCAxMDB0aHMgdG8gcG9pbnRzXHJcbiAgICAgICAgZm9udFdlaWdodDogZGVmUlByLmdldEF0dHJpYnV0ZSgnYicpID09PSAnMScgPyAnYm9sZCcgOiAnbm9ybWFsJyxcclxuICAgICAgICBmb250U3R5bGU6IGRlZlJQci5nZXRBdHRyaWJ1dGUoJ2knKSA9PT0gJzEnID8gJ2l0YWxpYycgOiAnbm9ybWFsJyxcclxuICAgICAgICB0ZXh0RGVjb3JhdGlvbjogZGVmUlByLmdldEF0dHJpYnV0ZSgndScpID09PSAnMScgPyAndW5kZXJsaW5lJyA6ICdub25lJyxcclxuICAgICAgICBjb2xvcjogdGhpcy5leHRyYWN0Q29sb3IoZGVmUlByKSxcclxuICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcclxuICAgICAgICBsaW5lSGVpZ2h0OiAxLjIsXHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgZm9udEZhbWlseTogJ0FyaWFsJyxcclxuICAgICAgZm9udFNpemU6IDE4LFxyXG4gICAgICBmb250V2VpZ2h0OiAnbm9ybWFsJyxcclxuICAgICAgZm9udFN0eWxlOiAnbm9ybWFsJyxcclxuICAgICAgdGV4dERlY29yYXRpb246ICdub25lJyxcclxuICAgICAgY29sb3I6ICcjMDAwMDAwJyxcclxuICAgICAgdGV4dEFsaWduOiAnbGVmdCcsXHJcbiAgICAgIGxpbmVIZWlnaHQ6IDEuMixcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZXh0cmFjdENvbG9yKGRlZlJQcjogRWxlbWVudCk6IHN0cmluZyB7XHJcbiAgICBjb25zdCBzb2xpZEZpbGwgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKGRlZlJQciwgJ3NvbGlkRmlsbCcpXHJcbiAgICBpZiAoc29saWRGaWxsKSB7XHJcbiAgICAgIGNvbnN0IHNyZ2JDbHIgPSB0aGlzLmZpbmRFbGVtZW50QnlUYWdOYW1lKHNvbGlkRmlsbCwgJ3NyZ2JDbHInKVxyXG4gICAgICBpZiAoc3JnYkNscikge1xyXG4gICAgICAgIGNvbnN0IHZhbCA9IHNyZ2JDbHIuZ2V0QXR0cmlidXRlKCd2YWwnKVxyXG4gICAgICAgIGlmICh2YWwpIHtcclxuICAgICAgICAgIHJldHVybiBgIyR7dmFsfWBcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiAnIzAwMDAwMCdcclxuICB9XHJcblxyXG4gIHByaXZhdGUgZGV0ZXJtaW5lU2hhcGVUeXBlKHNwUHI6IEVsZW1lbnQpOiAncmVjdGFuZ2xlJyB8ICdlbGxpcHNlJyB8ICdsaW5lJyB7XHJcbiAgICAvLyBUcnkgdG8gZmluZCBwcnN0R2VvbSBlbGVtZW50IHdpdGggYmV0dGVyIG5hbWVzcGFjZSBoYW5kbGluZ1xyXG4gICAgbGV0IHByc3RHZW9tID0gc3BQci5nZXRFbGVtZW50c0J5VGFnTmFtZSgncHJzdEdlb20nKVswXVxyXG4gICAgaWYgKCFwcnN0R2VvbSkge1xyXG4gICAgICBwcnN0R2VvbSA9IHNwUHIuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2E6cHJzdEdlb20nKVswXVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAocHJzdEdlb20pIHtcclxuICAgICAgY29uc3QgcHJzdCA9IHByc3RHZW9tLmdldEF0dHJpYnV0ZSgncHJzdCcpXHJcbiAgICAgIGNvbnNvbGUubG9nKGBGb3VuZCBzaGFwZSB0eXBlOiAke3Byc3R9YClcclxuICAgICAgXHJcbiAgICAgIHN3aXRjaCAocHJzdCkge1xyXG4gICAgICAgIGNhc2UgJ3JlY3QnOlxyXG4gICAgICAgIGNhc2UgJ3JvdW5kUmVjdCc6XHJcbiAgICAgICAgICByZXR1cm4gJ3JlY3RhbmdsZSdcclxuICAgICAgICBjYXNlICdlbGxpcHNlJzpcclxuICAgICAgICBjYXNlICdvdmFsJzpcclxuICAgICAgICAgIHJldHVybiAnZWxsaXBzZSdcclxuICAgICAgICBjYXNlICdsaW5lJzpcclxuICAgICAgICBjYXNlICdzdHJhaWdodENvbm5lY3RvcjEnOlxyXG4gICAgICAgICAgcmV0dXJuICdsaW5lJ1xyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhgVW5rbm93biBzaGFwZSB0eXBlOiAke3Byc3R9LCBkZWZhdWx0aW5nIHRvIHJlY3RhbmdsZWApXHJcbiAgICAgICAgICByZXR1cm4gJ3JlY3RhbmdsZSdcclxuICAgICAgfVxyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBJZiBubyBwcnN0R2VvbSBmb3VuZCwgdHJ5IHRvIGRldGVybWluZSBmcm9tIG90aGVyIHByb3BlcnRpZXNcclxuICAgIGNvbnNvbGUubG9nKCdObyBwcnN0R2VvbSBmb3VuZCwgZGVmYXVsdGluZyB0byByZWN0YW5nbGUnKVxyXG4gICAgcmV0dXJuICdyZWN0YW5nbGUnXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGNyZWF0ZURlZmF1bHRTbGlkZSgpOiBTbGlkZSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogY3J5cHRvLnJhbmRvbVVVSUQoKSxcclxuICAgICAgbmFtZTogJ1NsaWRlIDEnLFxyXG4gICAgICB3aWR0aDogOTYwLFxyXG4gICAgICBoZWlnaHQ6IDU0MCxcclxuICAgICAgb2JqZWN0czogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlkOiBjcnlwdG8ucmFuZG9tVVVJRCgpLFxyXG4gICAgICAgICAgdHlwZTogJ3RleHQnLFxyXG4gICAgICAgICAgdHJhbnNmb3JtOiB7XHJcbiAgICAgICAgICAgIGxlZnQ6IDEwMCxcclxuICAgICAgICAgICAgdG9wOiAxMDAsXHJcbiAgICAgICAgICAgIHdpZHRoOiAzMDAsXHJcbiAgICAgICAgICAgIGhlaWdodDogMTAwLFxyXG4gICAgICAgICAgICBhbmdsZTogMCxcclxuICAgICAgICAgICAgc2NhbGVYOiAxLFxyXG4gICAgICAgICAgICBzY2FsZVk6IDEsXHJcbiAgICAgICAgICAgIGZsaXBYOiBmYWxzZSxcclxuICAgICAgICAgICAgZmxpcFk6IGZhbHNlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICAgIHN0eWxlOiB7XHJcbiAgICAgICAgICAgIGZvbnRGYW1pbHk6ICdBcmlhbCcsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAyNCxcclxuICAgICAgICAgICAgZm9udFdlaWdodDogJ2JvbGQnLFxyXG4gICAgICAgICAgICBjb2xvcjogJyMwMDAwMDAnLFxyXG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICBjb250ZW50OiAnV2VsY29tZSB0byBQUFRYIEVkaXRvcicsXHJcbiAgICAgICAgfVxyXG4gICAgICBdLFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG5cclxuIl0sIm5hbWVzIjpbIkpTWmlwIiwiUFBUWFBhcnNlciIsInBhcnNlRmlsZSIsImZpbGUiLCJjb25zb2xlIiwibG9nIiwiemlwIiwibG9hZEFzeW5jIiwiZmlsZU5hbWVzIiwiT2JqZWN0Iiwia2V5cyIsImZpbGVzIiwic2xpZGVzIiwicmVhZFNsaWRlcyIsInByb3BlcnRpZXMiLCJyZWFkUHJlc2VudGF0aW9uUHJvcHMiLCJpZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJuYW1lIiwicmVwbGFjZSIsIm1ldGFkYXRhIiwiZXJyb3IiLCJjb3JlUHJvcHMiLCJjb250ZW50IiwiYXN5bmMiLCJwYXJzZXIiLCJET01QYXJzZXIiLCJ4bWwiLCJwYXJzZUZyb21TdHJpbmciLCJhdXRob3JFbGVtZW50IiwicXVlcnlTZWxlY3RvciIsImF1dGhvciIsInRleHRDb250ZW50IiwidW5kZWZpbmVkIiwid2FybiIsInByZXNlbnRhdGlvbiIsInN1YnN0cmluZyIsInNsaWRlSWRzIiwiZ2V0RWxlbWVudHNCeVRhZ05hbWUiLCJsZW5ndGgiLCJzbGlkZUZpbGVzIiwiZmlsdGVyIiwic3RhcnRzV2l0aCIsImVuZHNXaXRoIiwic29ydCIsImkiLCJzbGlkZUZpbGUiLCJzbGlkZU51bWJlciIsInNsaWRlIiwicmVhZFNsaWRlRnJvbUZpbGUiLCJwdXNoIiwic2xpZGVJZCIsImdldEF0dHJpYnV0ZSIsInJlYWRTbGlkZSIsImNyZWF0ZURlZmF1bHRTbGlkZSIsInNsaWRlUmVsIiwicmVsWG1sIiwicmVsQ29udGVudCIsInJlbFBhcnNlciIsInNsaWRlVGFyZ2V0Iiwic2xpZGVQYXRoIiwic3BsaXQiLCJwb3AiLCJ0YXJnZXRTbGlkZSIsInNsaWRlQ29udGVudCIsInNsaWRlUGFyc2VyIiwic2xpZGVYbWwiLCJzbGRTeiIsIndpZHRoIiwicGFyc2VJbnQiLCJoZWlnaHQiLCJvYmplY3RzIiwiZXh0cmFjdFNoYXBlcyIsInNsaWRlRmlsZVBhdGgiLCJzcFRyZWUiLCJmaW5kRWxlbWVudEJ5VGFnTmFtZSIsInRleHRCb3hlcyIsImZpbmRFbGVtZW50c0J5VGFnTmFtZSIsInRleHRCb3giLCJ0YWdOYW1lIiwibnZQciIsInBoIiwicGhUeXBlIiwic2hhcGUiLCJleHRyYWN0VGV4dEJveCIsInR5cGUiLCJhbGxTcEVsZW1lbnRzIiwic3BFbGVtZW50IiwidGV4dEVsZW1lbnRzIiwiZmlyc3RUZXh0IiwidGV4dE9iamVjdCIsInRyYW5zZm9ybSIsImxlZnQiLCJ0b3AiLCJhbmdsZSIsInNjYWxlWCIsInNjYWxlWSIsImZsaXBYIiwiZmxpcFkiLCJzdHlsZSIsImZvbnRGYW1pbHkiLCJmb250U2l6ZSIsImZvbnRXZWlnaHQiLCJmb250U3R5bGUiLCJ0ZXh0RGVjb3JhdGlvbiIsImNvbG9yIiwidGV4dEFsaWduIiwibGluZUhlaWdodCIsImltYWdlcyIsImltYWdlIiwiZXh0cmFjdEltYWdlIiwibWFwIiwib2JqIiwicGFyZW50IiwiZWxlbWVudCIsInByZWZpeGVzIiwicHJlZml4IiwiZnVsbFRhZ05hbWUiLCJhbGxFbGVtZW50cyIsImVsIiwiaW5jbHVkZXMiLCJlbGVtZW50cyIsIkFycmF5IiwiZnJvbSIsIm1hdGNoaW5nRWxlbWVudHMiLCJpbmRleCIsIm91dGVySFRNTCIsInNwUHIiLCJ0eEJvZHkiLCJoYXNUZXh0IiwiaXNQbGFjZWhvbGRlciIsInByc3RHZW9tIiwic2hhcGVUeXBlIiwiZXh0cmFjdEJhc2ljU2hhcGUiLCJleHRyYWN0VHJhbnNmb3JtIiwiZXh0cmFjdFRleHRDb250ZW50IiwidGV4dFN0eWxlIiwiZXh0cmFjdFRleHRTdHlsZSIsInNyYyIsImJ0b2EiLCJwcnN0IiwiY052UHIiLCJzaGFwZU5hbWUiLCJmaWxsIiwic3Ryb2tlIiwic3Ryb2tlV2lkdGgiLCJ4ZnJtIiwib2ZmIiwiZXh0Iiwicm90IiwiZW11VG9QaXhlbCIsInNjYWxlRmFjdG9yIiwiTWF0aCIsIm1heCIsImVtdUxlZnQiLCJlbXVUb3AiLCJlbXVXaWR0aCIsImVtdUhlaWdodCIsInBhcmFncmFwaHMiLCJwYXJhZ3JhcGgiLCJ0ZXh0UnVucyIsImoiLCJ0ZXh0UnVuIiwidGV4dEVsZW1lbnQiLCJkZWZSUHIiLCJleHRyYWN0Q29sb3IiLCJzb2xpZEZpbGwiLCJzcmdiQ2xyIiwidmFsIiwiZGV0ZXJtaW5lU2hhcGVUeXBlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./src/utils/pptxParser.ts\n"));

/***/ })

});