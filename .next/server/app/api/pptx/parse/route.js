"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "app/api/pptx/parse/route";
exports.ids = ["app/api/pptx/parse/route"];
exports.modules = {

/***/ "next/dist/compiled/next-server/app-route.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/app-route.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/app-route.runtime.dev.js");

/***/ }),

/***/ "buffer":
/*!*************************!*\
  !*** external "buffer" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("buffer");

/***/ }),

/***/ "events":
/*!*************************!*\
  !*** external "events" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("events");

/***/ }),

/***/ "stream":
/*!*************************!*\
  !*** external "stream" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("stream");

/***/ }),

/***/ "string_decoder":
/*!*********************************!*\
  !*** external "string_decoder" ***!
  \*********************************/
/***/ ((module) => {

module.exports = require("string_decoder");

/***/ }),

/***/ "timers":
/*!*************************!*\
  !*** external "timers" ***!
  \*************************/
/***/ ((module) => {

module.exports = require("timers");

/***/ }),

/***/ "util":
/*!***********************!*\
  !*** external "util" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("util");

/***/ }),

/***/ "(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpptx%2Fparse%2Froute&page=%2Fapi%2Fpptx%2Fparse%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpptx%2Fparse%2Froute.ts&appDir=C%3A%5CUsers%5CHP%5Cpptx-editor%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CHP%5Cpptx-editor&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpptx%2Fparse%2Froute&page=%2Fapi%2Fpptx%2Fparse%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpptx%2Fparse%2Froute.ts&appDir=C%3A%5CUsers%5CHP%5Cpptx-editor%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CHP%5Cpptx-editor&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   headerHooks: () => (/* binding */ headerHooks),\n/* harmony export */   originalPathname: () => (/* binding */ originalPathname),\n/* harmony export */   patchFetch: () => (/* binding */ patchFetch),\n/* harmony export */   requestAsyncStorage: () => (/* binding */ requestAsyncStorage),\n/* harmony export */   routeModule: () => (/* binding */ routeModule),\n/* harmony export */   serverHooks: () => (/* binding */ serverHooks),\n/* harmony export */   staticGenerationAsyncStorage: () => (/* binding */ staticGenerationAsyncStorage),\n/* harmony export */   staticGenerationBailout: () => (/* binding */ staticGenerationBailout)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/app-route/module.compiled */ \"(rsc)/./node_modules/next/dist/server/future/route-modules/app-route/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(rsc)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/server/lib/patch-fetch */ \"(rsc)/./node_modules/next/dist/server/lib/patch-fetch.js\");\n/* harmony import */ var next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var C_Users_HP_pptx_editor_src_app_api_pptx_parse_route_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./src/app/api/pptx/parse/route.ts */ \"(rsc)/./src/app/api/pptx/parse/route.ts\");\n\n\n\n\n// We inject the nextConfigOutput here so that we can use them in the route\n// module.\nconst nextConfigOutput = \"\"\nconst routeModule = new next_dist_server_future_route_modules_app_route_module_compiled__WEBPACK_IMPORTED_MODULE_0__.AppRouteRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.APP_ROUTE,\n        page: \"/api/pptx/parse/route\",\n        pathname: \"/api/pptx/parse\",\n        filename: \"route\",\n        bundlePath: \"app/api/pptx/parse/route\"\n    },\n    resolvedPagePath: \"C:\\\\Users\\\\HP\\\\pptx-editor\\\\src\\\\app\\\\api\\\\pptx\\\\parse\\\\route.ts\",\n    nextConfigOutput,\n    userland: C_Users_HP_pptx_editor_src_app_api_pptx_parse_route_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n// Pull out the exports that we need to expose from the module. This should\n// be eliminated when we've moved the other routes to the new format. These\n// are used to hook into the route.\nconst { requestAsyncStorage, staticGenerationAsyncStorage, serverHooks, headerHooks, staticGenerationBailout } = routeModule;\nconst originalPathname = \"/api/pptx/parse/route\";\nfunction patchFetch() {\n    return (0,next_dist_server_lib_patch_fetch__WEBPACK_IMPORTED_MODULE_2__.patchFetch)({\n        serverHooks,\n        staticGenerationAsyncStorage\n    });\n}\n\n\n//# sourceMappingURL=app-route.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWFwcC1sb2FkZXIuanM/bmFtZT1hcHAlMkZhcGklMkZwcHR4JTJGcGFyc2UlMkZyb3V0ZSZwYWdlPSUyRmFwaSUyRnBwdHglMkZwYXJzZSUyRnJvdXRlJmFwcFBhdGhzPSZwYWdlUGF0aD1wcml2YXRlLW5leHQtYXBwLWRpciUyRmFwaSUyRnBwdHglMkZwYXJzZSUyRnJvdXRlLnRzJmFwcERpcj1DJTNBJTVDVXNlcnMlNUNIUCU1Q3BwdHgtZWRpdG9yJTVDc3JjJTVDYXBwJnBhZ2VFeHRlbnNpb25zPXRzeCZwYWdlRXh0ZW5zaW9ucz10cyZwYWdlRXh0ZW5zaW9ucz1qc3gmcGFnZUV4dGVuc2lvbnM9anMmcm9vdERpcj1DJTNBJTVDVXNlcnMlNUNIUCU1Q3BwdHgtZWRpdG9yJmlzRGV2PXRydWUmdHNjb25maWdQYXRoPXRzY29uZmlnLmpzb24mYmFzZVBhdGg9JmFzc2V0UHJlZml4PSZuZXh0Q29uZmlnT3V0cHV0PSZwcmVmZXJyZWRSZWdpb249Jm1pZGRsZXdhcmVDb25maWc9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNjO0FBQ2dCO0FBQzdGO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixnSEFBbUI7QUFDM0M7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxZQUFZO0FBQ1osQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLFFBQVEsdUdBQXVHO0FBQy9HO0FBQ0E7QUFDQSxXQUFXLDRFQUFXO0FBQ3RCO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDNko7O0FBRTdKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1lZGl0b3IvPzA4MjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQXBwUm91dGVSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL2FwcC1yb3V0ZS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBwYXRjaEZldGNoIGFzIF9wYXRjaEZldGNoIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvbGliL3BhdGNoLWZldGNoXCI7XG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiQzpcXFxcVXNlcnNcXFxcSFBcXFxccHB0eC1lZGl0b3JcXFxcc3JjXFxcXGFwcFxcXFxhcGlcXFxccHB0eFxcXFxwYXJzZVxcXFxyb3V0ZS50c1wiO1xuLy8gV2UgaW5qZWN0IHRoZSBuZXh0Q29uZmlnT3V0cHV0IGhlcmUgc28gdGhhdCB3ZSBjYW4gdXNlIHRoZW0gaW4gdGhlIHJvdXRlXG4vLyBtb2R1bGUuXG5jb25zdCBuZXh0Q29uZmlnT3V0cHV0ID0gXCJcIlxuY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgQXBwUm91dGVSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuQVBQX1JPVVRFLFxuICAgICAgICBwYWdlOiBcIi9hcGkvcHB0eC9wYXJzZS9yb3V0ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL3BwdHgvcGFyc2VcIixcbiAgICAgICAgZmlsZW5hbWU6IFwicm91dGVcIixcbiAgICAgICAgYnVuZGxlUGF0aDogXCJhcHAvYXBpL3BwdHgvcGFyc2Uvcm91dGVcIlxuICAgIH0sXG4gICAgcmVzb2x2ZWRQYWdlUGF0aDogXCJDOlxcXFxVc2Vyc1xcXFxIUFxcXFxwcHR4LWVkaXRvclxcXFxzcmNcXFxcYXBwXFxcXGFwaVxcXFxwcHR4XFxcXHBhcnNlXFxcXHJvdXRlLnRzXCIsXG4gICAgbmV4dENvbmZpZ091dHB1dCxcbiAgICB1c2VybGFuZFxufSk7XG4vLyBQdWxsIG91dCB0aGUgZXhwb3J0cyB0aGF0IHdlIG5lZWQgdG8gZXhwb3NlIGZyb20gdGhlIG1vZHVsZS4gVGhpcyBzaG91bGRcbi8vIGJlIGVsaW1pbmF0ZWQgd2hlbiB3ZSd2ZSBtb3ZlZCB0aGUgb3RoZXIgcm91dGVzIHRvIHRoZSBuZXcgZm9ybWF0LiBUaGVzZVxuLy8gYXJlIHVzZWQgdG8gaG9vayBpbnRvIHRoZSByb3V0ZS5cbmNvbnN0IHsgcmVxdWVzdEFzeW5jU3RvcmFnZSwgc3RhdGljR2VuZXJhdGlvbkFzeW5jU3RvcmFnZSwgc2VydmVySG9va3MsIGhlYWRlckhvb2tzLCBzdGF0aWNHZW5lcmF0aW9uQmFpbG91dCB9ID0gcm91dGVNb2R1bGU7XG5jb25zdCBvcmlnaW5hbFBhdGhuYW1lID0gXCIvYXBpL3BwdHgvcGFyc2Uvcm91dGVcIjtcbmZ1bmN0aW9uIHBhdGNoRmV0Y2goKSB7XG4gICAgcmV0dXJuIF9wYXRjaEZldGNoKHtcbiAgICAgICAgc2VydmVySG9va3MsXG4gICAgICAgIHN0YXRpY0dlbmVyYXRpb25Bc3luY1N0b3JhZ2VcbiAgICB9KTtcbn1cbmV4cG9ydCB7IHJvdXRlTW9kdWxlLCByZXF1ZXN0QXN5bmNTdG9yYWdlLCBzdGF0aWNHZW5lcmF0aW9uQXN5bmNTdG9yYWdlLCBzZXJ2ZXJIb29rcywgaGVhZGVySG9va3MsIHN0YXRpY0dlbmVyYXRpb25CYWlsb3V0LCBvcmlnaW5hbFBhdGhuYW1lLCBwYXRjaEZldGNoLCAgfTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBwLXJvdXRlLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpptx%2Fparse%2Froute&page=%2Fapi%2Fpptx%2Fparse%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpptx%2Fparse%2Froute.ts&appDir=C%3A%5CUsers%5CHP%5Cpptx-editor%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CHP%5Cpptx-editor&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!\n");

/***/ }),

/***/ "(rsc)/./src/app/api/pptx/parse/route.ts":
/*!*****************************************!*\
  !*** ./src/app/api/pptx/parse/route.ts ***!
  \*****************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   POST: () => (/* binding */ POST)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/web/exports/next-response */ \"(rsc)/./node_modules/next/dist/server/web/exports/next-response.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! jszip */ \"(rsc)/./node_modules/jszip/lib/index.js\");\n/* harmony import */ var jszip__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(jszip__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var xml2js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! xml2js */ \"(rsc)/./node_modules/xml2js/lib/xml2js.js\");\n/* harmony import */ var xml2js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(xml2js__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nasync function POST(request) {\n    try {\n        const formData = await request.formData();\n        const file = formData.get(\"file\");\n        if (!file) {\n            return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n                error: \"No file provided\"\n            }, {\n                status: 400\n            });\n        }\n        console.log(\"\\uD83D\\uDCC1 Processing file:\", file.name);\n        // Convert File to Buffer\n        const arrayBuffer = await file.arrayBuffer();\n        const buffer = Buffer.from(arrayBuffer);\n        // Parse the PPTX file\n        const pptxService = new PPTXService();\n        const presentation = await pptxService.parsePPTX(buffer);\n        console.log(\"‚úÖ Parsing completed successfully\");\n        return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json(presentation);\n    } catch (error) {\n        console.error(\"‚ùå Error parsing PPTX file:\", error);\n        return next_dist_server_web_exports_next_response__WEBPACK_IMPORTED_MODULE_0__[\"default\"].json({\n            error: \"Failed to parse PPTX file\"\n        }, {\n            status: 500\n        });\n    }\n}\n// PPTX Service class (moved from backend)\nclass PPTXService {\n    async parsePPTX(buffer) {\n        try {\n            const zip = await jszip__WEBPACK_IMPORTED_MODULE_1___default().loadAsync(buffer);\n            const slides = await this.readSlides(zip);\n            const properties = await this.readPresentationProps(zip);\n            const presentation = {\n                id: this.generateId(),\n                name: \"Imported Presentation\",\n                slides,\n                metadata: properties\n            };\n            this.parsedPresentations.set(presentation.id, presentation);\n            console.log(\"‚úÖ Parsing completed successfully\");\n            return presentation;\n        } catch (error) {\n            console.error(\"‚ùå Error parsing PPTX file:\", error);\n            throw error;\n        }\n    }\n    async getSlide(slideId) {\n        const presentations = Array.from(this.parsedPresentations.values());\n        for (const presentation of presentations){\n            const slide = presentation.slides.find((s)=>s.id === slideId);\n            if (slide) return slide;\n        }\n        return null;\n    }\n    async exportPPTX(presentationData) {\n        // Placeholder for export logic\n        console.log(\"\\uD83D\\uDEA7 Exporting PPTX (placeholder)\");\n        const zip = new (jszip__WEBPACK_IMPORTED_MODULE_1___default())();\n        zip.file(\"doc.txt\", JSON.stringify(presentationData, null, 2));\n        const content = await zip.generateAsync({\n            type: \"nodebuffer\"\n        });\n        return content;\n    }\n    async readSlides(zip) {\n        const slides = [];\n        try {\n            const presentationXml = await zip.file(\"ppt/presentation.xml\")?.async(\"text\");\n            if (!presentationXml) {\n                console.warn(\"No presentation.xml found.\");\n                return [];\n            }\n            console.log(\"\\uD83D\\uDCC4 Found presentation.xml, length:\", presentationXml.length);\n            // Parse XML using xml2js\n            const presentationData = await this.parseXML(presentationXml);\n            console.log(\"\\uD83D\\uDD0D Parsed presentation data:\", JSON.stringify(presentationData, null, 2));\n            // Navigate to the presentation element first\n            const presentation = this.findElement(presentationData, \"p:presentation\");\n            if (!presentation) {\n                console.warn(\"‚ùå No presentation element found\");\n                return [];\n            }\n            const sldIdList = this.findElement(presentation, \"p:sldIdLst\");\n            console.log(\"\\uD83D\\uDCCB Found sldIdList:\", sldIdList);\n            if (sldIdList) {\n                const sldIds = this.findElements(sldIdList, \"p:sldId\");\n                console.log(`üî¢ Found ${sldIds.length} slide IDs:`, sldIds);\n                for(let i = 0; i < sldIds.length; i++){\n                    const sldId = sldIds[i];\n                    const rId = this.getAttribute(sldId, \"r:id\");\n                    console.log(`üìù Slide ${i + 1} has rId:`, rId);\n                    if (rId) {\n                        const relsXml = await zip.file(\"ppt/_rels/presentation.xml.rels\")?.async(\"text\");\n                        if (relsXml) {\n                            console.log(\"\\uD83D\\uDD17 Found relationships file, length:\", relsXml.length);\n                            const relsData = await this.parseXML(relsXml);\n                            console.log(\"\\uD83D\\uDD17 Parsed relationships data:\", JSON.stringify(relsData, null, 2));\n                            // Find the relationship that matches this slide's rId\n                            const relationships = this.findElements(relsData.Relationships, \"Relationship\");\n                            let target = null;\n                            console.log(`üîç Looking for relationship with Id: ${rId}`);\n                            console.log(`üîç Found ${relationships.length} relationships:`, relationships);\n                            for (const rel of relationships){\n                                const relId = this.getAttribute(rel, \"Id\");\n                                console.log(`üîç Checking relationship Id: ${relId}`);\n                                if (relId === rId) {\n                                    target = this.getAttribute(rel, \"Target\");\n                                    console.log(`‚úÖ Found matching relationship! Target: ${target}`);\n                                    break;\n                                }\n                            }\n                            console.log(\"\\uD83C\\uDFAF Final relationship target:\", target);\n                            if (target) {\n                                const slideFilePath = `ppt/${target}`;\n                                console.log(\"\\uD83D\\uDCC1 Slide file path:\", slideFilePath);\n                                const slide = await this.parseSlide(zip, slideFilePath, i + 1);\n                                if (slide) {\n                                    console.log(`‚úÖ Successfully parsed slide ${i + 1}:`, slide);\n                                    slides.push(slide);\n                                } else {\n                                    console.warn(`‚ùå Failed to parse slide ${i + 1}`);\n                                }\n                            }\n                        } else {\n                            console.warn(\"‚ùå No relationships file found\");\n                        }\n                    }\n                }\n            } else {\n                console.warn(\"‚ùå No sldIdList found in presentation data\");\n            }\n        } catch (error) {\n            console.error(\"‚ùå Error reading slides:\", error);\n        }\n        console.log(`üìä Total slides loaded: ${slides.length}`);\n        return slides;\n    }\n    async parseSlide(zip, slideFilePath, slideNumber) {\n        try {\n            const slideFile = zip.file(slideFilePath);\n            if (!slideFile) {\n                console.warn(`Slide file not found: ${slideFilePath}`);\n                return null;\n            }\n            const slideContent = await slideFile.async(\"text\");\n            console.log(`üìÑ Slide ${slideNumber} XML content length: ${slideContent.length}`);\n            // Parse the slide XML content\n            const slideData = await this.parseXML(slideContent);\n            const objects = await this.extractSlideObjects(slideData, zip, `ppt/slides/_rels/slide${slideNumber}.xml.rels`);\n            // Return basic slide structure - frontend will handle rendering\n            return {\n                id: this.generateId(),\n                slideNumber,\n                width: 800,\n                height: 600,\n                objects,\n                // Store raw slide XML for frontend processing\n                rawData: slideData\n            };\n        } catch (error) {\n            console.error(`Error parsing slide ${slideNumber}:`, error);\n            return null;\n        }\n    }\n    async extractSlideObjects(slideData, zip, slideRelsPath) {\n        const objects = [];\n        try {\n            console.log(\"\\uD83D\\uDD0D Extracting objects from slide data\");\n            // Navigate the correct XML structure: p:sld -> p:cSld -> p:spTree\n            const slide = this.findElement(slideData, \"p:sld\");\n            if (!slide) {\n                console.warn(\"‚ùå No p:sld found in slide data\");\n                return objects;\n            }\n            const cSld = this.findElement(slide, \"p:cSld\");\n            if (!cSld) {\n                console.warn(\"‚ùå No p:cSld found in slide\");\n                return objects;\n            }\n            // Find the shape tree\n            const spTree = this.findElement(cSld, \"p:spTree\");\n            if (!spTree) {\n                console.warn(\"‚ùå No spTree found in slide\");\n                return objects;\n            }\n            // Extract all shapes (both individual and grouped)\n            const allShapes = [\n                ...this.findElements(spTree, \"p:sp\"),\n                ...this.findElements(spTree, \"p:grpSp\")\n            ];\n            console.log(`üî∑ Found ${allShapes.length} total shapes in slide`);\n            for(let i = 0; i < allShapes.length; i++){\n                const shape = allShapes[i];\n                const shapeObject = await this.extractBasicShape(shape, i, zip, slideRelsPath);\n                if (shapeObject) {\n                    objects.push(shapeObject);\n                }\n            }\n        } catch (error) {\n            console.error(\"‚ùå Error extracting slide objects:\", error);\n        }\n        console.log(`üìä Total objects extracted: ${objects.length}`);\n        return objects;\n    }\n    async extractBasicShape(shape, index, zip, slideRelsPath) {\n        try {\n            // Get basic shape info\n            const nvSpPr = this.findElement(shape, \"p:nvSpPr\");\n            const cNvPr = this.findElement(nvSpPr, \"p:cNvPr\");\n            const name = this.getAttribute(cNvPr, \"name\") || `Shape ${index + 1}`;\n            // Check if it's a group\n            const isGroup = shape[\"p:grpSpPr\"] !== undefined;\n            // Check if it's a picture\n            const isPicture = shape[\"p:nvPicPr\"] !== undefined;\n            if (isPicture) {\n                console.log(`üîç Found picture shape: ${name}`);\n                const imageObject = await this.extractImage(shape, zip, slideRelsPath);\n                if (imageObject) {\n                    return imageObject;\n                }\n            }\n            // Extract text content if present\n            const txBody = this.findElement(shape, \"p:txBody\");\n            let textContent = \"\";\n            if (txBody) {\n                textContent = this.extractTextContent(txBody);\n            }\n            // Basic shape object - let frontend handle the details\n            return {\n                id: this.generateId(),\n                type: isGroup ? \"group\" : \"shape\",\n                name,\n                text: textContent,\n                // Store raw XML data for frontend processing\n                rawData: shape\n            };\n        } catch (error) {\n            console.error(`Error extracting basic shape ${index}:`, error);\n            return null;\n        }\n    }\n    extractTextContent(txBody) {\n        try {\n            console.log(\"\\uD83D\\uDD0D Extracting text from txBody:\", JSON.stringify(txBody, null, 2));\n            console.log(\"\\uD83D\\uDD0D txBody keys:\", Object.keys(txBody));\n            const paragraphs = this.findElements(txBody, \"a:p\");\n            console.log(\"\\uD83D\\uDD0D Found paragraphs:\", paragraphs);\n            let text = \"\";\n            for (const paragraph of paragraphs){\n                const textRuns = this.findElements(paragraph, \"a:r\");\n                console.log(\"\\uD83D\\uDD0D Found text runs:\", textRuns);\n                for (const textRun of textRuns){\n                    const textElement = this.findElement(textRun, \"a:t\");\n                    console.log(\"\\uD83D\\uDD0D Found text element:\", textElement);\n                    // Handle different text content formats from xml2js\n                    if (textElement) {\n                        if (typeof textElement === \"string\") {\n                            // Direct string content\n                            text += textElement;\n                        } else if (textElement._) {\n                            // Content in _ property\n                            text += textElement._;\n                        } else if (textElement.$ && textElement.$.val) {\n                            // Content in attribute\n                            text += textElement.$.val;\n                        } else {\n                            // Try to find any text content\n                            console.log(\"\\uD83D\\uDD0D Text element structure:\", textElement);\n                            const textKeys = Object.keys(textElement);\n                            for (const key of textKeys){\n                                if (key !== \"$\" && typeof textElement[key] === \"string\") {\n                                    text += textElement[key];\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                text += \"\\n\";\n            }\n            console.log(\"\\uD83D\\uDD0D Final extracted text:\", text);\n            return text.trim();\n        } catch (error) {\n            console.error(\"Error extracting text content:\", error);\n            return \"\";\n        }\n    }\n    async extractImage(shape, zip, slideRelsPath) {\n        try {\n            // Check if this is a picture shape\n            const nvPicPr = this.findElement(shape, \"p:nvPicPr\");\n            if (!nvPicPr) {\n                return null // Not a picture shape\n                ;\n            }\n            // Get the picture properties\n            const picPr = this.findElement(shape, \"p:picPr\");\n            if (!picPr) {\n                return null;\n            }\n            // Find the image reference\n            const blipFill = this.findElement(picPr, \"a:blipFill\");\n            if (!blipFill) {\n                return null;\n            }\n            const blip = this.findElement(blipFill, \"a:blip\");\n            if (!blip) {\n                return null;\n            }\n            // Get the relationship ID for the image\n            const rId = this.getAttribute(blip, \"r:embed\");\n            if (!rId) {\n                console.log(\"‚ùå No r:embed found for image\");\n                return null;\n            }\n            console.log(`üîç Found image with rId: ${rId}`);\n            // Find the image file path from relationships\n            const slideRelsXml = await zip.file(slideRelsPath)?.async(\"text\");\n            if (slideRelsXml) {\n                const relsData = await this.parseXML(slideRelsXml);\n                const relationships = this.findElements(relsData.Relationships, \"Relationship\");\n                for (const rel of relationships){\n                    const relId = this.getAttribute(rel, \"Id\");\n                    if (relId === rId) {\n                        const target = this.getAttribute(rel, \"Target\");\n                        if (target) {\n                            const imagePath = `ppt/${target}`;\n                            console.log(`üîç Found image file: ${imagePath}`);\n                            // Check if the image file exists\n                            const imageFile = zip.file(imagePath);\n                            if (imageFile) {\n                                // Get image data as base64\n                                const imageData = await imageFile.async(\"base64\");\n                                const imageType = this.getImageMimeType(imagePath);\n                                return {\n                                    id: this.generateId(),\n                                    type: \"image\",\n                                    name: \"Image\",\n                                    src: `data:${imageType};base64,${imageData}`,\n                                    rawData: shape\n                                };\n                            }\n                        }\n                        break;\n                    }\n                }\n            }\n            return null;\n        } catch (error) {\n            console.error(\"Error extracting image:\", error);\n            return null;\n        }\n    }\n    getImageMimeType(filePath) {\n        const extension = filePath.split(\".\").pop()?.toLowerCase();\n        switch(extension){\n            case \"jpg\":\n            case \"jpeg\":\n                return \"image/jpeg\";\n            case \"png\":\n                return \"image/png\";\n            case \"gif\":\n                return \"image/gif\";\n            case \"bmp\":\n                return \"image/bmp\";\n            case \"tiff\":\n                return \"image/tiff\";\n            default:\n                return \"image/jpeg\" // Default fallback\n                ;\n        }\n    }\n    async readPresentationProps(zip) {\n        try {\n            const coreProps = zip.file(\"docProps/core.xml\");\n            if (coreProps) {\n                const content = await coreProps.async(\"text\");\n                // Parse XML content here if needed\n                return {\n                    author: \"Unknown\",\n                    created: new Date().toISOString(),\n                    modified: new Date().toISOString()\n                };\n            }\n        } catch (error) {\n            console.error(\"Error reading presentation properties:\", error);\n        }\n        return {};\n    }\n    generateId() {\n        return crypto.randomUUID();\n    }\n    async parseXML(xmlString) {\n        return new Promise((resolve, reject)=>{\n            (0,xml2js__WEBPACK_IMPORTED_MODULE_2__.parseString)(xmlString, {\n                explicitArray: false\n            }, (err, result)=>{\n                if (err) reject(err);\n                else resolve(result);\n            });\n        });\n    }\n    findElement(data, tagName) {\n        try {\n            const parts = tagName.split(\":\");\n            if (parts.length === 2) {\n                const namespace = parts[0];\n                const element = parts[1];\n                const fullTag = `${namespace}:${element}`;\n                // Try different approaches to find the element\n                if (data[fullTag]) {\n                    console.log(`‚úÖ Found element ${fullTag} directly`);\n                    return data[fullTag];\n                }\n                if (data[element]) {\n                    console.log(`‚úÖ Found element ${element} without namespace`);\n                    return data[element];\n                }\n                // Check if it's nested in a different structure\n                for(const key in data){\n                    if (key.includes(element) || key.includes(namespace)) {\n                        console.log(`üîç Potential match found: ${key}`);\n                    }\n                }\n                console.log(`‚ùå Element ${fullTag} not found in data keys:`, Object.keys(data));\n                return undefined;\n            }\n            // For non-namespaced elements, try direct access\n            if (data[tagName]) {\n                console.log(`‚úÖ Found element ${tagName} directly`);\n                return data[tagName];\n            }\n            console.log(`‚ùå Element ${tagName} not found in data keys:`, Object.keys(data));\n            return undefined;\n        } catch (error) {\n            console.error(`Error in findElement for ${tagName}:`, error);\n            return undefined;\n        }\n    }\n    findElements(data, tagName) {\n        const element = this.findElement(data, tagName);\n        if (!element) {\n            console.log(`‚ùå No elements found for ${tagName}`);\n            return [];\n        }\n        return Array.isArray(element) ? element : [\n            element\n        ];\n    }\n    getAttribute(element, attrName) {\n        try {\n            if (!element || !element.$) {\n                console.log(`‚ùå Element or attributes not found for ${attrName}:`, element);\n                return null;\n            }\n            const value = element.$[attrName];\n            console.log(`üîç Attribute ${attrName}:`, value);\n            return value || null;\n        } catch (error) {\n            console.error(`Error getting attribute ${attrName}:`, error);\n            return null;\n        }\n    }\n    constructor(){\n        this.parsedPresentations = new Map();\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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ZnREIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1lZGl0b3IvLi9zcmMvYXBwL2FwaS9wcHR4L3BhcnNlL3JvdXRlLnRzPzBmNDciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dFJlcXVlc3QsIE5leHRSZXNwb25zZSB9IGZyb20gJ25leHQvc2VydmVyJ1xyXG5pbXBvcnQgSlNaaXAgZnJvbSAnanN6aXAnXHJcbmltcG9ydCB7IHBhcnNlU3RyaW5nIH0gZnJvbSAneG1sMmpzJ1xyXG5cclxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIFBPU1QocmVxdWVzdDogTmV4dFJlcXVlc3QpIHtcclxuICB0cnkge1xyXG4gICAgY29uc3QgZm9ybURhdGEgPSBhd2FpdCByZXF1ZXN0LmZvcm1EYXRhKClcclxuICAgIGNvbnN0IGZpbGUgPSBmb3JtRGF0YS5nZXQoJ2ZpbGUnKSBhcyBGaWxlXHJcbiAgICBcclxuICAgIGlmICghZmlsZSkge1xyXG4gICAgICByZXR1cm4gTmV4dFJlc3BvbnNlLmpzb24oXHJcbiAgICAgICAgeyBlcnJvcjogJ05vIGZpbGUgcHJvdmlkZWQnIH0sXHJcbiAgICAgICAgeyBzdGF0dXM6IDQwMCB9XHJcbiAgICAgIClcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZygn8J+TgSBQcm9jZXNzaW5nIGZpbGU6JywgZmlsZS5uYW1lKVxyXG4gICAgXHJcbiAgICAvLyBDb252ZXJ0IEZpbGUgdG8gQnVmZmVyXHJcbiAgICBjb25zdCBhcnJheUJ1ZmZlciA9IGF3YWl0IGZpbGUuYXJyYXlCdWZmZXIoKVxyXG4gICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmZyb20oYXJyYXlCdWZmZXIpXHJcbiAgICBcclxuICAgIC8vIFBhcnNlIHRoZSBQUFRYIGZpbGVcclxuICAgIGNvbnN0IHBwdHhTZXJ2aWNlID0gbmV3IFBQVFhTZXJ2aWNlKClcclxuICAgIGNvbnN0IHByZXNlbnRhdGlvbiA9IGF3YWl0IHBwdHhTZXJ2aWNlLnBhcnNlUFBUWChidWZmZXIpXHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCfinIUgUGFyc2luZyBjb21wbGV0ZWQgc3VjY2Vzc2Z1bGx5JylcclxuICAgIHJldHVybiBOZXh0UmVzcG9uc2UuanNvbihwcmVzZW50YXRpb24pXHJcbiAgICBcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIHBhcnNpbmcgUFBUWCBmaWxlOicsIGVycm9yKVxyXG4gICAgcmV0dXJuIE5leHRSZXNwb25zZS5qc29uKFxyXG4gICAgICB7IGVycm9yOiAnRmFpbGVkIHRvIHBhcnNlIFBQVFggZmlsZScgfSxcclxuICAgICAgeyBzdGF0dXM6IDUwMCB9XHJcbiAgICApXHJcbiAgfVxyXG59XHJcblxyXG4vLyBQUFRYIFNlcnZpY2UgY2xhc3MgKG1vdmVkIGZyb20gYmFja2VuZClcclxuY2xhc3MgUFBUWFNlcnZpY2Uge1xyXG4gIHByaXZhdGUgcGFyc2VkUHJlc2VudGF0aW9uczogTWFwPHN0cmluZywgYW55PiA9IG5ldyBNYXAoKVxyXG5cclxuICBhc3luYyBwYXJzZVBQVFgoYnVmZmVyOiBCdWZmZXIpOiBQcm9taXNlPGFueT4ge1xyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgemlwID0gYXdhaXQgSlNaaXAubG9hZEFzeW5jKGJ1ZmZlcilcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHNsaWRlcyA9IGF3YWl0IHRoaXMucmVhZFNsaWRlcyh6aXApXHJcbiAgICAgIGNvbnN0IHByb3BlcnRpZXMgPSBhd2FpdCB0aGlzLnJlYWRQcmVzZW50YXRpb25Qcm9wcyh6aXApXHJcblxyXG4gICAgICBjb25zdCBwcmVzZW50YXRpb24gPSB7XHJcbiAgICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVJZCgpLFxyXG4gICAgICAgIG5hbWU6ICdJbXBvcnRlZCBQcmVzZW50YXRpb24nLFxyXG4gICAgICAgIHNsaWRlcyxcclxuICAgICAgICBtZXRhZGF0YTogcHJvcGVydGllcyxcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgdGhpcy5wYXJzZWRQcmVzZW50YXRpb25zLnNldChwcmVzZW50YXRpb24uaWQsIHByZXNlbnRhdGlvbilcclxuICAgICAgY29uc29sZS5sb2coJ+KchSBQYXJzaW5nIGNvbXBsZXRlZCBzdWNjZXNzZnVsbHknKVxyXG4gICAgICByZXR1cm4gcHJlc2VudGF0aW9uXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgcGFyc2luZyBQUFRYIGZpbGU6JywgZXJyb3IpICAgICAgIFxyXG4gICAgICB0aHJvdyBlcnJvclxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZ2V0U2xpZGUoc2xpZGVJZDogc3RyaW5nKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XHJcbiAgICBjb25zdCBwcmVzZW50YXRpb25zID0gQXJyYXkuZnJvbSh0aGlzLnBhcnNlZFByZXNlbnRhdGlvbnMudmFsdWVzKCkpXHJcbiAgICBmb3IgKGNvbnN0IHByZXNlbnRhdGlvbiBvZiBwcmVzZW50YXRpb25zKSB7XHJcbiAgICAgIGNvbnN0IHNsaWRlID0gcHJlc2VudGF0aW9uLnNsaWRlcy5maW5kKChzOiBhbnkpID0+IHMuaWQgPT09IHNsaWRlSWQpXHJcbiAgICAgIGlmIChzbGlkZSkgcmV0dXJuIHNsaWRlXHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbFxyXG4gIH1cclxuXHJcbiAgYXN5bmMgZXhwb3J0UFBUWChwcmVzZW50YXRpb25EYXRhOiBhbnkpOiBQcm9taXNlPEJ1ZmZlcj4ge1xyXG4gICAgLy8gUGxhY2Vob2xkZXIgZm9yIGV4cG9ydCBsb2dpY1xyXG4gICAgY29uc29sZS5sb2coJ/CfmqcgRXhwb3J0aW5nIFBQVFggKHBsYWNlaG9sZGVyKScpXHJcbiAgICBjb25zdCB6aXAgPSBuZXcgSlNaaXAoKVxyXG4gICAgemlwLmZpbGUoXCJkb2MudHh0XCIsIEpTT04uc3RyaW5naWZ5KHByZXNlbnRhdGlvbkRhdGEsIG51bGwsIDIpKVxyXG4gICAgY29uc3QgY29udGVudCA9IGF3YWl0IHppcC5nZW5lcmF0ZUFzeW5jKHsgdHlwZTogXCJub2RlYnVmZmVyXCIgfSlcclxuICAgIHJldHVybiBjb250ZW50XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHJlYWRTbGlkZXMoemlwOiBKU1ppcCk6IFByb21pc2U8YW55W10+IHtcclxuICAgIGNvbnN0IHNsaWRlczogYW55W10gPSBbXVxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc3QgcHJlc2VudGF0aW9uWG1sID0gYXdhaXQgemlwLmZpbGUoJ3BwdC9wcmVzZW50YXRpb24ueG1sJyk/LmFzeW5jKCd0ZXh0JylcclxuICAgICAgaWYgKCFwcmVzZW50YXRpb25YbWwpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ05vIHByZXNlbnRhdGlvbi54bWwgZm91bmQuJylcclxuICAgICAgICByZXR1cm4gW11cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coJ/Cfk4QgRm91bmQgcHJlc2VudGF0aW9uLnhtbCwgbGVuZ3RoOicsIHByZXNlbnRhdGlvblhtbC5sZW5ndGgpXHJcbiAgICAgIFxyXG4gICAgICAvLyBQYXJzZSBYTUwgdXNpbmcgeG1sMmpzXHJcbiAgICAgIGNvbnN0IHByZXNlbnRhdGlvbkRhdGEgPSBhd2FpdCB0aGlzLnBhcnNlWE1MKHByZXNlbnRhdGlvblhtbClcclxuICAgICAgY29uc29sZS5sb2coJ/CflI0gUGFyc2VkIHByZXNlbnRhdGlvbiBkYXRhOicsIEpTT04uc3RyaW5naWZ5KHByZXNlbnRhdGlvbkRhdGEsIG51bGwsIDIpKVxyXG4gICAgICBcclxuICAgICAgLy8gTmF2aWdhdGUgdG8gdGhlIHByZXNlbnRhdGlvbiBlbGVtZW50IGZpcnN0XHJcbiAgICAgIGNvbnN0IHByZXNlbnRhdGlvbiA9IHRoaXMuZmluZEVsZW1lbnQocHJlc2VudGF0aW9uRGF0YSwgJ3A6cHJlc2VudGF0aW9uJylcclxuICAgICAgaWYgKCFwcmVzZW50YXRpb24pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ+KdjCBObyBwcmVzZW50YXRpb24gZWxlbWVudCBmb3VuZCcpXHJcbiAgICAgICAgcmV0dXJuIFtdXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHNsZElkTGlzdCA9IHRoaXMuZmluZEVsZW1lbnQocHJlc2VudGF0aW9uLCAncDpzbGRJZExzdCcpXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5OLIEZvdW5kIHNsZElkTGlzdDonLCBzbGRJZExpc3QpXHJcbiAgICAgIFxyXG4gICAgICBpZiAoc2xkSWRMaXN0KSB7XHJcbiAgICAgICAgY29uc3Qgc2xkSWRzID0gdGhpcy5maW5kRWxlbWVudHMoc2xkSWRMaXN0LCAncDpzbGRJZCcpXHJcbiAgICAgICAgY29uc29sZS5sb2coYPCflKIgRm91bmQgJHtzbGRJZHMubGVuZ3RofSBzbGlkZSBJRHM6YCwgc2xkSWRzKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc2xkSWRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICBjb25zdCBzbGRJZCA9IHNsZElkc1tpXVxyXG4gICAgICAgICAgY29uc3QgcklkID0gdGhpcy5nZXRBdHRyaWJ1dGUoc2xkSWQsICdyOmlkJylcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5OdIFNsaWRlICR7aSArIDF9IGhhcyBySWQ6YCwgcklkKVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAocklkKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHJlbHNYbWwgPSBhd2FpdCB6aXAuZmlsZSgncHB0L19yZWxzL3ByZXNlbnRhdGlvbi54bWwucmVscycpPy5hc3luYygndGV4dCcpXHJcbiAgICAgICAgICAgIGlmIChyZWxzWG1sKSB7XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflJcgRm91bmQgcmVsYXRpb25zaGlwcyBmaWxlLCBsZW5ndGg6JywgcmVsc1htbC5sZW5ndGgpXHJcbiAgICAgICAgICAgICAgY29uc3QgcmVsc0RhdGEgPSBhd2FpdCB0aGlzLnBhcnNlWE1MKHJlbHNYbWwpXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflJcgUGFyc2VkIHJlbGF0aW9uc2hpcHMgZGF0YTonLCBKU09OLnN0cmluZ2lmeShyZWxzRGF0YSwgbnVsbCwgMikpXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gRmluZCB0aGUgcmVsYXRpb25zaGlwIHRoYXQgbWF0Y2hlcyB0aGlzIHNsaWRlJ3MgcklkXHJcbiAgICAgICAgICAgICAgY29uc3QgcmVsYXRpb25zaGlwcyA9IHRoaXMuZmluZEVsZW1lbnRzKHJlbHNEYXRhLlJlbGF0aW9uc2hpcHMsICdSZWxhdGlvbnNoaXAnKVxyXG4gICAgICAgICAgICAgIGxldCB0YXJnZXQgPSBudWxsXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCflI0gTG9va2luZyBmb3IgcmVsYXRpb25zaGlwIHdpdGggSWQ6ICR7cklkfWApXHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCflI0gRm91bmQgJHtyZWxhdGlvbnNoaXBzLmxlbmd0aH0gcmVsYXRpb25zaGlwczpgLCByZWxhdGlvbnNoaXBzKVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGZvciAoY29uc3QgcmVsIG9mIHJlbGF0aW9uc2hpcHMpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHJlbElkID0gdGhpcy5nZXRBdHRyaWJ1dGUocmVsLCAnSWQnKVxyXG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coYPCflI0gQ2hlY2tpbmcgcmVsYXRpb25zaGlwIElkOiAke3JlbElkfWApXHJcbiAgICAgICAgICAgICAgICBcclxuICAgICAgICAgICAgICAgIGlmIChyZWxJZCA9PT0gcklkKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRhcmdldCA9IHRoaXMuZ2V0QXR0cmlidXRlKHJlbCwgJ1RhcmdldCcpXHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgbWF0Y2hpbmcgcmVsYXRpb25zaGlwISBUYXJnZXQ6ICR7dGFyZ2V0fWApXHJcbiAgICAgICAgICAgICAgICAgIGJyZWFrXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn46vIEZpbmFsIHJlbGF0aW9uc2hpcCB0YXJnZXQ6JywgdGFyZ2V0KVxyXG4gICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGNvbnN0IHNsaWRlRmlsZVBhdGggPSBgcHB0LyR7dGFyZ2V0fWBcclxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKCfwn5OBIFNsaWRlIGZpbGUgcGF0aDonLCBzbGlkZUZpbGVQYXRoKVxyXG4gICAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgICBjb25zdCBzbGlkZSA9IGF3YWl0IHRoaXMucGFyc2VTbGlkZSh6aXAsIHNsaWRlRmlsZVBhdGgsIGkgKyAxKVxyXG4gICAgICAgICAgICAgICAgaWYgKHNsaWRlKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgU3VjY2Vzc2Z1bGx5IHBhcnNlZCBzbGlkZSAke2kgKyAxfTpgLCBzbGlkZSlcclxuICAgICAgICAgICAgICAgICAgc2xpZGVzLnB1c2goc2xpZGUpXHJcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYOKdjCBGYWlsZWQgdG8gcGFyc2Ugc2xpZGUgJHtpICsgMX1gKVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ+KdjCBObyByZWxhdGlvbnNoaXBzIGZpbGUgZm91bmQnKVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybign4p2MIE5vIHNsZElkTGlzdCBmb3VuZCBpbiBwcmVzZW50YXRpb24gZGF0YScpXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciByZWFkaW5nIHNsaWRlczonLCBlcnJvcilcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYPCfk4ogVG90YWwgc2xpZGVzIGxvYWRlZDogJHtzbGlkZXMubGVuZ3RofWApXHJcbiAgICByZXR1cm4gc2xpZGVzXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHBhcnNlU2xpZGUoemlwOiBKU1ppcCwgc2xpZGVGaWxlUGF0aDogc3RyaW5nLCBzbGlkZU51bWJlcjogbnVtYmVyKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBzbGlkZUZpbGUgPSB6aXAuZmlsZShzbGlkZUZpbGVQYXRoKVxyXG4gICAgICBpZiAoIXNsaWRlRmlsZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybihgU2xpZGUgZmlsZSBub3QgZm91bmQ6ICR7c2xpZGVGaWxlUGF0aH1gKVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH1cclxuICAgICAgY29uc3Qgc2xpZGVDb250ZW50ID0gYXdhaXQgc2xpZGVGaWxlLmFzeW5jKCd0ZXh0JylcclxuICAgICAgY29uc29sZS5sb2coYPCfk4QgU2xpZGUgJHtzbGlkZU51bWJlcn0gWE1MIGNvbnRlbnQgbGVuZ3RoOiAke3NsaWRlQ29udGVudC5sZW5ndGh9YClcclxuXHJcbiAgICAgIC8vIFBhcnNlIHRoZSBzbGlkZSBYTUwgY29udGVudFxyXG4gICAgICBjb25zdCBzbGlkZURhdGEgPSBhd2FpdCB0aGlzLnBhcnNlWE1MKHNsaWRlQ29udGVudClcclxuICAgICAgY29uc3Qgb2JqZWN0cyA9IGF3YWl0IHRoaXMuZXh0cmFjdFNsaWRlT2JqZWN0cyhzbGlkZURhdGEsIHppcCwgYHBwdC9zbGlkZXMvX3JlbHMvc2xpZGUke3NsaWRlTnVtYmVyfS54bWwucmVsc2ApXHJcbiAgICAgIFxyXG4gICAgICAvLyBSZXR1cm4gYmFzaWMgc2xpZGUgc3RydWN0dXJlIC0gZnJvbnRlbmQgd2lsbCBoYW5kbGUgcmVuZGVyaW5nXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVJZCgpLFxyXG4gICAgICAgIHNsaWRlTnVtYmVyLFxyXG4gICAgICAgIHdpZHRoOiA4MDAsXHJcbiAgICAgICAgaGVpZ2h0OiA2MDAsXHJcbiAgICAgICAgb2JqZWN0cyxcclxuICAgICAgICAvLyBTdG9yZSByYXcgc2xpZGUgWE1MIGZvciBmcm9udGVuZCBwcm9jZXNzaW5nXHJcbiAgICAgICAgcmF3RGF0YTogc2xpZGVEYXRhXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIHBhcnNpbmcgc2xpZGUgJHtzbGlkZU51bWJlcn06YCwgZXJyb3IpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIGV4dHJhY3RTbGlkZU9iamVjdHMoc2xpZGVEYXRhOiBhbnksIHppcDogSlNaaXAsIHNsaWRlUmVsc1BhdGg6IHN0cmluZyk6IFByb21pc2U8YW55W10+IHtcclxuICAgIGNvbnN0IG9iamVjdHM6IGFueVtdID0gW11cclxuICAgIFxyXG4gICAgdHJ5IHtcclxuICAgICAgY29uc29sZS5sb2coJ/CflI0gRXh0cmFjdGluZyBvYmplY3RzIGZyb20gc2xpZGUgZGF0YScpXHJcbiAgICAgIFxyXG4gICAgICAvLyBOYXZpZ2F0ZSB0aGUgY29ycmVjdCBYTUwgc3RydWN0dXJlOiBwOnNsZCAtPiBwOmNTbGQgLT4gcDpzcFRyZWVcclxuICAgICAgY29uc3Qgc2xpZGUgPSB0aGlzLmZpbmRFbGVtZW50KHNsaWRlRGF0YSwgJ3A6c2xkJylcclxuICAgICAgaWYgKCFzbGlkZSkge1xyXG4gICAgICAgIGNvbnNvbGUud2Fybign4p2MIE5vIHA6c2xkIGZvdW5kIGluIHNsaWRlIGRhdGEnKVxyXG4gICAgICAgIHJldHVybiBvYmplY3RzXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGNTbGQgPSB0aGlzLmZpbmRFbGVtZW50KHNsaWRlLCAncDpjU2xkJylcclxuICAgICAgaWYgKCFjU2xkKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCfinYwgTm8gcDpjU2xkIGZvdW5kIGluIHNsaWRlJylcclxuICAgICAgICByZXR1cm4gb2JqZWN0c1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBGaW5kIHRoZSBzaGFwZSB0cmVlXHJcbiAgICAgIGNvbnN0IHNwVHJlZSA9IHRoaXMuZmluZEVsZW1lbnQoY1NsZCwgJ3A6c3BUcmVlJylcclxuICAgICAgaWYgKCFzcFRyZWUpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oJ+KdjCBObyBzcFRyZWUgZm91bmQgaW4gc2xpZGUnKVxyXG4gICAgICAgIHJldHVybiBvYmplY3RzXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEV4dHJhY3QgYWxsIHNoYXBlcyAoYm90aCBpbmRpdmlkdWFsIGFuZCBncm91cGVkKVxyXG4gICAgICBjb25zdCBhbGxTaGFwZXMgPSBbXHJcbiAgICAgICAgLi4udGhpcy5maW5kRWxlbWVudHMoc3BUcmVlLCAncDpzcCcpLFxyXG4gICAgICAgIC4uLnRoaXMuZmluZEVsZW1lbnRzKHNwVHJlZSwgJ3A6Z3JwU3AnKVxyXG4gICAgICBdXHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhg8J+UtyBGb3VuZCAke2FsbFNoYXBlcy5sZW5ndGh9IHRvdGFsIHNoYXBlcyBpbiBzbGlkZWApXHJcblxyXG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFsbFNoYXBlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIGNvbnN0IHNoYXBlID0gYWxsU2hhcGVzW2ldXHJcbiAgICAgICAgY29uc3Qgc2hhcGVPYmplY3QgPSBhd2FpdCB0aGlzLmV4dHJhY3RCYXNpY1NoYXBlKHNoYXBlLCBpLCB6aXAsIHNsaWRlUmVsc1BhdGgpXHJcbiAgICAgICAgaWYgKHNoYXBlT2JqZWN0KSB7XHJcbiAgICAgICAgICBvYmplY3RzLnB1c2goc2hhcGVPYmplY3QpXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGV4dHJhY3Rpbmcgc2xpZGUgb2JqZWN0czonLCBlcnJvcilcclxuICAgIH1cclxuXHJcbiAgICBjb25zb2xlLmxvZyhg8J+TiiBUb3RhbCBvYmplY3RzIGV4dHJhY3RlZDogJHtvYmplY3RzLmxlbmd0aH1gKVxyXG4gICAgcmV0dXJuIG9iamVjdHNcclxuICB9XHJcblxyXG4gIHByaXZhdGUgYXN5bmMgZXh0cmFjdEJhc2ljU2hhcGUoc2hhcGU6IGFueSwgaW5kZXg6IG51bWJlciwgemlwOiBKU1ppcCwgc2xpZGVSZWxzUGF0aDogc3RyaW5nKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBHZXQgYmFzaWMgc2hhcGUgaW5mb1xyXG4gICAgICBjb25zdCBudlNwUHIgPSB0aGlzLmZpbmRFbGVtZW50KHNoYXBlLCAncDpudlNwUHInKVxyXG4gICAgICBjb25zdCBjTnZQciA9IHRoaXMuZmluZEVsZW1lbnQobnZTcFByLCAncDpjTnZQcicpXHJcbiAgICAgIGNvbnN0IG5hbWUgPSB0aGlzLmdldEF0dHJpYnV0ZShjTnZQciwgJ25hbWUnKSB8fCBgU2hhcGUgJHtpbmRleCArIDF9YFxyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIGdyb3VwXHJcbiAgICAgIGNvbnN0IGlzR3JvdXAgPSBzaGFwZVsncDpncnBTcFByJ10gIT09IHVuZGVmaW5lZFxyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgaWYgaXQncyBhIHBpY3R1cmVcclxuICAgICAgY29uc3QgaXNQaWN0dXJlID0gc2hhcGVbJ3A6bnZQaWNQciddICE9PSB1bmRlZmluZWRcclxuICAgICAgXHJcbiAgICAgIGlmIChpc1BpY3R1cmUpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg8J+UjSBGb3VuZCBwaWN0dXJlIHNoYXBlOiAke25hbWV9YClcclxuICAgICAgICBjb25zdCBpbWFnZU9iamVjdCA9IGF3YWl0IHRoaXMuZXh0cmFjdEltYWdlKHNoYXBlLCB6aXAsIHNsaWRlUmVsc1BhdGgpXHJcbiAgICAgICAgaWYgKGltYWdlT2JqZWN0KSB7XHJcbiAgICAgICAgICByZXR1cm4gaW1hZ2VPYmplY3RcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgdGV4dCBjb250ZW50IGlmIHByZXNlbnRcclxuICAgICAgY29uc3QgdHhCb2R5ID0gdGhpcy5maW5kRWxlbWVudChzaGFwZSwgJ3A6dHhCb2R5JylcclxuICAgICAgbGV0IHRleHRDb250ZW50ID0gJydcclxuICAgICAgaWYgKHR4Qm9keSkge1xyXG4gICAgICAgIHRleHRDb250ZW50ID0gdGhpcy5leHRyYWN0VGV4dENvbnRlbnQodHhCb2R5KVxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBCYXNpYyBzaGFwZSBvYmplY3QgLSBsZXQgZnJvbnRlbmQgaGFuZGxlIHRoZSBkZXRhaWxzXHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVJZCgpLFxyXG4gICAgICAgIHR5cGU6IGlzR3JvdXAgPyAnZ3JvdXAnIDogJ3NoYXBlJyxcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHRleHQ6IHRleHRDb250ZW50LFxyXG4gICAgICAgIC8vIFN0b3JlIHJhdyBYTUwgZGF0YSBmb3IgZnJvbnRlbmQgcHJvY2Vzc2luZ1xyXG4gICAgICAgIHJhd0RhdGE6IHNoYXBlXHJcbiAgICAgIH1cclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGV4dHJhY3RpbmcgYmFzaWMgc2hhcGUgJHtpbmRleH06YCwgZXJyb3IpXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGV4dHJhY3RUZXh0Q29udGVudCh0eEJvZHk6IGFueSk6IHN0cmluZyB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBFeHRyYWN0aW5nIHRleHQgZnJvbSB0eEJvZHk6JywgSlNPTi5zdHJpbmdpZnkodHhCb2R5LCBudWxsLCAyKSlcclxuICAgICAgY29uc29sZS5sb2coJ/CflI0gdHhCb2R5IGtleXM6JywgT2JqZWN0LmtleXModHhCb2R5KSlcclxuICAgICAgXHJcbiAgICAgIGNvbnN0IHBhcmFncmFwaHMgPSB0aGlzLmZpbmRFbGVtZW50cyh0eEJvZHksICdhOnAnKVxyXG4gICAgICBjb25zb2xlLmxvZygn8J+UjSBGb3VuZCBwYXJhZ3JhcGhzOicsIHBhcmFncmFwaHMpXHJcbiAgICAgIGxldCB0ZXh0ID0gJydcclxuICAgICAgXHJcbiAgICAgIGZvciAoY29uc3QgcGFyYWdyYXBoIG9mIHBhcmFncmFwaHMpIHtcclxuICAgICAgICBjb25zdCB0ZXh0UnVucyA9IHRoaXMuZmluZEVsZW1lbnRzKHBhcmFncmFwaCwgJ2E6cicpXHJcbiAgICAgICAgY29uc29sZS5sb2coJ/CflI0gRm91bmQgdGV4dCBydW5zOicsIHRleHRSdW5zKVxyXG4gICAgICAgIGZvciAoY29uc3QgdGV4dFJ1biBvZiB0ZXh0UnVucykge1xyXG4gICAgICAgICAgY29uc3QgdGV4dEVsZW1lbnQgPSB0aGlzLmZpbmRFbGVtZW50KHRleHRSdW4sICdhOnQnKVxyXG4gICAgICAgICAgY29uc29sZS5sb2coJ/CflI0gRm91bmQgdGV4dCBlbGVtZW50OicsIHRleHRFbGVtZW50KVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICAvLyBIYW5kbGUgZGlmZmVyZW50IHRleHQgY29udGVudCBmb3JtYXRzIGZyb20geG1sMmpzXHJcbiAgICAgICAgICBpZiAodGV4dEVsZW1lbnQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0ZXh0RWxlbWVudCA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAvLyBEaXJlY3Qgc3RyaW5nIGNvbnRlbnRcclxuICAgICAgICAgICAgICB0ZXh0ICs9IHRleHRFbGVtZW50XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodGV4dEVsZW1lbnQuXykge1xyXG4gICAgICAgICAgICAgIC8vIENvbnRlbnQgaW4gXyBwcm9wZXJ0eVxyXG4gICAgICAgICAgICAgIHRleHQgKz0gdGV4dEVsZW1lbnQuX1xyXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHRleHRFbGVtZW50LiQgJiYgdGV4dEVsZW1lbnQuJC52YWwpIHtcclxuICAgICAgICAgICAgICAvLyBDb250ZW50IGluIGF0dHJpYnV0ZVxyXG4gICAgICAgICAgICAgIHRleHQgKz0gdGV4dEVsZW1lbnQuJC52YWxcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAvLyBUcnkgdG8gZmluZCBhbnkgdGV4dCBjb250ZW50XHJcbiAgICAgICAgICAgICAgY29uc29sZS5sb2coJ/CflI0gVGV4dCBlbGVtZW50IHN0cnVjdHVyZTonLCB0ZXh0RWxlbWVudClcclxuICAgICAgICAgICAgICBjb25zdCB0ZXh0S2V5cyA9IE9iamVjdC5rZXlzKHRleHRFbGVtZW50KVxyXG4gICAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIHRleHRLZXlzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoa2V5ICE9PSAnJCcgJiYgdHlwZW9mIHRleHRFbGVtZW50W2tleV0gPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgIHRleHQgKz0gdGV4dEVsZW1lbnRba2V5XVxyXG4gICAgICAgICAgICAgICAgICBicmVha1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0ZXh0ICs9ICdcXG4nXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnNvbGUubG9nKCfwn5SNIEZpbmFsIGV4dHJhY3RlZCB0ZXh0OicsIHRleHQpXHJcbiAgICAgIHJldHVybiB0ZXh0LnRyaW0oKVxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZXh0cmFjdGluZyB0ZXh0IGNvbnRlbnQ6JywgZXJyb3IpXHJcbiAgICAgIHJldHVybiAnJ1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBhc3luYyBleHRyYWN0SW1hZ2Uoc2hhcGU6IGFueSwgemlwOiBKU1ppcCwgc2xpZGVSZWxzUGF0aDogc3RyaW5nKTogUHJvbWlzZTxhbnkgfCBudWxsPiB7XHJcbiAgICB0cnkge1xyXG4gICAgICAvLyBDaGVjayBpZiB0aGlzIGlzIGEgcGljdHVyZSBzaGFwZVxyXG4gICAgICBjb25zdCBudlBpY1ByID0gdGhpcy5maW5kRWxlbWVudChzaGFwZSwgJ3A6bnZQaWNQcicpXHJcbiAgICAgIGlmICghbnZQaWNQcikge1xyXG4gICAgICAgIHJldHVybiBudWxsIC8vIE5vdCBhIHBpY3R1cmUgc2hhcGVcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gR2V0IHRoZSBwaWN0dXJlIHByb3BlcnRpZXNcclxuICAgICAgY29uc3QgcGljUHIgPSB0aGlzLmZpbmRFbGVtZW50KHNoYXBlLCAncDpwaWNQcicpXHJcbiAgICAgIGlmICghcGljUHIpIHtcclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGaW5kIHRoZSBpbWFnZSByZWZlcmVuY2VcclxuICAgICAgY29uc3QgYmxpcEZpbGwgPSB0aGlzLmZpbmRFbGVtZW50KHBpY1ByLCAnYTpibGlwRmlsbCcpXHJcbiAgICAgIGlmICghYmxpcEZpbGwpIHtcclxuICAgICAgICByZXR1cm4gbnVsbFxyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBibGlwID0gdGhpcy5maW5kRWxlbWVudChibGlwRmlsbCwgJ2E6YmxpcCcpXHJcbiAgICAgIGlmICghYmxpcCkge1xyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIEdldCB0aGUgcmVsYXRpb25zaGlwIElEIGZvciB0aGUgaW1hZ2VcclxuICAgICAgY29uc3QgcklkID0gdGhpcy5nZXRBdHRyaWJ1dGUoYmxpcCwgJ3I6ZW1iZWQnKVxyXG4gICAgICBpZiAoIXJJZCkge1xyXG4gICAgICAgIGNvbnNvbGUubG9nKCfinYwgTm8gcjplbWJlZCBmb3VuZCBmb3IgaW1hZ2UnKVxyXG4gICAgICAgIHJldHVybiBudWxsXHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEZvdW5kIGltYWdlIHdpdGggcklkOiAke3JJZH1gKVxyXG5cclxuICAgICAgLy8gRmluZCB0aGUgaW1hZ2UgZmlsZSBwYXRoIGZyb20gcmVsYXRpb25zaGlwc1xyXG4gICAgICBjb25zdCBzbGlkZVJlbHNYbWwgPSBhd2FpdCB6aXAuZmlsZShzbGlkZVJlbHNQYXRoKT8uYXN5bmMoJ3RleHQnKVxyXG4gICAgICBcclxuICAgICAgaWYgKHNsaWRlUmVsc1htbCkge1xyXG4gICAgICAgIGNvbnN0IHJlbHNEYXRhID0gYXdhaXQgdGhpcy5wYXJzZVhNTChzbGlkZVJlbHNYbWwpXHJcbiAgICAgICAgY29uc3QgcmVsYXRpb25zaGlwcyA9IHRoaXMuZmluZEVsZW1lbnRzKHJlbHNEYXRhLlJlbGF0aW9uc2hpcHMsICdSZWxhdGlvbnNoaXAnKVxyXG4gICAgICAgIFxyXG4gICAgICAgIGZvciAoY29uc3QgcmVsIG9mIHJlbGF0aW9uc2hpcHMpIHtcclxuICAgICAgICAgIGNvbnN0IHJlbElkID0gdGhpcy5nZXRBdHRyaWJ1dGUocmVsLCAnSWQnKVxyXG4gICAgICAgICAgaWYgKHJlbElkID09PSBySWQpIHtcclxuICAgICAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy5nZXRBdHRyaWJ1dGUocmVsLCAnVGFyZ2V0JylcclxuICAgICAgICAgICAgaWYgKHRhcmdldCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGltYWdlUGF0aCA9IGBwcHQvJHt0YXJnZXR9YFxyXG4gICAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEZvdW5kIGltYWdlIGZpbGU6ICR7aW1hZ2VQYXRofWApXHJcbiAgICAgICAgICAgICAgXHJcbiAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGltYWdlIGZpbGUgZXhpc3RzXHJcbiAgICAgICAgICAgICAgY29uc3QgaW1hZ2VGaWxlID0gemlwLmZpbGUoaW1hZ2VQYXRoKVxyXG4gICAgICAgICAgICAgIGlmIChpbWFnZUZpbGUpIHtcclxuICAgICAgICAgICAgICAgIC8vIEdldCBpbWFnZSBkYXRhIGFzIGJhc2U2NFxyXG4gICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VEYXRhID0gYXdhaXQgaW1hZ2VGaWxlLmFzeW5jKCdiYXNlNjQnKVxyXG4gICAgICAgICAgICAgICAgY29uc3QgaW1hZ2VUeXBlID0gdGhpcy5nZXRJbWFnZU1pbWVUeXBlKGltYWdlUGF0aClcclxuICAgICAgICAgICAgICAgIFxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgICAgaWQ6IHRoaXMuZ2VuZXJhdGVJZCgpLFxyXG4gICAgICAgICAgICAgICAgICB0eXBlOiAnaW1hZ2UnLFxyXG4gICAgICAgICAgICAgICAgICBuYW1lOiAnSW1hZ2UnLFxyXG4gICAgICAgICAgICAgICAgICBzcmM6IGBkYXRhOiR7aW1hZ2VUeXBlfTtiYXNlNjQsJHtpbWFnZURhdGF9YCxcclxuICAgICAgICAgICAgICAgICAgcmF3RGF0YTogc2hhcGVcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYnJlYWtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBudWxsXHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBleHRyYWN0aW5nIGltYWdlOicsIGVycm9yKVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBnZXRJbWFnZU1pbWVUeXBlKGZpbGVQYXRoOiBzdHJpbmcpOiBzdHJpbmcge1xyXG4gICAgY29uc3QgZXh0ZW5zaW9uID0gZmlsZVBhdGguc3BsaXQoJy4nKS5wb3AoKT8udG9Mb3dlckNhc2UoKVxyXG4gICAgc3dpdGNoIChleHRlbnNpb24pIHtcclxuICAgICAgY2FzZSAnanBnJzpcclxuICAgICAgY2FzZSAnanBlZyc6XHJcbiAgICAgICAgcmV0dXJuICdpbWFnZS9qcGVnJ1xyXG4gICAgICBjYXNlICdwbmcnOlxyXG4gICAgICAgIHJldHVybiAnaW1hZ2UvcG5nJ1xyXG4gICAgICBjYXNlICdnaWYnOlxyXG4gICAgICAgIHJldHVybiAnaW1hZ2UvZ2lmJ1xyXG4gICAgICBjYXNlICdibXAnOlxyXG4gICAgICAgIHJldHVybiAnaW1hZ2UvYm1wJ1xyXG4gICAgICBjYXNlICd0aWZmJzpcclxuICAgICAgICByZXR1cm4gJ2ltYWdlL3RpZmYnXHJcbiAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgcmV0dXJuICdpbWFnZS9qcGVnJyAvLyBEZWZhdWx0IGZhbGxiYWNrXHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHJlYWRQcmVzZW50YXRpb25Qcm9wcyh6aXA6IEpTWmlwKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIHRyeSB7XHJcbiAgICAgIGNvbnN0IGNvcmVQcm9wcyA9IHppcC5maWxlKCdkb2NQcm9wcy9jb3JlLnhtbCcpXHJcbiAgICAgIGlmIChjb3JlUHJvcHMpIHtcclxuICAgICAgICBjb25zdCBjb250ZW50ID0gYXdhaXQgY29yZVByb3BzLmFzeW5jKCd0ZXh0JylcclxuICAgICAgICAvLyBQYXJzZSBYTUwgY29udGVudCBoZXJlIGlmIG5lZWRlZFxyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICBhdXRob3I6ICdVbmtub3duJyxcclxuICAgICAgICAgIGNyZWF0ZWQ6IG5ldyBEYXRlKCkudG9JU09TdHJpbmcoKSxcclxuICAgICAgICAgIG1vZGlmaWVkOiBuZXcgRGF0ZSgpLnRvSVNPU3RyaW5nKCksXHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWFkaW5nIHByZXNlbnRhdGlvbiBwcm9wZXJ0aWVzOicsIGVycm9yKVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHt9XHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGdlbmVyYXRlSWQoKTogc3RyaW5nIHtcclxuICAgIHJldHVybiBjcnlwdG8ucmFuZG9tVVVJRCgpXHJcbiAgfVxyXG5cclxuICBwcml2YXRlIGFzeW5jIHBhcnNlWE1MKHhtbFN0cmluZzogc3RyaW5nKTogUHJvbWlzZTxhbnk+IHtcclxuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIHBhcnNlU3RyaW5nKHhtbFN0cmluZywgeyBleHBsaWNpdEFycmF5OiBmYWxzZSB9LCAoZXJyLCByZXN1bHQpID0+IHtcclxuICAgICAgICBpZiAoZXJyKSByZWplY3QoZXJyKVxyXG4gICAgICAgIGVsc2UgcmVzb2x2ZShyZXN1bHQpXHJcbiAgICAgIH0pXHJcbiAgICB9KVxyXG4gIH1cclxuXHJcbiAgcHJpdmF0ZSBmaW5kRWxlbWVudChkYXRhOiBhbnksIHRhZ05hbWU6IHN0cmluZyk6IGFueSB7XHJcbiAgICB0cnkge1xyXG4gICAgICBjb25zdCBwYXJ0cyA9IHRhZ05hbWUuc3BsaXQoJzonKVxyXG4gICAgICBpZiAocGFydHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgY29uc3QgbmFtZXNwYWNlID0gcGFydHNbMF1cclxuICAgICAgICBjb25zdCBlbGVtZW50ID0gcGFydHNbMV1cclxuICAgICAgICBjb25zdCBmdWxsVGFnID0gYCR7bmFtZXNwYWNlfToke2VsZW1lbnR9YFxyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIFRyeSBkaWZmZXJlbnQgYXBwcm9hY2hlcyB0byBmaW5kIHRoZSBlbGVtZW50XHJcbiAgICAgICAgaWYgKGRhdGFbZnVsbFRhZ10pIHtcclxuICAgICAgICAgIGNvbnNvbGUubG9nKGDinIUgRm91bmQgZWxlbWVudCAke2Z1bGxUYWd9IGRpcmVjdGx5YClcclxuICAgICAgICAgIHJldHVybiBkYXRhW2Z1bGxUYWddXHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIGlmIChkYXRhW2VsZW1lbnRdKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGVsZW1lbnQgJHtlbGVtZW50fSB3aXRob3V0IG5hbWVzcGFjZWApXHJcbiAgICAgICAgICByZXR1cm4gZGF0YVtlbGVtZW50XVxyXG4gICAgICAgIH1cclxuICAgICAgICBcclxuICAgICAgICAvLyBDaGVjayBpZiBpdCdzIG5lc3RlZCBpbiBhIGRpZmZlcmVudCBzdHJ1Y3R1cmVcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XHJcbiAgICAgICAgICBpZiAoa2V5LmluY2x1ZGVzKGVsZW1lbnQpIHx8IGtleS5pbmNsdWRlcyhuYW1lc3BhY2UpKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUubG9nKGDwn5SNIFBvdGVudGlhbCBtYXRjaCBmb3VuZDogJHtrZXl9YClcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgY29uc29sZS5sb2coYOKdjCBFbGVtZW50ICR7ZnVsbFRhZ30gbm90IGZvdW5kIGluIGRhdGEga2V5czpgLCBPYmplY3Qua2V5cyhkYXRhKSlcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkXHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEZvciBub24tbmFtZXNwYWNlZCBlbGVtZW50cywgdHJ5IGRpcmVjdCBhY2Nlc3NcclxuICAgICAgaWYgKGRhdGFbdGFnTmFtZV0pIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEZvdW5kIGVsZW1lbnQgJHt0YWdOYW1lfSBkaXJlY3RseWApXHJcbiAgICAgICAgcmV0dXJuIGRhdGFbdGFnTmFtZV1cclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYOKdjCBFbGVtZW50ICR7dGFnTmFtZX0gbm90IGZvdW5kIGluIGRhdGEga2V5czpgLCBPYmplY3Qua2V5cyhkYXRhKSlcclxuICAgICAgcmV0dXJuIHVuZGVmaW5lZFxyXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgICAgY29uc29sZS5lcnJvcihgRXJyb3IgaW4gZmluZEVsZW1lbnQgZm9yICR7dGFnTmFtZX06YCwgZXJyb3IpXHJcbiAgICAgIHJldHVybiB1bmRlZmluZWRcclxuICAgIH1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZmluZEVsZW1lbnRzKGRhdGE6IGFueSwgdGFnTmFtZTogc3RyaW5nKTogYW55W10ge1xyXG4gICAgY29uc3QgZWxlbWVudCA9IHRoaXMuZmluZEVsZW1lbnQoZGF0YSwgdGFnTmFtZSlcclxuICAgIGlmICghZWxlbWVudCkge1xyXG4gICAgICBjb25zb2xlLmxvZyhg4p2MIE5vIGVsZW1lbnRzIGZvdW5kIGZvciAke3RhZ05hbWV9YClcclxuICAgICAgcmV0dXJuIFtdXHJcbiAgICB9XHJcbiAgICByZXR1cm4gQXJyYXkuaXNBcnJheShlbGVtZW50KSA/IGVsZW1lbnQgOiBbZWxlbWVudF1cclxuICB9XHJcblxyXG4gIHByaXZhdGUgZ2V0QXR0cmlidXRlKGVsZW1lbnQ6IGFueSwgYXR0ck5hbWU6IHN0cmluZyk6IHN0cmluZyB8IG51bGwge1xyXG4gICAgdHJ5IHtcclxuICAgICAgaWYgKCFlbGVtZW50IHx8ICFlbGVtZW50LiQpIHtcclxuICAgICAgICBjb25zb2xlLmxvZyhg4p2MIEVsZW1lbnQgb3IgYXR0cmlidXRlcyBub3QgZm91bmQgZm9yICR7YXR0ck5hbWV9OmAsIGVsZW1lbnQpXHJcbiAgICAgICAgcmV0dXJuIG51bGxcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QgdmFsdWUgPSBlbGVtZW50LiRbYXR0ck5hbWVdXHJcbiAgICAgIGNvbnNvbGUubG9nKGDwn5SNIEF0dHJpYnV0ZSAke2F0dHJOYW1lfTpgLCB2YWx1ZSlcclxuICAgICAgcmV0dXJuIHZhbHVlIHx8IG51bGxcclxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoYEVycm9yIGdldHRpbmcgYXR0cmlidXRlICR7YXR0ck5hbWV9OmAsIGVycm9yKVxyXG4gICAgICByZXR1cm4gbnVsbFxyXG4gICAgfVxyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiTmV4dFJlc3BvbnNlIiwiSlNaaXAiLCJwYXJzZVN0cmluZyIsIlBPU1QiLCJyZXF1ZXN0IiwiZm9ybURhdGEiLCJmaWxlIiwiZ2V0IiwianNvbiIsImVycm9yIiwic3RhdHVzIiwiY29uc29sZSIsImxvZyIsIm5hbWUiLCJhcnJheUJ1ZmZlciIsImJ1ZmZlciIsIkJ1ZmZlciIsImZyb20iLCJwcHR4U2VydmljZSIsIlBQVFhTZXJ2aWNlIiwicHJlc2VudGF0aW9uIiwicGFyc2VQUFRYIiwiemlwIiwibG9hZEFzeW5jIiwic2xpZGVzIiwicmVhZFNsaWRlcyIsInByb3BlcnRpZXMiLCJyZWFkUHJlc2VudGF0aW9uUHJvcHMiLCJpZCIsImdlbmVyYXRlSWQiLCJtZXRhZGF0YSIsInBhcnNlZFByZXNlbnRhdGlvbnMiLCJzZXQiLCJnZXRTbGlkZSIsInNsaWRlSWQiLCJwcmVzZW50YXRpb25zIiwiQXJyYXkiLCJ2YWx1ZXMiLCJzbGlkZSIsImZpbmQiLCJzIiwiZXhwb3J0UFBUWCIsInByZXNlbnRhdGlvbkRhdGEiLCJKU09OIiwic3RyaW5naWZ5IiwiY29udGVudCIsImdlbmVyYXRlQXN5bmMiLCJ0eXBlIiwicHJlc2VudGF0aW9uWG1sIiwiYXN5bmMiLCJ3YXJuIiwibGVuZ3RoIiwicGFyc2VYTUwiLCJmaW5kRWxlbWVudCIsInNsZElkTGlzdCIsInNsZElkcyIsImZpbmRFbGVtZW50cyIsImkiLCJzbGRJZCIsInJJZCIsImdldEF0dHJpYnV0ZSIsInJlbHNYbWwiLCJyZWxzRGF0YSIsInJlbGF0aW9uc2hpcHMiLCJSZWxhdGlvbnNoaXBzIiwidGFyZ2V0IiwicmVsIiwicmVsSWQiLCJzbGlkZUZpbGVQYXRoIiwicGFyc2VTbGlkZSIsInB1c2giLCJzbGlkZU51bWJlciIsInNsaWRlRmlsZSIsInNsaWRlQ29udGVudCIsInNsaWRlRGF0YSIsIm9iamVjdHMiLCJleHRyYWN0U2xpZGVPYmplY3RzIiwid2lkdGgiLCJoZWlnaHQiLCJyYXdEYXRhIiwic2xpZGVSZWxzUGF0aCIsImNTbGQiLCJzcFRyZWUiLCJhbGxTaGFwZXMiLCJzaGFwZSIsInNoYXBlT2JqZWN0IiwiZXh0cmFjdEJhc2ljU2hhcGUiLCJpbmRleCIsIm52U3BQciIsImNOdlByIiwiaXNHcm91cCIsInVuZGVmaW5lZCIsImlzUGljdHVyZSIsImltYWdlT2JqZWN0IiwiZXh0cmFjdEltYWdlIiwidHhCb2R5IiwidGV4dENvbnRlbnQiLCJleHRyYWN0VGV4dENvbnRlbnQiLCJ0ZXh0IiwiT2JqZWN0Iiwia2V5cyIsInBhcmFncmFwaHMiLCJwYXJhZ3JhcGgiLCJ0ZXh0UnVucyIsInRleHRSdW4iLCJ0ZXh0RWxlbWVudCIsIl8iLCIkIiwidmFsIiwidGV4dEtleXMiLCJrZXkiLCJ0cmltIiwibnZQaWNQciIsInBpY1ByIiwiYmxpcEZpbGwiLCJibGlwIiwic2xpZGVSZWxzWG1sIiwiaW1hZ2VQYXRoIiwiaW1hZ2VGaWxlIiwiaW1hZ2VEYXRhIiwiaW1hZ2VUeXBlIiwiZ2V0SW1hZ2VNaW1lVHlwZSIsInNyYyIsImZpbGVQYXRoIiwiZXh0ZW5zaW9uIiwic3BsaXQiLCJwb3AiLCJ0b0xvd2VyQ2FzZSIsImNvcmVQcm9wcyIsImF1dGhvciIsImNyZWF0ZWQiLCJEYXRlIiwidG9JU09TdHJpbmciLCJtb2RpZmllZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJ4bWxTdHJpbmciLCJQcm9taXNlIiwicmVzb2x2ZSIsInJlamVjdCIsImV4cGxpY2l0QXJyYXkiLCJlcnIiLCJyZXN1bHQiLCJkYXRhIiwidGFnTmFtZSIsInBhcnRzIiwibmFtZXNwYWNlIiwiZWxlbWVudCIsImZ1bGxUYWciLCJpbmNsdWRlcyIsImlzQXJyYXkiLCJhdHRyTmFtZSIsInZhbHVlIiwiTWFwIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./src/app/api/pptx/parse/route.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../../webpack-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next","vendor-chunks/jszip","vendor-chunks/xmlbuilder","vendor-chunks/pako","vendor-chunks/readable-stream","vendor-chunks/xml2js","vendor-chunks/inherits","vendor-chunks/util-deprecate","vendor-chunks/string_decoder","vendor-chunks/sax","vendor-chunks/safe-buffer","vendor-chunks/process-nextick-args","vendor-chunks/lie","vendor-chunks/isarray","vendor-chunks/immediate","vendor-chunks/core-util-is"], () => (__webpack_exec__("(rsc)/./node_modules/next/dist/build/webpack/loaders/next-app-loader.js?name=app%2Fapi%2Fpptx%2Fparse%2Froute&page=%2Fapi%2Fpptx%2Fparse%2Froute&appPaths=&pagePath=private-next-app-dir%2Fapi%2Fpptx%2Fparse%2Froute.ts&appDir=C%3A%5CUsers%5CHP%5Cpptx-editor%5Csrc%5Capp&pageExtensions=tsx&pageExtensions=ts&pageExtensions=jsx&pageExtensions=js&rootDir=C%3A%5CUsers%5CHP%5Cpptx-editor&isDev=true&tsconfigPath=tsconfig.json&basePath=&assetPrefix=&nextConfigOutput=&preferredRegion=&middlewareConfig=e30%3D!")));
module.exports = __webpack_exports__;

})();