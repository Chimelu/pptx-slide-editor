/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/nwsapi";
exports.ids = ["vendor-chunks/nwsapi"];
exports.modules = {

/***/ "(ssr)/./node_modules/nwsapi/src/nwsapi.js":
/*!*******************************************!*\
  !*** ./node_modules/nwsapi/src/nwsapi.js ***!
  \*******************************************/
/***/ (function(module) {

eval("/*\n * Copyright (C) 2007-2025 Diego Perini\n * All rights reserved.\n *\n * nwsapi.js - Fast CSS Selectors API Engine\n *\n * Author: Diego Perini <diego.perini at gmail com>\n * Version: 2.2.21\n * Created: 20070722\n * Release: 20250726\n *\n * License:\n *  https://javascript.nwbox.com/nwsapi/MIT-LICENSE\n * Download:\n *  https://javascript.nwbox.com/nwsapi/nwsapi.js\n */ (function Export(global, factory) {\n    \"use strict\";\n    if (true) {\n        module.exports = factory;\n    } else {}\n})(this, function Factory(global, Export) {\n    var version = \"nwsapi-2.2.21\", doc = global.document, root = doc.documentElement, slice = Array.prototype.slice, HSP = \"[\\\\x20\\\\t]\", VSP = \"[\\\\r\\\\n\\\\f]\", WSP = \"[\\\\x20\\\\t\\\\r\\\\n\\\\f]\", CFG = {\n        // extensions\n        operators: \"[~*^$|]=|=\",\n        combinators: \"[\\\\x20\\\\t>+~](?=[^>+~])\"\n    }, NOT = {\n        // not enclosed in double/single/parens/square\n        double_enc: '(?=(?:[^\"]*[\"][^\"]*[\"])*[^\"]*$)',\n        single_enc: \"(?=(?:[^']*['][^']*['])*[^']*$)\",\n        parens_enc: \"(?![^\\\\x28]*\\\\x29)\",\n        square_enc: \"(?![^\\\\x5b]*\\\\x5d)\"\n    }, REX = {\n        // regular expressions\n        HasEscapes: RegExp(\"\\\\\\\\\"),\n        HexNumbers: RegExp(\"^[0-9a-fA-F]\"),\n        EscOrQuote: RegExp(\"^\\\\\\\\|[\\\\x22\\\\x27]\"),\n        RegExpChar: RegExp(\"(?!\\\\\\\\)[\\\\\\\\^$.,*+?()[\\\\]{}|\\\\/]\", \"g\"),\n        TrimSpaces: RegExp(\"^\" + WSP + \"+|\" + WSP + \"+$|\" + VSP, \"g\"),\n        SplitGroup: RegExp(\"(\\\\([^)]*\\\\)|\\\\[[^[]*\\\\]|\\\\\\\\.|[^,])+\", \"g\"),\n        CommaGroup: RegExp(\"(\\\\s*,\\\\s*)\" + NOT.square_enc + NOT.parens_enc, \"g\"),\n        FixEscapes: RegExp(\"\\\\\\\\([0-9a-fA-F]{1,6}\" + WSP + \"?|.)|([\\\\x22\\\\x27])\", \"g\"),\n        CombineWSP: RegExp(\"[\\\\n\\\\r\\\\f\\\\x20]+\" + NOT.single_enc + NOT.double_enc, \"g\"),\n        TabCharWSP: RegExp(\"(\\\\x20?\\\\t+\\\\x20?)\" + NOT.single_enc + NOT.double_enc, \"g\"),\n        PseudosWSP: RegExp(\"\\\\s+([-+])\\\\s+\" + NOT.square_enc, \"g\")\n    }, STD = {\n        combinator: RegExp(\"\\\\s?([>+~])\\\\s?\", \"g\"),\n        apimethods: RegExp(\"^(?:\\\\w+|\\\\*)\\\\|\"),\n        namespaces: RegExp(\"(\\\\*|\\\\w+)\\\\|[\\\\w-]+\")\n    }, GROUPS = {\n        // pseudo-classes requiring parameters\n        linguistic: \"(dir|lang)(?:\\\\x28\\\\s?([-\\\\w]{2,})\\\\s?\\\\x29)\",\n        logicalsel: \"(is|where|matches|not|has)(?:\\\\x28\\\\s?(\" + \"[^()]*|.*\" + \")\\\\s?\\\\x29)\",\n        treestruct: \"(nth(?:-last)?(?:-child|-of\\\\-type))(?:\\\\x28\\\\s?(even|odd|(?:[-+]?\\\\d*)(?:n\\\\s?[-+]?\\\\s?\\\\d*)?)\\\\s?\\\\x29)\",\n        // pseudo-classes not requiring parameters\n        locationpc: \"(any\\\\-link|link|visited|target|defined)\\\\b\",\n        useraction: \"(hover|active|focus\\\\-within|focus\\\\-visible|focus)\\\\b\",\n        structural: \"(scope|root|empty|(?:(?:first|last|only)(?:-child|\\\\-of\\\\-type)))\\\\b\",\n        inputstate: \"(enabled|disabled|read\\\\-only|read\\\\-write|placeholder\\\\-shown|default)\\\\b\",\n        inputvalue: \"(checked|indeterminate|required|optional|valid|invalid|in\\\\-range|out\\\\-of\\\\-range)\\\\b\",\n        // pseudo-classes not requiring parameters and describing functional state\n        rsrc_state: \"(playing|paused|seeking|buffering|stalled|muted|volume-locked)\\\\b\",\n        disp_state: \"(open|closed|modal|fullscreen|picture-in-picture)\\\\b\",\n        time_state: \"(current|past|future)\\\\b\",\n        // pseudo-classes for parsing only selectors\n        pseudo_nop: \"(autofill|-webkit\\\\-autofill)\\\\b\",\n        // pseudo-elements starting with single colon (:)\n        pseudo_sng: \"(after|before|first\\\\-letter|first\\\\-line)\\\\b\",\n        // pseudo-elements starting with double colon (::)\n        pseudo_dbl: \":(after|before|first\\\\-letter|first\\\\-line|selection|placeholder|-webkit-[-a-zA-Z0-9]{2,})\\\\b\"\n    }, Patterns = {\n        // pseudo-classes\n        treestruct: RegExp(\"^:(?:\" + GROUPS.treestruct + \")(.*)\", \"i\"),\n        structural: RegExp(\"^:(?:\" + GROUPS.structural + \")(.*)\", \"i\"),\n        linguistic: RegExp(\"^:(?:\" + GROUPS.linguistic + \")(.*)\", \"i\"),\n        useraction: RegExp(\"^:(?:\" + GROUPS.useraction + \")(.*)\", \"i\"),\n        inputstate: RegExp(\"^:(?:\" + GROUPS.inputstate + \")(.*)\", \"i\"),\n        inputvalue: RegExp(\"^:(?:\" + GROUPS.inputvalue + \")(.*)\", \"i\"),\n        rsrc_state: RegExp(\"^:(?:\" + GROUPS.rsrc_state + \")(.*)\", \"i\"),\n        disp_state: RegExp(\"^:(?:\" + GROUPS.disp_state + \")(.*)\", \"i\"),\n        time_state: RegExp(\"^:(?:\" + GROUPS.time_state + \")(.*)\", \"i\"),\n        locationpc: RegExp(\"^:(?:\" + GROUPS.locationpc + \")(.*)\", \"i\"),\n        logicalsel: RegExp(\"^:(?:\" + GROUPS.logicalsel + \")(.*)\", \"i\"),\n        pseudo_nop: RegExp(\"^:(?:\" + GROUPS.pseudo_nop + \")(.*)\", \"i\"),\n        pseudo_sng: RegExp(\"^:(?:\" + GROUPS.pseudo_sng + \")(.*)\", \"i\"),\n        pseudo_dbl: RegExp(\"^:(?:\" + GROUPS.pseudo_dbl + \")(.*)\", \"i\"),\n        // combinator symbols\n        children: RegExp(\"^\" + WSP + \"?\\\\>\" + WSP + \"?(.*)\"),\n        adjacent: RegExp(\"^\" + WSP + \"?\\\\+\" + WSP + \"?(.*)\"),\n        relative: RegExp(\"^\" + WSP + \"?\\\\~\" + WSP + \"?(.*)\"),\n        ancestor: RegExp(\"^\" + WSP + \"+(.*)\"),\n        // universal & namespace\n        universal: RegExp(\"^(\\\\*)(.*)\"),\n        namespace: RegExp(\"^(\\\\*|[\\\\w-]+)?\\\\|(.*)\")\n    }, // regexp to better aproximate detection of RTL languages (Arabic)\n    RTL = RegExp(\"^(?:[\\\\u0627-\\\\u064a]|[\\\\u0591-\\\\u08ff]|[\\\\ufb1d-\\\\ufdfd]|[\\\\ufe70-\\\\ufefc])+$\"), // emulate firefox error strings\n    qsNotArgs = \"Not enough arguments\", qsInvalid = \" is not a valid selector\", // detect structural pseudo-classes in selectors\n    reNthElem = RegExp(\"(:nth(?:-last)?-child)\", \"i\"), reNthType = RegExp(\"(:nth(?:-last)?-of-type)\", \"i\"), // placeholder for global regexp\n    reOptimizer, reValidator, // special handling configuration flags\n    Config = {\n        IDS_DUPES: true,\n        ANODELIST: false,\n        LOGERRORS: true,\n        USR_EVENT: true,\n        VERBOSITY: true\n    }, NAMESPACE, QUIRKS_MODE, HTML_DOCUMENT, ATTR_STD_OPS = {\n        \"=\": 1,\n        \"^=\": 1,\n        \"$=\": 1,\n        \"|=\": 1,\n        \"*=\": 1,\n        \"~=\": 1\n    }, HTML_TABLE = {\n        \"accept\": 1,\n        \"accept-charset\": 1,\n        \"align\": 1,\n        \"alink\": 1,\n        \"axis\": 1,\n        \"bgcolor\": 1,\n        \"charset\": 1,\n        \"checked\": 1,\n        \"clear\": 1,\n        \"codetype\": 1,\n        \"color\": 1,\n        \"compact\": 1,\n        \"declare\": 1,\n        \"defer\": 1,\n        \"dir\": 1,\n        \"direction\": 1,\n        \"disabled\": 1,\n        \"enctype\": 1,\n        \"face\": 1,\n        \"frame\": 1,\n        \"hreflang\": 1,\n        \"http-equiv\": 1,\n        \"lang\": 1,\n        \"language\": 1,\n        \"link\": 1,\n        \"media\": 1,\n        \"method\": 1,\n        \"multiple\": 1,\n        \"nohref\": 1,\n        \"noresize\": 1,\n        \"noshade\": 1,\n        \"nowrap\": 1,\n        \"readonly\": 1,\n        \"rel\": 1,\n        \"rev\": 1,\n        \"rules\": 1,\n        \"scope\": 1,\n        \"scrolling\": 1,\n        \"selected\": 1,\n        \"shape\": 1,\n        \"target\": 1,\n        \"text\": 1,\n        \"type\": 1,\n        \"valign\": 1,\n        \"valuetype\": 1,\n        \"vlink\": 1\n    }, Combinators = {}, Selectors = {}, Operators = {\n        \"=\": {\n            p1: \"^\",\n            p2: \"$\",\n            p3: \"true\"\n        },\n        \"^=\": {\n            p1: \"^\",\n            p2: \"\",\n            p3: \"true\"\n        },\n        \"$=\": {\n            p1: \"\",\n            p2: \"$\",\n            p3: \"true\"\n        },\n        \"*=\": {\n            p1: \"\",\n            p2: \"\",\n            p3: \"true\"\n        },\n        \"|=\": {\n            p1: \"^\",\n            p2: \"(-|$)\",\n            p3: \"true\"\n        },\n        \"~=\": {\n            p1: \"(^|\\\\s)\",\n            p2: \"(\\\\s|$)\",\n            p3: \"true\"\n        }\n    }, concatCall = function(nodes, callback) {\n        var i = 0, l = nodes.length, list = Array(l);\n        while(l > i){\n            if (false === callback(list[i] = nodes[i])) break;\n            ++i;\n        }\n        return list;\n    }, concatList = function(list, nodes) {\n        var i = -1, l = nodes.length;\n        while(l--){\n            list[list.length] = nodes[++i];\n        }\n        return list;\n    }, // only define the toNodeList helper if explicitly enabled in Config,\n    // a safety measure for headless hosts missing feature/implementation\n    toNodeList = Config.ANODELIST == false ? function(x) {\n        return x;\n    } : function() {\n        // create a DocumentFragment\n        var emptyNL = doc.createDocumentFragment().childNodes;\n        // this is returned from a self-executing function so that\n        // the DocumentFragment isn't repeatedly created\n        return function(nodeArray) {\n            // check if it is already a nodelist\n            if (nodeArray instanceof global.NodeList) return nodeArray;\n            // if it's a single element, wrap it in a classic array\n            if (!Array.isArray(nodeArray)) nodeArray = [\n                nodeArray\n            ];\n            // base an object on emptyNL\n            var fakeNL = Object.create(emptyNL, {\n                \"length\": {\n                    value: nodeArray.length,\n                    enumerable: false\n                },\n                \"item\": {\n                    \"value\": function(i) {\n                        return this[+i || 0];\n                    },\n                    enumerable: false\n                }\n            });\n            // copy the array elemnts\n            nodeArray.forEach(function(v, i) {\n                fakeNL[i] = v;\n            });\n            // return an object pretending to be a NodeList.\n            return fakeNL;\n        };\n    }(), documentOrder = function(a, b) {\n        if (!hasDupes && a === b) {\n            hasDupes = true;\n            return 0;\n        }\n        return a.compareDocumentPosition(b) & 4 ? -1 : 1;\n    }, hasDupes = false, unique = function(nodes) {\n        var i = 0, j = -1, l = nodes.length + 1, list = [];\n        while(--l){\n            if (nodes[i++] === nodes[i]) continue;\n            list[++j] = nodes[i - 1];\n        }\n        hasDupes = false;\n        return list;\n    }, switchContext = function(context, force) {\n        var oldDoc = doc;\n        doc = context.ownerDocument || context;\n        if (force || oldDoc !== doc) {\n            // force a new check for each document change\n            // performed before the next select operation\n            root = doc.documentElement;\n            HTML_DOCUMENT = isHTML(doc);\n            QUIRKS_MODE = HTML_DOCUMENT && doc.compatMode.indexOf(\"CSS\") < 0;\n            NAMESPACE = root && root.namespaceURI;\n            Snapshot.doc = doc;\n            Snapshot.root = root;\n        }\n        return Snapshot.from = context;\n    }, // convert single codepoint to UTF-16 encoding\n    codePointToUTF16 = function(codePoint) {\n        // out of range, use replacement character\n        if (codePoint < 1 || codePoint > 0x10ffff || codePoint > 0xd7ff && codePoint < 0xe000) {\n            return \"\\\\ufffd\";\n        }\n        // javascript strings are UTF-16 encoded\n        if (codePoint < 0x10000) {\n            var lowHex = \"000\" + codePoint.toString(16);\n            return \"\\\\u\" + lowHex.substr(lowHex.length - 4);\n        }\n        // supplementary high + low surrogates\n        return \"\\\\u\" + ((codePoint - 0x10000 >> 0x0a) + 0xd800).toString(16) + \"\\\\u\" + ((codePoint - 0x10000) % 0x400 + 0xdc00).toString(16);\n    }, // convert single codepoint to string\n    stringFromCodePoint = function(codePoint) {\n        // out of range, use replacement character\n        if (codePoint < 1 || codePoint > 0x10ffff || codePoint > 0xd7ff && codePoint < 0xe000) {\n            return \"ï¿½\";\n        }\n        if (codePoint < 0x10000) {\n            return String.fromCharCode(codePoint);\n        }\n        return String.fromCodePoint ? String.fromCodePoint(codePoint) : String.fromCharCode((codePoint - 0x10000 >> 0x0a) + 0xd800, (codePoint - 0x10000) % 0x400 + 0xdc00);\n    }, // convert escape sequence in a CSS string or identifier\n    // to javascript string with javascript escape sequences\n    convertEscapes = function(str) {\n        return REX.HasEscapes.test(str) ? str.replace(REX.FixEscapes, function(substring, p1, p2) {\n            // unescaped \" or '\n            return p2 ? \"\\\\\" + p2 : // javascript strings are UTF-16 encoded\n            REX.HexNumbers.test(p1) ? codePointToUTF16(parseInt(p1, 16)) : // \\' \\\"\n            REX.EscOrQuote.test(p1) ? substring : // \\g \\h \\. \\# etc\n            p1;\n        }) : str;\n    }, // convert escape sequence in a CSS string or identifier\n    // to javascript string with characters representations\n    unescapeIdentifier = function(str) {\n        return REX.HasEscapes.test(str) ? str.replace(REX.FixEscapes, function(substring, p1, p2) {\n            // unescaped \" or '\n            return p2 ? p2 : // javascript strings are UTF-16 encoded\n            REX.HexNumbers.test(p1) ? stringFromCodePoint(parseInt(p1, 16)) : // \\' \\\"\n            REX.EscOrQuote.test(p1) ? substring : // \\g \\h \\. \\# etc\n            p1;\n        }) : str;\n    }, method = {\n        \"#\": \"getElementById\",\n        \"*\": \"getElementsByTagName\",\n        \"|\": \"getElementsByTagNameNS\",\n        \".\": \"getElementsByClassName\"\n    }, compat = {\n        \"#\": function(c, n) {\n            REX.HasEscapes.test(n) && (n = unescapeIdentifier(n));\n            return function(e, f) {\n                return byId(n, c);\n            };\n        },\n        \"*\": function(c, n) {\n            REX.HasEscapes.test(n) && (n = unescapeIdentifier(n));\n            return function(e, f) {\n                return byTag(n, c);\n            };\n        },\n        \"|\": function(c, n) {\n            REX.HasEscapes.test(n) && (n = unescapeIdentifier(n));\n            return function(e, f) {\n                return byTagNS(n, c);\n            };\n        },\n        \".\": function(c, n) {\n            REX.HasEscapes.test(n) && (n = unescapeIdentifier(n));\n            return function(e, f) {\n                return byClass(n, c);\n            };\n        }\n    }, // find duplicate ids using iterative walk\n    byIdRaw = function(id, context) {\n        var node = context, nodes = [], next = node.firstElementChild;\n        while(node = next){\n            node.id == id && (nodes[nodes.length] = node);\n            if (next = node.firstElementChild || node.nextElementSibling) continue;\n            while(!next && (node = node.parentElement) && node !== context){\n                next = node.nextElementSibling;\n            }\n        }\n        return nodes;\n    }, // context agnostic getElementById\n    byId = function(id, context) {\n        var e, i, l, nodes, api = method[\"#\"];\n        // duplicates id allowed\n        if (Config.IDS_DUPES === false) {\n            if (api in context) {\n                return (e = context[api](id)) ? [\n                    e\n                ] : none;\n            }\n        } else {\n            if (\"all\" in context) {\n                if (e = context.all[id]) {\n                    if (e.nodeType == 1) return e.getAttribute(\"id\") != id ? [] : [\n                        e\n                    ];\n                    else if (id == \"length\") return (e = context[api](id)) ? [\n                        e\n                    ] : none;\n                    for(i = 0, l = e.length, nodes = []; l > i; ++i){\n                        if (e[i].id == id) nodes[nodes.length] = e[i];\n                    }\n                    return nodes && nodes.length ? nodes : [\n                        nodes\n                    ];\n                } else return none;\n            }\n        }\n        return byIdRaw(id, context);\n    }, // wrapped up namespaced TagName api calls\n    byTagNS = function(context, tag) {\n        return byTag(tag, context);\n    }, // context agnostic getElementsByTagName\n    byTag = function(tag, context) {\n        var e, nodes, api = method[\"*\"];\n        // DOCUMENT_NODE (9) & ELEMENT_NODE (1)\n        if (api in context) {\n            return slice.call(context[api](tag));\n        } else {\n            tag = tag.toLowerCase();\n            // DOCUMENT_FRAGMENT_NODE (11)\n            if (e = context.firstElementChild) {\n                if (!(e.nextElementSibling || tag == \"*\" || e.localName == tag)) {\n                    return slice.call(e[api](tag));\n                } else {\n                    nodes = [];\n                    do {\n                        if (tag == \"*\" || e.localName == tag) nodes[nodes.length] = e;\n                        concatList(nodes, e[api](tag));\n                    }while (e = e.nextElementSibling);\n                }\n            } else nodes = none;\n        }\n        return !Config.ANODELIST ? nodes : nodes instanceof global.NodeList ? nodes : toNodeList(nodes);\n    }, // context agnostic getElementsByClassName\n    byClass = function(cls, context) {\n        var e, nodes, api = method[\".\"], reCls;\n        // DOCUMENT_NODE (9) & ELEMENT_NODE (1)\n        if (api in context) {\n            return slice.call(context[api](cls));\n        } else {\n            // DOCUMENT_FRAGMENT_NODE (11)\n            if (e = context.firstElementChild) {\n                reCls = RegExp(\"(^|\\\\s)\" + cls + \"(\\\\s|$)\", QUIRKS_MODE ? \"i\" : \"\");\n                if (!(e.nextElementSibling || reCls.test(e.className))) {\n                    return slice.call(e[api](cls));\n                } else {\n                    nodes = [];\n                    do {\n                        if (reCls.test(e.className)) nodes[nodes.length] = e;\n                        concatList(nodes, e[api](cls));\n                    }while (e = e.nextElementSibling);\n                }\n            } else nodes = none;\n        }\n        return !Config.ANODELIST ? nodes : nodes instanceof global.NodeList ? nodes : toNodeList(nodes);\n    }, // namespace aware hasAttribute\n    // helper for XML/XHTML documents\n    hasAttributeNS = function(e, name) {\n        var i, l, attr = e.getAttributeNames();\n        name = RegExp(\":?\" + name + \"$\", HTML_DOCUMENT ? \"i\" : \"\");\n        for(i = 0, l = attr.length; l > i; ++i){\n            if (name.test(attr[i])) return true;\n        }\n        return false;\n    }, // fast resolver for the :nth-child() and :nth-last-child() pseudo-classes\n    nthElement = function() {\n        var idx = 0, len = 0, set = 0, parent = undefined, parents = Array(), nodes = Array();\n        return function(element, dir) {\n            // ensure caches are emptied after each run, invoking with dir = 2\n            if (dir == 2) {\n                idx = 0;\n                len = 0;\n                set = 0;\n                nodes.length = 0;\n                parents.length = 0;\n                parent = undefined;\n                return -1;\n            }\n            var e, i, j, k, l;\n            if (parent === element.parentElement) {\n                i = set;\n                j = idx;\n                l = len;\n            } else {\n                l = parents.length;\n                parent = element.parentElement;\n                for(i = -1, j = 0, k = l - 1; l > j; ++j, --k){\n                    if (parents[j] === parent) {\n                        i = j;\n                        break;\n                    }\n                    if (parents[k] === parent) {\n                        i = k;\n                        break;\n                    }\n                }\n                if (i < 0) {\n                    parents[i = l] = parent;\n                    l = 0;\n                    nodes[i] = Array();\n                    e = parent && parent.firstElementChild || element;\n                    while(e){\n                        nodes[i][l] = e;\n                        if (e === element) j = l;\n                        e = e.nextElementSibling;\n                        ++l;\n                    }\n                    set = i;\n                    idx = 0;\n                    len = l;\n                    if (l < 2) return l;\n                } else {\n                    l = nodes[i].length;\n                    set = i;\n                }\n            }\n            if (element !== nodes[i][j] && element !== nodes[i][j = 0]) {\n                for(j = 0, e = nodes[i], k = l - 1; l > j; ++j, --k){\n                    if (e[j] === element) {\n                        break;\n                    }\n                    if (e[k] === element) {\n                        j = k;\n                        break;\n                    }\n                }\n            }\n            idx = j + 1;\n            len = l;\n            return dir ? l - j : idx;\n        };\n    }(), // fast resolver for the :nth-of-type() and :nth-last-of-type() pseudo-classes\n    nthOfType = function() {\n        var idx = 0, len = 0, set = 0, parent = undefined, parents = Array(), nodes = Array();\n        return function(element, dir) {\n            // ensure caches are emptied after each run, invoking with dir = 2\n            if (dir == 2) {\n                idx = 0;\n                len = 0;\n                set = 0;\n                nodes.length = 0;\n                parents.length = 0;\n                parent = undefined;\n                return -1;\n            }\n            var e, i, j, k, l, name = element.localName;\n            if (nodes[set] && nodes[set][name] && parent === element.parentElement) {\n                i = set;\n                j = idx;\n                l = len;\n            } else {\n                l = parents.length;\n                parent = element.parentElement;\n                for(i = -1, j = 0, k = l - 1; l > j; ++j, --k){\n                    if (parents[j] === parent) {\n                        i = j;\n                        break;\n                    }\n                    if (parents[k] === parent) {\n                        i = k;\n                        break;\n                    }\n                }\n                if (i < 0 || !nodes[i][name]) {\n                    parents[i = l] = parent;\n                    nodes[i] || (nodes[i] = Object());\n                    l = 0;\n                    nodes[i][name] = Array();\n                    e = parent && parent.firstElementChild || element;\n                    while(e){\n                        if (e === element) j = l;\n                        if (e.localName == name) {\n                            nodes[i][name][l] = e;\n                            ++l;\n                        }\n                        e = e.nextElementSibling;\n                    }\n                    set = i;\n                    idx = j;\n                    len = l;\n                    if (l < 2) return l;\n                } else {\n                    l = nodes[i][name].length;\n                    set = i;\n                }\n            }\n            if (element !== nodes[i][name][j] && element !== nodes[i][name][j = 0]) {\n                for(j = 0, e = nodes[i][name], k = l - 1; l > j; ++j, --k){\n                    if (e[j] === element) {\n                        break;\n                    }\n                    if (e[k] === element) {\n                        j = k;\n                        break;\n                    }\n                }\n            }\n            idx = j + 1;\n            len = l;\n            return dir ? l - j : idx;\n        };\n    }(), // check if the document type is HTML\n    isHTML = function(node) {\n        var doc = node.ownerDocument || node;\n        return doc.nodeType == 9 && // contentType not in IE <= 11\n        \"contentType\" in doc ? doc.contentType.indexOf(\"/html\") > 0 : doc.createElement(\"DiV\").localName == \"div\";\n    }, // return node if node is focusable\n    // or false if node isn't focusable\n    isFocusable = function(node) {\n        var doc = node.ownerDocument;\n        if (node.contentDocument && node.localName == \"iframe\") {\n            return false;\n        }\n        if (doc.hasFocus() && node === doc.activeElement) {\n            if (node.type || node.href || typeof node.tabIndex == \"number\") {\n                return node;\n            }\n        }\n        return false;\n    }, // check if node content is editable\n    isContentEditable = function(node) {\n        var attrValue = \"inherit\";\n        if (node.hasAttribute(\"contenteditable\")) {\n            attrValue = node.getAttribute(\"contenteditable\");\n        }\n        switch(attrValue){\n            case \"\":\n            case \"plaintext-only\":\n            case \"true\":\n                return true;\n            case \"false\":\n                return false;\n            default:\n                if (node.parentNode && node.parentNode.nodeType === 1) {\n                    return isContentEditable(node.parentNode);\n                }\n                return false;\n        }\n    }, // check media resources is playing\n    isPlaying = function(media) {\n        // for <audio>, <video>, <source> and <track> elements\n        var parent = media instanceof HTMLMediaElement ? null : media.parentElement;\n        return !!(media && media.currentTime > 0 && !media.paused && !media.ended && media.readyState > 2) || !!(parent && parent.currentTime > 0 && !parent.paused && !parent.ended && parent.readyState > 2);\n    }, // configure the engine to use special handling\n    configure = function(option, clear) {\n        if (typeof option == \"string\") {\n            return !!Config[option];\n        }\n        if (typeof option != \"object\") {\n            return Config;\n        }\n        for(var i in option){\n            Config[i] = !!option[i];\n        }\n        // clear lambda cache\n        if (clear) {\n            matchResolvers = {};\n            selectResolvers = {};\n        }\n        setIdentifierSyntax();\n        return true;\n    }, // centralized error and exceptions handling\n    emit = function(message, proto) {\n        var err;\n        if (Config.VERBOSITY) {\n            if (proto) {\n                err = new proto(message);\n            } else {\n                err = new global.DOMException(message, \"SyntaxError\");\n            }\n            throw err;\n        }\n        if (Config.LOGERRORS && console && console.log) {\n            console.log(message);\n        }\n    }, // execute the engine initialization code\n    initialize = function(doc) {\n        setIdentifierSyntax();\n        lastContext = switchContext(doc, true);\n    }, // build validation regexps used by the engine\n    setIdentifierSyntax = function() {\n        //\n        // NOTE: SPECIAL CASES IN CSS SYNTAX PARSING RULES\n        //\n        // The <EOF-token> https://drafts.csswg.org/css-syntax/#typedef-eof-token\n        // allow mangled|unclosed selector syntax at the end of selectors strings\n        //\n        // Literal equivalent hex representations of the characters: \" ' ` ] )\n        //\n        //     \\\\x22 = \" - double quotes    \\\\x5b = [ - open square bracket\n        //     \\\\x27 = ' - single quote     \\\\x5d = ] - closed square bracket\n        //     \\\\x60 = ` - back tick        \\\\x28 = ( - open round parens\n        //     \\\\x5c = \\ - back slash       \\\\x29 = ) - closed round parens\n        //\n        // using hex format prevents false matches of opened/closed instances\n        // pairs, coloring breakage and other editors highlightning problems.\n        //\n        var // non-ascii chars\n        noascii = \"[^\\\\x00-\\\\x9f]\", // escaped chars\n        escaped = \"\\\\\\\\[^\\\\r\\\\n\\\\f0-9a-fA-F]\", // unicode chars\n        unicode = \"\\\\\\\\[0-9a-fA-F]{1,6}(?:\\\\r\\\\n|\\\\s)?\", // can start with single/double dash\n        // but it can not start with a digit\n        identifier = \"-?(?:[a-zA-Z_-]|\" + noascii + \"|\" + escaped + \"|\" + unicode + \")\" + \"(?:-{2}|[0-9]|[a-zA-Z_-]|\" + noascii + \"|\" + escaped + \"|\" + unicode + \")*\", pseudonames = \"[-\\\\w]+\", pseudoparms = \"(?:[-+]?\\\\d*)(?:n\\\\s?[-+]?\\\\s?\\\\d*)\", doublequote = '\"[^\"\\\\\\\\]*(?:\\\\\\\\.[^\"\\\\\\\\]*)*(?:\"|$)', singlequote = \"'[^'\\\\\\\\]*(?:\\\\\\\\.[^'\\\\\\\\]*)*(?:'|$)\", attrparser = identifier + \"|\" + doublequote + \"|\" + singlequote, attrvalues = \"([\\\\x22\\\\x27]?)((?!\\\\3)*|(?:\\\\\\\\?.)*?)(?:\\\\3|$)\", attributes = \"\\\\[\" + // attribute presence\n        \"(?:\\\\*\\\\|)?\" + WSP + \"?\" + \"(\" + identifier + \"(?::\" + identifier + \")?)\" + WSP + \"?\" + \"(?:\" + \"(\" + CFG.operators + \")\" + WSP + \"?\" + \"(?:\" + attrparser + \")\" + \")?\" + // attribute case sensitivity\n        \"(?:\" + WSP + \"?\\\\b(i))?\" + WSP + \"?\" + \"(?:\\\\]|$)\", attrmatcher = attributes.replace(attrparser, attrvalues), pseudoclass = \"(?:\\\\x28\" + WSP + \"*\" + \"(?:\" + pseudoparms + \"?)?|\" + // universal * &\n        // namespace *|*\n        \"(?:\\\\*|\\\\*\\\\|)|\" + \"(?:\" + \"(?::\" + pseudonames + \"(?:\\\\x28\" + pseudoparms + \"?(?:\\\\x29|$))?|\" + \")|\" + \"(?:[.#]?\" + identifier + \")|\" + \"(?:\" + attributes + \")\" + \")+|\" + \"(?:\" + WSP + \"?[>+~][^>+~]\" + WSP + \"?)|\" + \"(?:\" + WSP + \"?,\" + WSP + \"?)|\" + \"(?:\" + WSP + \"?)|\" + \"(?:\\\\x29|$)\" + \")*\", standardValidator = \"(?=\" + WSP + \"?[^>+~(){}<>])\" + \"(?:\" + // universal * &\n        // namespace *|*\n        \"(?:\\\\*|\\\\*\\\\|)|\" + \"(?:[.#]?\" + identifier + \")+|\" + \"(?:\" + attributes + \")+|\" + \"(?:::?\" + pseudonames + pseudoclass + \")|\" + \"(?:\" + WSP + \"?\" + CFG.combinators + WSP + \"?)|\" + \"(?:\" + WSP + \"?,\" + WSP + \"?)|\" + \"(?:\" + WSP + \"?)\" + \")+\";\n        // the following global RE is used to return the\n        // deepest localName in selector strings and then\n        // use it to retrieve all possible matching nodes\n        // that will be filtered by compiled resolvers\n        reOptimizer = RegExp(\"(?:([.:#*]?)\" + \"(\" + identifier + \")\" + \"(?:\" + \":[-\\\\w]+|\" + \"\\\\[[^\\\\]]+(?:\\\\]|$)|\" + \"\\\\x28[^\\\\x29]+(?:\\\\x29|$)\" + \")*)$\");\n        // global\n        reValidator = RegExp(standardValidator, \"g\");\n        Patterns.id = RegExp(\"^#(\" + identifier + \")(.*)\");\n        Patterns.tagName = RegExp(\"^(\" + identifier + \")(.*)\");\n        Patterns.className = RegExp(\"^\\\\.(\" + identifier + \")(.*)\");\n        Patterns.attribute = RegExp(\"^(?:\" + attrmatcher + \")(.*)\");\n    }, F_INIT = '\"use strict\";return function Resolver(c,f,x,r)', /*\n  // S - M - N\n  //\n  // SELECT\n  // MATCH\n  // NONE\n  //\n  */ S_HEAD = \"var e,n,o,j=r.length-1,k=-1\", M_HEAD = \"var e,n,o\", N_HEAD = \"var e,n,o\", S_LOOP = \"main:while((e=c[++k]))\", M_LOOP = \"e=c;\", N_LOOP = \"main:while((e=c.item(++k)))\", S_BODY = \"r[++j]=c[k];\", M_BODY = \"\", N_BODY = \"r[++j]=c.item(k);\", S_TAIL = \"continue main;\", M_TAIL = \"r=true;\", N_TAIL = \"r=true;\", S_TEST = \"if(f(c[k])){break main;}\", M_TEST = \"f(c);\", N_TEST = \"if(f(c.item(k))){break main;}\", S_VARS = [], M_VARS = [], N_VARS = [], // compile groups or single selector strings into\n    // executable functions for matching or selecting\n    S_TEST = \"if(f(c[k])){break main;}\", M_TEST = \"f(c);\", N_TEST = \"if(f(c.item(k))){break main;}\", S_VARS = [], M_VARS = [], N_VARS = [], // compile groups or single selector strings into\n    // executable functions for matching or selecting\n    compile = function(selector, mode, callback) {\n        var factory, token, head = \"\", loop = \"\", macro = \"\", source = \"\", vars = \"\";\n        // 'mode' can be boolean or null\n        // true = select / false = match\n        // null to use collection.item()\n        switch(mode){\n            case true:\n                if (selectLambdas[selector]) {\n                    return selectLambdas[selector];\n                }\n                macro = S_BODY + (callback ? S_TEST : \"\") + S_TAIL;\n                head = S_HEAD;\n                loop = S_LOOP;\n                break;\n            case false:\n                if (matchLambdas[selector]) {\n                    return matchLambdas[selector];\n                }\n                macro = M_BODY + (callback ? M_TEST : \"\") + M_TAIL;\n                head = M_HEAD;\n                loop = M_LOOP;\n                break;\n            case null:\n                if (selectLambdas[selector]) {\n                    return selectLambdas[selector];\n                }\n                macro = N_BODY + (callback ? N_TEST : \"\") + N_TAIL;\n                head = N_HEAD;\n                loop = N_LOOP;\n                break;\n            default:\n                break;\n        }\n        source = compileSelector(selector, macro, mode, callback);\n        loop += mode || mode === null ? \"{\" + source + \"}\" : source;\n        if (mode || mode === null && selector.includes(\":nth\")) {\n            loop += reNthElem.test(selector) ? \"s.nthElement(null, 2);\" : \"\";\n            loop += reNthType.test(selector) ? \"s.nthOfType(null, 2);\" : \"\";\n        }\n        if (S_VARS[0] || M_VARS[0] || N_VARS[0]) {\n            vars = \",\" + (S_VARS.join(\",\") || M_VARS.join(\",\") || N_VARS[0]);\n            S_VARS.length = 0;\n            M_VARS.length = 0;\n            N_VARS.length = 0;\n        }\n        factory = Function(\"s\", F_INIT + \"{\" + head + vars + \";\" + loop + \"return r;}\")(Snapshot);\n        return mode || mode === null ? selectLambdas[selector] = factory : matchLambdas[selector] = factory;\n    }, // build conditional code to check components of selector strings\n    compileSelector = function(expression, source, mode, callback) {\n        var a, b, n, f, k = 0, name, NS, referenceElement, compat, expr, match, result, status, symbol, test, type, selector = expression, selector_string, vars;\n        // original 'select' or 'match' selector string before normalization\n        selector_string = mode ? lastSelected : lastMatched;\n        // isolate selector combinators/components and normalize whitespace\n        selector = selector.replace(STD.combinator, \"$1\"); //.replace(STD.whitespace, ' ');\n        // javascript needs a label to break\n        // out of the while loops processing\n        selector_recursion_label: while(selector){\n            ++k;\n            // get namespace prefix if present or get first char of selector\n            symbol = STD.apimethods.test(selector) ? \"|\" : selector[0];\n            switch(symbol){\n                // universal resolver\n                case \"*\":\n                    match = selector.match(Patterns.universal);\n                    break;\n                // id resolver\n                case \"#\":\n                    match = selector.match(Patterns.id);\n                    source = \"if((/^\" + match[1] + '$/.test(e.getAttribute(\"id\")))){' + source + \"}\";\n                    break;\n                // class name resolver\n                case \".\":\n                    match = selector.match(Patterns.className);\n                    compat = (QUIRKS_MODE ? \"i\" : \"\") + '.test(e.getAttribute(\"class\"))';\n                    source = \"if((/(^|\\\\s)\" + match[1] + \"(\\\\s|$)/\" + compat + \")){\" + source + \"}\";\n                    break;\n                // tag name resolver\n                case /[_a-z]/i.test(symbol) ? symbol : undefined:\n                    match = selector.match(Patterns.tagName);\n                    source = 'if((e.localName==\"' + match[1] + '\")){' + source + \"}\";\n                    break;\n                // namespace resolver\n                case \"|\":\n                    match = selector.match(Patterns.namespace);\n                    if (match[1] == \"*\") {\n                        source = \"if(true){\" + source + \"}\";\n                    } else if (!match[1]) {\n                        source = \"if((!e.namespaceURI)){\" + source + \"}\";\n                    } else if (typeof match[1] == \"string\" && root.prefix == match[1]) {\n                        source = 'if((e.namespaceURI==\"' + NAMESPACE + '\")){' + source + \"}\";\n                    } else {\n                        emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                    }\n                    break;\n                // attributes resolver\n                case \"[\":\n                    match = selector.match(Patterns.attribute);\n                    NS = match[0].match(STD.namespaces);\n                    name = match[1];\n                    expr = name.split(\":\");\n                    expr = expr.length == 2 ? expr[1] : expr[0];\n                    if (match[2] && !(test = Operators[match[2]])) {\n                        emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                        return \"\";\n                    }\n                    if (match[4] === \"\") {\n                        test = match[2] == \"~=\" ? {\n                            p1: \"^\\\\s\",\n                            p2: \"+$\",\n                            p3: \"true\"\n                        } : match[2] in ATTR_STD_OPS && match[2] != \"~=\" ? {\n                            p1: \"^\",\n                            p2: \"$\",\n                            p3: \"true\"\n                        } : test;\n                    } else if (match[2] == \"~=\" && match[4].includes(\" \")) {\n                        break;\n                    } else if (match[4]) {\n                        match[4] = convertEscapes(match[4]).replace(REX.RegExpChar, \"\\\\$&\");\n                    }\n                    type = match[5] == \"i\" || HTML_DOCUMENT && HTML_TABLE[expr.toLowerCase()] ? \"i\" : \"\";\n                    source = \"if((\" + (!match[2] ? NS ? 's.hasAttributeNS(e,\"' + name + '\")' : 'e.hasAttribute&&e.hasAttribute(\"' + name + '\")' : !match[4] && ATTR_STD_OPS[match[2]] && match[2] != \"~=\" ? 'e.getAttribute&&e.getAttribute(\"' + name + '\")==\"\"' : \"(/\" + test.p1 + match[4] + test.p2 + \"/\" + type + ').test(e.getAttribute&&e.getAttribute(\"' + name + '\"))==' + test.p3) + \")){\" + source + \"}\";\n                    break;\n                // *** General sibling combinator\n                // E ~ F (F relative sibling of E)\n                case \"~\":\n                    match = selector.match(Patterns.relative);\n                    source = \"var N\" + k + \"=e;while(e&&(e=e.previousElementSibling)){\" + source + \"}e=N\" + k + \";\";\n                    break;\n                // *** Adjacent sibling combinator\n                // E + F (F adiacent sibling of E)\n                case \"+\":\n                    match = selector.match(Patterns.adjacent);\n                    source = \"var N\" + k + \"=e;if(e&&(e=e.previousElementSibling)){\" + source + \"}e=N\" + k + \";\";\n                    break;\n                // *** Descendant combinator\n                // E F (E ancestor of F)\n                case \"\t\":\n                case \" \":\n                    match = selector.match(Patterns.ancestor);\n                    source = \"var N\" + k + \"=e;while(e&&(e=e.parentElement)){\" + source + \"}e=N\" + k + \";\";\n                    break;\n                // *** Child combinator\n                // E > F (F children of E)\n                case \">\":\n                    match = selector.match(Patterns.children);\n                    source = \"var N\" + k + \"=e;if(e&&(e=e.parentElement)){\" + source + \"}e=N\" + k + \";\";\n                    break;\n                // *** user supplied combinators extensions\n                case symbol in Combinators ? symbol : undefined:\n                    // for other registered combinators extensions\n                    match[match.length - 1] = \"*\";\n                    source = Combinators[symbol](match) + source;\n                    break;\n                // *** tree-structural pseudo-classes\n                // :root, :empty, :first-child, :last-child, :only-child, :first-of-type, :last-of-type, :only-of-type\n                case \":\":\n                    if (match = selector.match(Patterns.structural)) {\n                        match[1] = match[1].toLowerCase();\n                        switch(match[1]){\n                            case \"scope\":\n                                // use the root (documentElement) when comparing against a document\n                                source = \"if(e===(s.from.nodeType===9?s.root:s.from)){\" + source + \"}\";\n                                break;\n                            case \"root\":\n                                // there can only be one :root element, so exit the loop once found\n                                source = \"if((e===s.root)){\" + source + (mode ? \"break main;\" : \"\") + \"}\";\n                                break;\n                            case \"empty\":\n                                // matches elements that don't contain elements or text nodes\n                                source = \"n=e.firstChild;while(n&&!(/1|3/).test(n.nodeType)){n=n.nextSibling}if(!n){\" + source + \"}\";\n                                break;\n                            // *** child-indexed pseudo-classes\n                            // :first-child, :last-child, :only-child\n                            case \"only-child\":\n                                source = \"if((!e.nextElementSibling&&!e.previousElementSibling)){\" + source + \"}\";\n                                break;\n                            case \"last-child\":\n                                source = \"if((!e.nextElementSibling)){\" + source + \"}\";\n                                break;\n                            case \"first-child\":\n                                source = \"if((!e.previousElementSibling)){\" + source + \"}\";\n                                break;\n                            // *** typed child-indexed pseudo-classes\n                            // :only-of-type, :last-of-type, :first-of-type\n                            case \"only-of-type\":\n                                source = \"o=e.localName;\" + \"n=e;while((n=n.nextElementSibling)&&n.localName!=o);if(!n){\" + \"n=e;while((n=n.previousElementSibling)&&n.localName!=o);}if(!n){\" + source + \"}\";\n                                break;\n                            case \"last-of-type\":\n                                source = \"n=e;o=e.localName;while((n=n.nextElementSibling)&&n.localName!=o);if(!n){\" + source + \"}\";\n                                break;\n                            case \"first-of-type\":\n                                source = \"n=e;o=e.localName;while((n=n.previousElementSibling)&&n.localName!=o);if(!n){\" + source + \"}\";\n                                break;\n                            default:\n                                emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                                break;\n                        }\n                    } else if (match = selector.match(Patterns.treestruct)) {\n                        match[1] = match[1].toLowerCase();\n                        switch(match[1]){\n                            case \"nth-child\":\n                            case \"nth-of-type\":\n                            case \"nth-last-child\":\n                            case \"nth-last-of-type\":\n                                expr = /-of-type/i.test(match[1]);\n                                if (match[1] && match[2]) {\n                                    type = /last/i.test(match[1]);\n                                    if (match[2] == \"n\") {\n                                        source = \"if(true){\" + source + \"}\";\n                                        break;\n                                    } else if (match[2] == \"1\") {\n                                        test = type ? \"next\" : \"previous\";\n                                        source = expr ? \"n=e;o=e.localName;\" + \"while((n=n.\" + test + \"ElementSibling)&&n.localName!=o);if(!n){\" + source + \"}\" : \"if(!e.\" + test + \"ElementSibling){\" + source + \"}\";\n                                        break;\n                                    } else if (match[2] == \"even\" || match[2] == \"2n0\" || match[2] == \"2n+0\" || match[2] == \"2n\") {\n                                        test = \"n%2==0\";\n                                    } else if (match[2] == \"odd\" || match[2] == \"2n1\" || match[2] == \"2n+1\") {\n                                        test = \"n%2==1\";\n                                    } else {\n                                        f = /n/i.test(match[2]);\n                                        n = match[2].split(\"n\");\n                                        a = parseInt(n[0], 10) || 0;\n                                        b = parseInt(n[1], 10) || 0;\n                                        if (n[0] == \"-\") {\n                                            a = -1;\n                                        }\n                                        if (n[0] == \"+\") {\n                                            a = +1;\n                                        }\n                                        test = (b ? \"(n\" + (b > 0 ? \"-\" : \"+\") + Math.abs(b) + \")\" : \"n\") + \"%\" + a + \"==0\";\n                                        test = a >= +1 ? f ? \"n>\" + (b - 1) + (Math.abs(a) != 1 ? \"&&\" + test : \"\") : \"n==\" + a : a <= -1 ? f ? \"n<\" + (b + 1) + (Math.abs(a) != 1 ? \"&&\" + test : \"\") : \"n==\" + a : a === 0 ? n[0] ? \"n==\" + b : \"n>\" + (b - 1) : \"false\";\n                                    }\n                                    expr = expr ? \"OfType\" : \"Element\";\n                                    type = type ? \"true\" : \"false\";\n                                    source = \"n=s.nth\" + expr + \"(e,\" + type + \");if((\" + test + \")){\" + source + \"}\";\n                                } else {\n                                    emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                                }\n                                break;\n                            default:\n                                emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                                break;\n                        }\n                    } else if (match = selector.match(Patterns.logicalsel)) {\n                        match[1] = match[1].toLowerCase();\n                        expr = match[2].replace(REX.CommaGroup, \",\").replace(REX.TrimSpaces, \"\");\n                        expr = expr.replace(/\\x22/g, '\\\\\"');\n                        switch(match[1]){\n                            case \"is\":\n                                source = \"try{\" + 'if(s.match(\"' + expr + '\",e)){' + source + \"}\" + \"}catch(E){\" + \"console.log(E)\" + \"}\";\n                                break;\n                            case \"where\":\n                            case \"matches\":\n                                source = 'if(s.match(\"' + expr + '\",e)){' + source + \"}\";\n                                break;\n                            case \"not\":\n                                source = 'if(!s.match(\"' + expr + '\",e)){' + source + \"}\";\n                                break;\n                            case \"has\":\n                                if (/^\\s*(\\+|\\~)/.test(match[2])) {\n                                    source = \"if(e.parentElement&&Array.from(e.parentElement\" + (/^\\s*[+]/.test(match[2]) ? '.querySelectorAll(\"*' + expr + '\")' : \".children\") + \").includes(e.nextElementSibling)){\" + source + \"}\";\n                                } else {\n                                    source = 'if(e.querySelector(\":scope ' + expr + '\"))' + \"{\" + source + \"}\";\n                                }\n                                break;\n                            default:\n                                emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                                break;\n                        }\n                    } else if (match = selector.match(Patterns.linguistic)) {\n                        match[1] = match[1].toLowerCase();\n                        switch(match[1]){\n                            case \"dir\":\n                                source = \"var p;if((\" + \"(/\" + match[2] + '/i.test(e.dir))||(p=s.ancestor(\"[dir]\", e))&&' + \"(/\" + match[2] + '/i.test(p.dir))||(e.dir==\"\"||e.dir==\"auto\")&&' + \"(\" + (match[2] == \"ltr\" ? \"!\" : \"\") + RTL + \".test(e.textContent)))\" + \"){\" + source + \"};\";\n                                break;\n                            case \"lang\":\n                                expr = \"(?:^|-)\" + match[2] + \"(?:-|$)\";\n                                source = \"var p;if((\" + '(e.isConnected&&(e.lang==\"\"&&(p=s.ancestor(\"[lang]\",e)))&&' + '(p.lang==\"' + match[2] + '\")||/' + expr + \"/i.test(e.lang)))\" + \"){\" + source + \"};\";\n                                break;\n                            default:\n                                emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                                break;\n                        }\n                    } else if (match = selector.match(Patterns.locationpc)) {\n                        match[1] = match[1].toLowerCase();\n                        switch(match[1]){\n                            case \"any-link\":\n                                source = 'if((/^a|area$/i.test(e.localName)&&e.hasAttribute(\"href\")||e.visited)){' + source + \"}\";\n                                break;\n                            case \"link\":\n                                source = 'if((/^a|area$/i.test(e.localName)&&e.hasAttribute(\"href\"))){' + source + \"}\";\n                                break;\n                            case \"visited\":\n                                source = 'if((/^a|area$/i.test(e.localName)&&e.hasAttribute(\"href\")&&e.visited)){' + source + \"}\";\n                                break;\n                            case \"target\":\n                                source = \"if(((s.doc.compareDocumentPosition(e)&16)&&s.doc.location.hash&&e.id==s.doc.location.hash.slice(1))){\" + source + \"}\";\n                                break;\n                            case \"defined\":\n                                source = \"n=s.doc.defaultView.customElements.get(e.localName);if(n&&e instanceof n){\" + source + \"}\";\n                                break;\n                            default:\n                                emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                                break;\n                        }\n                    } else if (match = selector.match(Patterns.useraction)) {\n                        match[1] = match[1].toLowerCase();\n                        switch(match[1]){\n                            case \"hover\":\n                                source = \"if(e===s.HOVER){\" + source + \"}\";\n                                break;\n                            case \"active\":\n                                source = \"if(e===s.doc.activeElement){\" + source + \"}\";\n                                break;\n                            case \"focus\":\n                                source = \"if(s.isFocusable(e)){\" + source + \"}\";\n                                break;\n                            case \"focus-visible\":\n                                source = \"if(n=s.isFocusable(e)){\" + \"if(e!==n){while(e){e=e.parentElement;if(e===n)break;}}}\" + \"if((e===n||e.autofocus)){\" + source + \"}\";\n                                break;\n                            case \"focus-within\":\n                                source = \"if(n=s.isFocusable(e)){\" + \"if(n!==e){while(n){n=n.parentElement;if(n===e)break;}}}\" + \"if((n===e||n.autofocus)){\" + source + \"}\";\n                                break;\n                            default:\n                                emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                                break;\n                        }\n                    } else if (match = selector.match(Patterns.inputstate)) {\n                        match[1] = match[1].toLowerCase();\n                        switch(match[1]){\n                            case \"enabled\":\n                                source = 'if(((\"form\" in e||/^optgroup$/i.test(e.localName))&&\"disabled\" in e &&e.disabled===false' + \")){\" + source + \"}\";\n                                break;\n                            case \"disabled\":\n                                // https://html.spec.whatwg.org/#enabling-and-disabling-form-controls:-the-disabled-attribute\n                                source = 'if(((\"form\" in e||/^optgroup$/i.test(e.localName))&&\"disabled\" in e)){' + // F is true if any of the fieldset elements in the ancestry chain has the disabled attribute specified\n                                // L is true if the first legend element of the fieldset contains the element\n                                \"var x=0,N=[],F=false,L=false;\" + \"if(!(/^(optgroup|option)$/i.test(e.localName))){\" + \"n=e.parentElement;\" + \"while(n){\" + 'if(n.localName==\"fieldset\"){' + \"N[x++]=n;\" + \"if(n.disabled===true){\" + \"F=true;\" + \"break;\" + \"}\" + \"}\" + \"n=n.parentElement;\" + \"}\" + \"for(var x=0;x<N.length;x++){\" + 'if((n=s.first(\"legend\",N[x]))&&n.contains(e)){' + \"L=true;\" + \"break;\" + \"}\" + \"}\" + \"}\" + \"if(e.disabled===true||(F&&!L)){\" + source + \"}}\";\n                                break;\n                            case \"read-only\":\n                                source = \"if(\" + \"(/^textarea$/i.test(e.localName)&&(e.readOnly||e.disabled))||\" + '(/^input$/i.test(e.localName)&&(\"|date|datetime-local|email|month|number|password|search|tel|text|time|url|week|\".includes(\"|\"+e.type+\"|\")?(e.readOnly||e.disabled):true))||' + \"(!/^(?:input|textarea)$/i.test(e.localName) && !s.isContentEditable(e))\" + \"){\" + source + \"}\";\n                                break;\n                            case \"read-write\":\n                                source = \"if(\" + \"(/^textarea$/i.test(e.localName)&&!e.readOnly&&!e.disabled)||\" + '(/^input$/i.test(e.localName)&&\"|date|datetime-local|email|month|number|password|search|tel|text|time|url|week|\".includes(\"|\"+e.type+\"|\")&&!e.readOnly&&!e.disabled)||' + \"(!/^(?:input|textarea)$/i.test(e.localName) && s.isContentEditable(e))\" + \"){\" + source + \"}\";\n                                break;\n                            case \"placeholder-shown\":\n                                source = \"if((\" + '(/^input|textarea$/i.test(e.localName))&&e.hasAttribute(\"placeholder\")&&' + '(\"|textarea|password|number|search|email|text|tel|url|\".includes(\"|\"+e.type+\"|\"))&&' + '(!s.match(\":focus\",e))' + \")){\" + source + \"}\";\n                                break;\n                            case \"default\":\n                                source = 'if((\"form\" in e && e.form)){' + \"var x=0;n=[];\" + 'if(e.type==\"image\")n=e.form.getElementsByTagName(\"input\");' + 'if(e.type==\"submit\")n=e.form.elements;' + \"while(n[x]&&e!==n[x]){\" + 'if(n[x].type==\"image\")break;' + 'if(n[x].type==\"submit\")break;' + \"x++;\" + \"}\" + \"}\" + 'if((e.form&&(e===n[x]&&\"|image|submit|\".includes(\"|\"+e.type+\"|\"))||' + \"((/^option$/i.test(e.localName))&&e.defaultSelected)||\" + '((\"|radio|checkbox|\".includes(\"|\"+e.type+\"|\"))&&e.defaultChecked)' + \")){\" + source + \"}\";\n                                break;\n                            default:\n                                emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                                break;\n                        }\n                    } else if (match = selector.match(Patterns.inputvalue)) {\n                        match[1] = match[1].toLowerCase();\n                        switch(match[1]){\n                            case \"checked\":\n                                source = \"if((/^input$/i.test(e.localName)&&\" + '(\"|radio|checkbox|\".includes(\"|\"+e.type+\"|\")&&e.checked)||' + \"(/^option$/i.test(e.localName)&&(e.selected||e.checked))\" + \")){\" + source + \"}\";\n                                break;\n                            case \"indeterminate\":\n                                source = 'if((/^progress$/i.test(e.localName)&&!e.hasAttribute(\"value\"))||' + '(/^input$/i.test(e.localName)&&(\"checkbox\"==e.type&&e.indeterminate)||' + '(\"radio\"==e.type&&e.name&&!s.first(\"input[name=\"+e.name+\"]:checked\",e.form))' + \")){\" + source + \"}\";\n                                break;\n                            case \"required\":\n                                source = \"if((/^input|select|textarea$/i.test(e.localName)&&e.required)\" + \"){\" + source + \"}\";\n                                break;\n                            case \"optional\":\n                                source = \"if((/^input|select|textarea$/i.test(e.localName)&&!e.required)\" + \"){\" + source + \"}\";\n                                break;\n                            case \"invalid\":\n                                source = \"if(((\" + \"(/^form$/i.test(e.localName)&&!e.noValidate)||\" + \"(e.willValidate&&!e.formNoValidate))&&!e.checkValidity())||\" + '(/^fieldset$/i.test(e.localName)&&s.first(\":invalid\",e))' + \"){\" + source + \"}\";\n                                break;\n                            case \"valid\":\n                                source = \"if(((\" + \"(/^form$/i.test(e.localName)&&!e.noValidate)||\" + \"(e.willValidate&&!e.formNoValidate))&&e.checkValidity())||\" + '(/^fieldset$/i.test(e.localName)&&s.first(\":valid\",e))' + \"){\" + source + \"}\";\n                                break;\n                            case \"in-range\":\n                                source = \"if((/^input$/i.test(e.localName))&&\" + \"(e.willValidate&&!e.formNoValidate)&&\" + \"(!e.validity.rangeUnderflow&&!e.validity.rangeOverflow)&&\" + '(\"|date|datetime-local|month|number|range|time|week|\".includes(\"|\"+e.type+\"|\"))&&' + '(\"range\"==e.type||e.getAttribute(\"min\")||e.getAttribute(\"max\"))' + \"){\" + source + \"}\";\n                                break;\n                            case \"out-of-range\":\n                                source = \"if((/^input$/i.test(e.localName))&&\" + \"(e.willValidate&&!e.formNoValidate)&&\" + \"(e.validity.rangeUnderflow||e.validity.rangeOverflow)&&\" + '(\"|date|datetime-local|month|number|range|time|week|\".includes(\"|\"+e.type+\"|\"))&&' + '(\"range\"==e.type||e.getAttribute(\"min\")||e.getAttribute(\"max\"))' + \"){\" + source + \"}\";\n                                break;\n                            default:\n                                emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                                break;\n                        }\n                    } else if (match = selector.match(Patterns.rsrc_state)) {\n                        match[1] = match[1].toLowerCase();\n                        switch(match[1]){\n                            case \"playing\":\n                                source = \"if(s.isPlaying(e)){\" + source + \"}\";\n                                break;\n                            case \"paused\":\n                                source = \"if(!s.isPlaying(e)){\" + source + \"}\";\n                                break;\n                            case \"seeking\":\n                                source = \"if(!s.isPlaying(e)){\" + source + \"}\";\n                                break;\n                            case \"buffering\":\n                                break;\n                            case \"stalled\":\n                                break;\n                            case \"muted\":\n                                source = 'if(e.localName==\"audio\"&&e.getAttribute(\"muted\")){' + source + \"}\";\n                                break;\n                            case \"volume-locked\":\n                                break;\n                            default:\n                                break;\n                        }\n                    } else if (match = selector.match(Patterns.pseudo_nop)) {\n                        break;\n                    } else if (match = selector.match(Patterns.pseudo_sng)) {\n                        source = 'if(e.element&&e.type.toLowerCase()==\"' + \":\" + match[0].toLowerCase() + '\"){e=e.element;' + source + \"}\";\n                    } else if (match = selector.match(Patterns.pseudo_dbl)) {\n                        source = 'if(e.element&&e.type.toLowerCase()==\"' + match[0].toLowerCase() + '\"){e=e.element;' + source + \"}\";\n                    } else {\n                        // reset\n                        expr = false;\n                        status = false;\n                        // process registered selector extensions\n                        for(expr in Selectors){\n                            if (match = selector.match(Selectors[expr].Expression)) {\n                                result = Selectors[expr].Callback(match, source, mode, callback);\n                                if (\"match\" in result) {\n                                    match = result.match;\n                                }\n                                vars = result.modvar;\n                                if (mode) {\n                                    // add extra select() vars\n                                    vars && S_VARS.indexOf(vars) < 0 && (S_VARS[S_VARS.length] = vars);\n                                } else {\n                                    // add extra match() vars\n                                    vars && M_VARS.indexOf(vars) < 0 && (M_VARS[M_VARS.length] = vars);\n                                }\n                                // extension source code\n                                source = result.source;\n                                // extension status code\n                                status = result.status;\n                                // break on status error\n                                if (status) {\n                                    break;\n                                }\n                            }\n                        }\n                        if (!status) {\n                            emit(\"unknown pseudo-class selector '\" + selector + \"'\");\n                            return \"\";\n                        }\n                        if (!expr) {\n                            emit(\"unknown token in selector '\" + selector + \"'\");\n                            return \"\";\n                        }\n                    }\n                    break;\n                default:\n                    emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                    break selector_recursion_label;\n            }\n            // end of switch symbol\n            if (!match) {\n                emit(\"'\" + selector_string + \"'\" + qsInvalid);\n                return \"\";\n            }\n            // pop last component\n            selector = match.pop();\n        }\n        // end of while selector\n        return source;\n    }, // replace :scope context element as a\n    // a reference in the selector string\n    makeref = function(selectors, element) {\n        // replace DOCUMENT with first element (root)\n        if (element.nodeType === 9) {\n            element = element.documentElement;\n        }\n        return selectors.replace(/:scope/i, element.localName + (element.id ? \"#\" + escape(element.id) : \"\") + (element.className ? \".\" + escape(element.classList[0]) : \"\"));\n    }, // equivalent of w3c 'closest' method\n    ancestor = function _closest(selectors, element, callback) {\n        parse(selectors, true);\n        selectors = makeref(selectors, element);\n        while(element){\n            if (match(selectors, element, callback)) break;\n            element = element.parentElement;\n        }\n        return element;\n    }, match_assert = function(f, element, callback) {\n        for(var i = 0, l = f.length, r = false; l > i; ++i)f[i](element, callback, null, false) && (r = true);\n        return r;\n    }, match_collect = function(selectors, callback) {\n        for(var i = 0, l = selectors.length, f = []; l > i; ++i)f[i] = compile(selectors[i], false, callback);\n        return {\n            factory: f\n        };\n    }, // unique parser entry point for all\n    // methods (type matching/selecting)\n    parse = function(selectors, type) {\n        var parsed;\n        // arguments validation\n        if (arguments.length === 0) {\n            emit(qsNotArgs, TypeError);\n            return Config.VERBOSITY ? undefined : type ? none : false;\n        } else if (arguments[0] === \"\") {\n            emit(\"''\" + qsInvalid);\n            return Config.VERBOSITY ? undefined : type ? none : false;\n        }\n        // input NULL or UNDEFINED\n        if (typeof selectors != \"string\") {\n            selectors = \"\" + selectors;\n        }\n        if (/:scope/i.test(selectors)) {\n            selectors = makeref(selectors, Snapshot.from);\n        }\n        // normalize input string\n        parsed = selectors.replace(/\\x00|\\\\$/g, \"ï¿½\").replace(REX.CombineWSP, \" \").replace(REX.PseudosWSP, \"$1\").replace(REX.TabCharWSP, \"\t\").replace(REX.CommaGroup, \",\").replace(REX.TrimSpaces, \"\");\n        // parse, validate and split possible compound selectors\n        if ((selectors = parsed.match(reValidator)) && selectors.join(\"\") == parsed) {\n            selectors = parsed.match(REX.SplitGroup);\n            if (parsed[parsed.length - 1] == \",\") {\n                emit(qsInvalid);\n                return Config.VERBOSITY ? undefined : type ? none : false;\n            }\n        } else {\n            emit(\"'\" + selectors + \"'\" + qsInvalid);\n            return Config.VERBOSITY ? undefined : type ? none : false;\n        }\n        return selectors;\n    }, // equivalent of w3c 'matches' method\n    match = function _matches(selectors, element, callback) {\n        if (element && matchResolvers[selectors]) {\n            return match_assert(matchResolvers[selectors].factory, element, callback);\n        }\n        matchResolvers[selectors] = match_collect(parse(selectors, false), callback);\n        return match_assert(matchResolvers[selectors].factory, element, callback);\n    }, // equivalent of w3c 'querySelector' method\n    first = function _querySelector(selectors, context, callback) {\n        return select(selectors, context, typeof callback == \"function\" ? function firstMatch(element) {\n            callback(element);\n            return false;\n        } : function firstMatch() {\n            return false;\n        })[0] || null;\n    }, // equivalent of w3c 'querySelectorAll' method\n    select = function _querySelectorAll(selectors, context, callback) {\n        var nodes = [], resolver;\n        arguments.length == 0 && emit(qsNotArgs, TypeError);\n        context || (context = doc);\n        lastContext !== context && (lastContext = switchContext(context));\n        if (selectors) {\n            if (resolver = selectResolvers[selectors]) {\n                if (resolver.context === context && resolver.callback === callback) {\n                    var f = resolver.factory, h = resolver.htmlset, n = resolver.nodeset;\n                    if (n.length > 1) {\n                        for(var i = 0, l = n.length, list; l > i; ++i){\n                            list = compat[n[i][0]](context, n[i].slice(1))();\n                            if (f[i] !== null) {\n                                f[i](list, callback, context, nodes);\n                            } else {\n                                nodes = nodes.concat(list);\n                            }\n                        }\n                        if (l > 1 && nodes.length > 1) {\n                            nodes.sort(documentOrder);\n                            hasDupes && (nodes = unique(nodes));\n                        }\n                    } else {\n                        if (f[0]) {\n                            nodes = f[0](h[0](), callback, context, nodes);\n                        } else {\n                            nodes = h[0]();\n                        }\n                    }\n                    if (typeof callback == \"function\") {\n                        nodes = concatCall(nodes, callback);\n                    }\n                    return !Config.ANODELIST ? nodes : nodes instanceof global.NodeList ? nodes : toNodeList(nodes);\n                }\n            }\n        }\n        // save/reuse factory and closure collection\n        selectResolvers[selectors] = collect(parse(selectors, true), context, callback);\n        nodes = selectResolvers[selectors].results;\n        if (typeof callback == \"function\") {\n            nodes = concatCall(nodes, callback);\n        }\n        return !Config.ANODELIST ? nodes : nodes instanceof global.NodeList ? nodes : toNodeList(nodes);\n    }, // optimize selectors avoiding duplicated checks\n    optimize = function(selector, token) {\n        var index = token.index, length = token[1].length + token[2].length;\n        return selector.slice(0, index) + (\" >+~\".indexOf(selector.charAt(index - 1)) > -1 ? \":[\".indexOf(selector.charAt(index + length + 1)) > -1 ? \"*\" : \"\" : \"\") + selector.slice(index + length - (token[1] == \"*\" ? 1 : 0));\n    }, // prepare factory resolvers and closure collections\n    collect = function(selectors, context, callback) {\n        var i, l, seen = {}, token = [\n            \"\",\n            \"*\",\n            \"*\"\n        ], optimized = selectors, factory = [], htmlset = [], nodeset = [], results = [], type;\n        for(i = 0, l = selectors.length; l > i; ++i){\n            if (!seen[selectors[i]] && (seen[selectors[i]] = true)) {\n                type = selectors[i].match(reOptimizer);\n                if (type && type[1] != \":\" && (token = type)) {\n                    token[1] || (token[1] = \"*\");\n                    optimized[i] = optimize(optimized[i], token);\n                } else {\n                    token = [\n                        \"\",\n                        \"*\",\n                        \"*\"\n                    ];\n                }\n            }\n            nodeset[i] = token[1] + token[2];\n            htmlset[i] = compat[token[1]](context, token[2]);\n            factory[i] = compile(optimized[i], true, null);\n            factory[i] ? factory[i](htmlset[i](), callback, context, results) : results.concat(htmlset[i]());\n        }\n        if (l > 1) {\n            results.sort(documentOrder);\n            hasDupes && (results = unique(results));\n        }\n        return {\n            callback: callback,\n            context: context,\n            factory: factory,\n            htmlset: htmlset,\n            nodeset: nodeset,\n            results: results\n        };\n    }, // handlers needed for the :hover pseudo-class\n    // track state change in browsers and headless\n    initEnv = function() {\n        doc.addEventListener(\"mouseover\", function(e) {\n            Snapshot.HOVER = e.target;\n        }, true);\n        doc.addEventListener(\"mouseout\", function(e) {\n            Snapshot.HOVER = null;\n        }, true);\n    }(), // QSA placeholders to native references\n    _closest, _matches, _querySelector, _querySelectorAll, _querySelectorDoc, _querySelectorAllDoc, // overrides QSA methods (only for browsers)\n    install = function(all) {\n        // save references\n        _closest = Element.prototype.closest;\n        _matches = Element.prototype.matches;\n        _querySelector = Element.prototype.querySelector;\n        _querySelectorAll = Element.prototype.querySelectorAll;\n        _querySelectorDoc = Document.prototype.querySelector;\n        _querySelectorAllDoc = Document.prototype.querySelectorAll;\n        function parseQSArgs() {\n            var method = arguments[arguments.length - 1];\n            return arguments.length < 2 ? method.apply(this, []) : arguments.length < 3 ? method.apply(this, [\n                arguments[0],\n                this\n            ]) : method.apply(this, [\n                arguments[0],\n                this,\n                typeof arguments[1] == \"function\" ? arguments[1] : undefined\n            ]);\n        }\n        Element.prototype.closest = HTMLElement.prototype.closest = function closest() {\n            return parseQSArgs.apply(this, [].slice.call(arguments).concat(ancestor));\n        };\n        Element.prototype.matches = HTMLElement.prototype.matches = function matches() {\n            return parseQSArgs.apply(this, [].slice.call(arguments).concat(match));\n        };\n        Element.prototype.querySelector = HTMLElement.prototype.querySelector = function querySelector() {\n            return parseQSArgs.apply(this, [].slice.call(arguments).concat(first));\n        };\n        Element.prototype.querySelectorAll = HTMLElement.prototype.querySelectorAll = function querySelectorAll() {\n            return parseQSArgs.apply(this, [].slice.call(arguments).concat(select));\n        };\n        Document.prototype.querySelector = DocumentFragment.prototype.querySelector = function querySelector() {\n            return parseQSArgs.apply(this, [].slice.call(arguments).concat(first));\n        };\n        Document.prototype.querySelectorAll = DocumentFragment.prototype.querySelectorAll = function querySelectorAll() {\n            return parseQSArgs.apply(this, [].slice.call(arguments).concat(select));\n        };\n        if (all) {\n            doc.addEventListener(\"load\", function(e) {\n                var c, d, r, s, t = e.target;\n                if (/iframe/i.test(t.localName)) {\n                    c = \"(\" + Export + \")(this, \" + Factory + \");\";\n                    d = t.ownerDocument;\n                    s = d.createElement(\"script\");\n                    s.textContent = c + \"NW.Dom.install(true)\";\n                    r = d.documentElement;\n                    r.removeChild(r.insertBefore(s, r.firstChild));\n                }\n            }, true);\n        }\n    }, // restore QSA methods (only for browsers)\n    uninstall = function() {\n        // restore references\n        if (_closest) {\n            Element.prototype.closest = _closest;\n            HTMLElement.prototype.closest = _closest;\n        }\n        if (_matches) {\n            Element.prototype.matches = _matches;\n            HTMLElement.prototype.matches = _matches;\n        }\n        if (_querySelector) {\n            Element.prototype.querySelector = HTMLElement.prototype.querySelector = _querySelector;\n            Element.prototype.querySelectorAll = HTMLElement.prototype.querySelectorAll = _querySelector;\n        }\n        if (_querySelectorAllDoc) {\n            Document.prototype.querySelector = DocumentFragment.prototype.querySelector = _querySelectorDoc;\n            Document.prototype.querySelectorAll = DocumentFragment.prototype.querySelectorAll = _querySelectorAllDoc;\n        }\n    }, // empty set\n    none = Array(), // context\n    lastContext, // selector\n    lastMatched, lastSelected, // cached lambdas\n    matchLambdas = {}, selectLambdas = {}, // cached resolvers\n    matchResolvers = {}, selectResolvers = {}, // passed to resolvers\n    Snapshot = {\n        doc: doc,\n        from: doc,\n        root: root,\n        byTag: byTag,\n        first: first,\n        match: match,\n        ancestor: ancestor,\n        nthOfType: nthOfType,\n        nthElement: nthElement,\n        isFocusable: isFocusable,\n        isContentEditable: isContentEditable,\n        hasAttributeNS: hasAttributeNS\n    }, // public exported methods/objects\n    Dom = {\n        // exported cache objects\n        lastMatched: lastMatched,\n        lastSelected: lastSelected,\n        matchLambdas: matchLambdas,\n        selectLambdas: selectLambdas,\n        matchResolvers: matchResolvers,\n        selectResolvers: selectResolvers,\n        // exported compiler macros\n        CFG: CFG,\n        S_BODY: S_BODY,\n        M_BODY: M_BODY,\n        N_BODY: M_BODY,\n        S_TEST: S_TEST,\n        M_TEST: M_TEST,\n        N_TEST: N_TEST,\n        // exported engine methods\n        byId: byId,\n        byTag: byTag,\n        byClass: byClass,\n        match: match,\n        first: first,\n        select: select,\n        closest: ancestor,\n        compile: compile,\n        configure: configure,\n        emit: emit,\n        Config: Config,\n        Snapshot: Snapshot,\n        Version: version,\n        install: install,\n        uninstall: uninstall,\n        Operators: Operators,\n        Selectors: Selectors,\n        // register a new selector combinator symbol and its related function resolver\n        registerCombinator: function(combinator, resolver) {\n            var i = 0, l = combinator.length, symbol;\n            for(; l > i; ++i){\n                if (combinator[i] != \"=\") {\n                    symbol = combinator[i];\n                    break;\n                }\n            }\n            if (CFG.combinators.indexOf(symbol) < 0) {\n                CFG.combinators = CFG.combinators.replace(\"](\", symbol + \"](\");\n                CFG.combinators = CFG.combinators.replace(\"])\", symbol + \"])\");\n                Combinators[combinator] = resolver;\n                setIdentifierSyntax();\n            } else {\n                console.warn(\"Warning: the '\" + combinator + \"' combinator is already registered.\");\n            }\n        },\n        // register a new attribute operator symbol and its related function resolver\n        registerOperator: function(operator, resolver) {\n            var i = 0, l = operator.length, symbol;\n            for(; l > i; ++i){\n                if (operator[i] != \"=\") {\n                    symbol = operator[i];\n                    break;\n                }\n            }\n            if (CFG.operators.indexOf(symbol) < 0 && !Operators[operator]) {\n                CFG.operators = CFG.operators.replace(\"]=\", symbol + \"]=\");\n                Operators[operator] = resolver;\n                setIdentifierSyntax();\n            } else {\n                console.warn(\"Warning: the '\" + operator + \"' operator is already registered.\");\n            }\n        },\n        // register a new selector symbol and its related function resolver\n        registerSelector: function(name, rexp, func) {\n            Selectors[name] || (Selectors[name] = {\n                Expression: rexp,\n                Callback: func\n            });\n        }\n    };\n    initialize(doc);\n    return Dom;\n});\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvbndzYXBpL3NyYy9ud3NhcGkuanMiLCJtYXBwaW5ncyI6IkFBQUE7Ozs7Ozs7Ozs7Ozs7OztDQWVDLEdBRUEsVUFBU0EsT0FBT0MsTUFBTSxFQUFFQyxPQUFPO0lBRTlCO0lBRUEsSUFBSSxJQUErQyxFQUFVO1FBQzNEQyxPQUFPQyxPQUFPLEdBQUdGO0lBQ25CLE9BQU8sRUFLTjtBQUVILEdBQUcsSUFBSSxFQUFFLFNBQVNNLFFBQVFQLE1BQU0sRUFBRUQsTUFBTTtJQUV0QyxJQUFJUyxVQUFVLGlCQUVkQyxNQUFNVCxPQUFPVSxRQUFRLEVBQ3JCQyxPQUFPRixJQUFJRyxlQUFlLEVBQzFCQyxRQUFRQyxNQUFNQyxTQUFTLENBQUNGLEtBQUssRUFFN0JHLE1BQU0sY0FDTkMsTUFBTSxlQUNOQyxNQUFNLHVCQUVOQyxNQUFNO1FBQ0osYUFBYTtRQUNiQyxXQUFXO1FBQ1hDLGFBQWE7SUFDZixHQUVBQyxNQUFNO1FBQ0osOENBQThDO1FBQzlDQyxZQUFZO1FBQ1pDLFlBQVk7UUFDWkMsWUFBWTtRQUNaQyxZQUFZO0lBQ2QsR0FFQUMsTUFBTTtRQUNKLHNCQUFzQjtRQUN0QkMsWUFBWUMsT0FBTztRQUNuQkMsWUFBWUQsT0FBTztRQUNuQkUsWUFBWUYsT0FBTztRQUNuQkcsWUFBWUgsT0FBTyxxQ0FBcUM7UUFDeERJLFlBQVlKLE9BQU8sTUFBTVgsTUFBTSxPQUFPQSxNQUFNLFFBQVFELEtBQUs7UUFDekRpQixZQUFZTCxPQUFPLHlDQUF5QztRQUM1RE0sWUFBWU4sT0FBTyxnQkFBZ0JQLElBQUlJLFVBQVUsR0FBR0osSUFBSUcsVUFBVSxFQUFFO1FBQ3BFVyxZQUFZUCxPQUFPLDBCQUEwQlgsTUFBTSx1QkFBdUI7UUFDMUVtQixZQUFZUixPQUFPLHNCQUFzQlAsSUFBSUUsVUFBVSxHQUFHRixJQUFJQyxVQUFVLEVBQUU7UUFDMUVlLFlBQVlULE9BQU8sdUJBQXVCUCxJQUFJRSxVQUFVLEdBQUdGLElBQUlDLFVBQVUsRUFBRTtR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RUYsNkVBQTZFO1FBQzdFMFQsa0JBQ0UsU0FBU0MsUUFBUSxFQUFFMUMsUUFBUTtZQUN6QixJQUFJN04sSUFBSSxHQUFHQyxJQUFJc1EsU0FBU3JRLE1BQU0sRUFBRTRMO1lBQ2hDLE1BQU83TCxJQUFJRCxHQUFHLEVBQUVBLEVBQUc7Z0JBQ2pCLElBQUl1USxRQUFRLENBQUN2USxFQUFFLElBQUksS0FBSztvQkFDdEI4TCxTQUFTeUUsUUFBUSxDQUFDdlEsRUFBRTtvQkFDcEI7Z0JBQ0Y7WUFDRjtZQUNBLElBQUkxRSxJQUFJQyxTQUFTLENBQUMyRyxPQUFPLENBQUM0SixVQUFVLEtBQUssQ0FBQ3JNLFNBQVMsQ0FBQzhRLFNBQVMsRUFBRTtnQkFDN0RqVixJQUFJQyxTQUFTLEdBQUdELElBQUlDLFNBQVMsQ0FBQzJILE9BQU8sQ0FBQyxNQUFNNEksU0FBUztnQkFDckRyTSxTQUFTLENBQUM4USxTQUFTLEdBQUcxQztnQkFDdEJsRztZQUNGLE9BQU87Z0JBQ0xNLFFBQVFvSSxJQUFJLENBQUMsbUJBQW9CRSxXQUFXO1lBQzlDO1FBQ0Y7UUFFRixtRUFBbUU7UUFDbkVDLGtCQUNFLFNBQVNwTCxJQUFJLEVBQUVxTCxJQUFJLEVBQUVDLElBQUk7WUFDdkJsUixTQUFTLENBQUM0RixLQUFLLElBQUs1RixDQUFBQSxTQUFTLENBQUM0RixLQUFLLEdBQUc7Z0JBQ3BDbUgsWUFBWWtFO2dCQUNaakUsVUFBVWtFO1lBQ1o7UUFDRjtJQUNKO0lBRUF2SSxXQUFXdk47SUFFWCxPQUFPSDtBQUNUIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcHB0eC1lZGl0b3IvLi9ub2RlX21vZHVsZXMvbndzYXBpL3NyYy9ud3NhcGkuanM/YjNjNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICogQ29weXJpZ2h0IChDKSAyMDA3LTIwMjUgRGllZ28gUGVyaW5pXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIG53c2FwaS5qcyAtIEZhc3QgQ1NTIFNlbGVjdG9ycyBBUEkgRW5naW5lXG4gKlxuICogQXV0aG9yOiBEaWVnbyBQZXJpbmkgPGRpZWdvLnBlcmluaSBhdCBnbWFpbCBjb20+XG4gKiBWZXJzaW9uOiAyLjIuMjFcbiAqIENyZWF0ZWQ6IDIwMDcwNzIyXG4gKiBSZWxlYXNlOiAyMDI1MDcyNlxuICpcbiAqIExpY2Vuc2U6XG4gKiAgaHR0cHM6Ly9qYXZhc2NyaXB0Lm53Ym94LmNvbS9ud3NhcGkvTUlULUxJQ0VOU0VcbiAqIERvd25sb2FkOlxuICogIGh0dHBzOi8vamF2YXNjcmlwdC5ud2JveC5jb20vbndzYXBpL253c2FwaS5qc1xuICovXG5cbihmdW5jdGlvbiBFeHBvcnQoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cbiAgJ3VzZSBzdHJpY3QnO1xuXG4gIGlmICh0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmVbJ2FtZCddKSB7XG4gICAgZGVmaW5lKGZhY3RvcnkpO1xuICB9IGVsc2Uge1xuICAgIGdsb2JhbC5OVyB8fCAoZ2xvYmFsLk5XID0geyB9KTtcbiAgICBnbG9iYWwuTlcuRG9tID0gZmFjdG9yeShnbG9iYWwsIEV4cG9ydCk7XG4gIH1cblxufSkodGhpcywgZnVuY3Rpb24gRmFjdG9yeShnbG9iYWwsIEV4cG9ydCkge1xuXG4gIHZhciB2ZXJzaW9uID0gJ253c2FwaS0yLjIuMjEnLFxuXG4gIGRvYyA9IGdsb2JhbC5kb2N1bWVudCxcbiAgcm9vdCA9IGRvYy5kb2N1bWVudEVsZW1lbnQsXG4gIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLFxuXG4gIEhTUCA9ICdbXFxcXHgyMFxcXFx0XScsXG4gIFZTUCA9ICdbXFxcXHJcXFxcblxcXFxmXScsXG4gIFdTUCA9ICdbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXScsXG5cbiAgQ0ZHID0ge1xuICAgIC8vIGV4dGVuc2lvbnNcbiAgICBvcGVyYXRvcnM6ICdbfipeJHxdPXw9JyxcbiAgICBjb21iaW5hdG9yczogJ1tcXFxceDIwXFxcXHQ+K35dKD89W14+K35dKSdcbiAgfSxcblxuICBOT1QgPSB7XG4gICAgLy8gbm90IGVuY2xvc2VkIGluIGRvdWJsZS9zaW5nbGUvcGFyZW5zL3NxdWFyZVxuICAgIGRvdWJsZV9lbmM6ICcoPz0oPzpbXlwiXSpbXCJdW15cIl0qW1wiXSkqW15cIl0qJCknLFxuICAgIHNpbmdsZV9lbmM6IFwiKD89KD86W14nXSpbJ11bXiddKlsnXSkqW14nXSokKVwiLFxuICAgIHBhcmVuc19lbmM6ICcoPyFbXlxcXFx4MjhdKlxcXFx4MjkpJyxcbiAgICBzcXVhcmVfZW5jOiAnKD8hW15cXFxceDViXSpcXFxceDVkKSdcbiAgfSxcblxuICBSRVggPSB7XG4gICAgLy8gcmVndWxhciBleHByZXNzaW9uc1xuICAgIEhhc0VzY2FwZXM6IFJlZ0V4cCgnXFxcXFxcXFwnKSxcbiAgICBIZXhOdW1iZXJzOiBSZWdFeHAoJ15bMC05YS1mQS1GXScpLFxuICAgIEVzY09yUXVvdGU6IFJlZ0V4cCgnXlxcXFxcXFxcfFtcXFxceDIyXFxcXHgyN10nKSxcbiAgICBSZWdFeHBDaGFyOiBSZWdFeHAoJyg/IVxcXFxcXFxcKVtcXFxcXFxcXF4kLiwqKz8oKVtcXFxcXXt9fFxcXFwvXScsICdnJyksXG4gICAgVHJpbVNwYWNlczogUmVnRXhwKCdeJyArIFdTUCArICcrfCcgKyBXU1AgKyAnKyR8JyArIFZTUCwgJ2cnKSxcbiAgICBTcGxpdEdyb3VwOiBSZWdFeHAoJyhcXFxcKFteKV0qXFxcXCl8XFxcXFtbXltdKlxcXFxdfFxcXFxcXFxcLnxbXixdKSsnLCAnZycpLFxuICAgIENvbW1hR3JvdXA6IFJlZ0V4cCgnKFxcXFxzKixcXFxccyopJyArIE5PVC5zcXVhcmVfZW5jICsgTk9ULnBhcmVuc19lbmMsICdnJyksXG4gICAgRml4RXNjYXBlczogUmVnRXhwKCdcXFxcXFxcXChbMC05YS1mQS1GXXsxLDZ9JyArIFdTUCArICc/fC4pfChbXFxcXHgyMlxcXFx4MjddKScsICdnJyksXG4gICAgQ29tYmluZVdTUDogUmVnRXhwKCdbXFxcXG5cXFxcclxcXFxmXFxcXHgyMF0rJyArIE5PVC5zaW5nbGVfZW5jICsgTk9ULmRvdWJsZV9lbmMsICdnJyksXG4gICAgVGFiQ2hhcldTUDogUmVnRXhwKCcoXFxcXHgyMD9cXFxcdCtcXFxceDIwPyknICsgTk9ULnNpbmdsZV9lbmMgKyBOT1QuZG91YmxlX2VuYywgJ2cnKSxcbiAgICBQc2V1ZG9zV1NQOiBSZWdFeHAoJ1xcXFxzKyhbLStdKVxcXFxzKycgKyBOT1Quc3F1YXJlX2VuYywgJ2cnKVxuICB9LFxuXG4gIFNURCA9IHtcbiAgICBjb21iaW5hdG9yOiBSZWdFeHAoJ1xcXFxzPyhbPit+XSlcXFxccz8nLCAnZycpLFxuICAgIGFwaW1ldGhvZHM6IFJlZ0V4cCgnXig/OlxcXFx3K3xcXFxcKilcXFxcfCcpLFxuICAgIG5hbWVzcGFjZXM6IFJlZ0V4cCgnKFxcXFwqfFxcXFx3KylcXFxcfFtcXFxcdy1dKycpXG4gIH0sXG5cbiAgR1JPVVBTID0ge1xuICAgIC8vIHBzZXVkby1jbGFzc2VzIHJlcXVpcmluZyBwYXJhbWV0ZXJzXG4gICAgbGluZ3Vpc3RpYzogJyhkaXJ8bGFuZykoPzpcXFxceDI4XFxcXHM/KFstXFxcXHddezIsfSlcXFxccz9cXFxceDI5KScsXG4gICAgbG9naWNhbHNlbDogJyhpc3x3aGVyZXxtYXRjaGVzfG5vdHxoYXMpKD86XFxcXHgyOFxcXFxzPygnICsgJ1teKCldKnwuKicgKyAnKVxcXFxzP1xcXFx4MjkpJyxcbiAgICB0cmVlc3RydWN0OiAnKG50aCg/Oi1sYXN0KT8oPzotY2hpbGR8LW9mXFxcXC10eXBlKSkoPzpcXFxceDI4XFxcXHM/KGV2ZW58b2RkfCg/OlstK10/XFxcXGQqKSg/Om5cXFxccz9bLStdP1xcXFxzP1xcXFxkKik/KVxcXFxzP1xcXFx4MjkpJyxcbiAgICAvLyBwc2V1ZG8tY2xhc3NlcyBub3QgcmVxdWlyaW5nIHBhcmFtZXRlcnNcbiAgICBsb2NhdGlvbnBjOiAnKGFueVxcXFwtbGlua3xsaW5rfHZpc2l0ZWR8dGFyZ2V0fGRlZmluZWQpXFxcXGInLFxuICAgIHVzZXJhY3Rpb246ICcoaG92ZXJ8YWN0aXZlfGZvY3VzXFxcXC13aXRoaW58Zm9jdXNcXFxcLXZpc2libGV8Zm9jdXMpXFxcXGInLFxuICAgIHN0cnVjdHVyYWw6ICcoc2NvcGV8cm9vdHxlbXB0eXwoPzooPzpmaXJzdHxsYXN0fG9ubHkpKD86LWNoaWxkfFxcXFwtb2ZcXFxcLXR5cGUpKSlcXFxcYicsXG4gICAgaW5wdXRzdGF0ZTogJyhlbmFibGVkfGRpc2FibGVkfHJlYWRcXFxcLW9ubHl8cmVhZFxcXFwtd3JpdGV8cGxhY2Vob2xkZXJcXFxcLXNob3dufGRlZmF1bHQpXFxcXGInLFxuICAgIGlucHV0dmFsdWU6ICcoY2hlY2tlZHxpbmRldGVybWluYXRlfHJlcXVpcmVkfG9wdGlvbmFsfHZhbGlkfGludmFsaWR8aW5cXFxcLXJhbmdlfG91dFxcXFwtb2ZcXFxcLXJhbmdlKVxcXFxiJyxcbiAgICAvLyBwc2V1ZG8tY2xhc3NlcyBub3QgcmVxdWlyaW5nIHBhcmFtZXRlcnMgYW5kIGRlc2NyaWJpbmcgZnVuY3Rpb25hbCBzdGF0ZVxuICAgIHJzcmNfc3RhdGU6ICcocGxheWluZ3xwYXVzZWR8c2Vla2luZ3xidWZmZXJpbmd8c3RhbGxlZHxtdXRlZHx2b2x1bWUtbG9ja2VkKVxcXFxiJyxcbiAgICBkaXNwX3N0YXRlOiAnKG9wZW58Y2xvc2VkfG1vZGFsfGZ1bGxzY3JlZW58cGljdHVyZS1pbi1waWN0dXJlKVxcXFxiJyxcbiAgICB0aW1lX3N0YXRlOiAnKGN1cnJlbnR8cGFzdHxmdXR1cmUpXFxcXGInLFxuICAgIC8vIHBzZXVkby1jbGFzc2VzIGZvciBwYXJzaW5nIG9ubHkgc2VsZWN0b3JzXG4gICAgcHNldWRvX25vcDogJyhhdXRvZmlsbHwtd2Via2l0XFxcXC1hdXRvZmlsbClcXFxcYicsXG4gICAgLy8gcHNldWRvLWVsZW1lbnRzIHN0YXJ0aW5nIHdpdGggc2luZ2xlIGNvbG9uICg6KVxuICAgIHBzZXVkb19zbmc6ICcoYWZ0ZXJ8YmVmb3JlfGZpcnN0XFxcXC1sZXR0ZXJ8Zmlyc3RcXFxcLWxpbmUpXFxcXGInLFxuICAgIC8vIHBzZXVkby1lbGVtZW50cyBzdGFydGluZyB3aXRoIGRvdWJsZSBjb2xvbiAoOjopXG4gICAgcHNldWRvX2RibDogJzooYWZ0ZXJ8YmVmb3JlfGZpcnN0XFxcXC1sZXR0ZXJ8Zmlyc3RcXFxcLWxpbmV8c2VsZWN0aW9ufHBsYWNlaG9sZGVyfC13ZWJraXQtWy1hLXpBLVowLTldezIsfSlcXFxcYidcbiAgfSxcblxuICBQYXR0ZXJucyA9IHtcbiAgICAvLyBwc2V1ZG8tY2xhc3Nlc1xuICAgIHRyZWVzdHJ1Y3Q6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLnRyZWVzdHJ1Y3QgKyAnKSguKiknLCAnaScpLFxuICAgIHN0cnVjdHVyYWw6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLnN0cnVjdHVyYWwgKyAnKSguKiknLCAnaScpLFxuICAgIGxpbmd1aXN0aWM6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLmxpbmd1aXN0aWMgKyAnKSguKiknLCAnaScpLFxuICAgIHVzZXJhY3Rpb246IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLnVzZXJhY3Rpb24gKyAnKSguKiknLCAnaScpLFxuICAgIGlucHV0c3RhdGU6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLmlucHV0c3RhdGUgKyAnKSguKiknLCAnaScpLFxuICAgIGlucHV0dmFsdWU6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLmlucHV0dmFsdWUgKyAnKSguKiknLCAnaScpLFxuICAgIHJzcmNfc3RhdGU6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLnJzcmNfc3RhdGUgKyAnKSguKiknLCAnaScpLFxuICAgIGRpc3Bfc3RhdGU6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLmRpc3Bfc3RhdGUgKyAnKSguKiknLCAnaScpLFxuICAgIHRpbWVfc3RhdGU6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLnRpbWVfc3RhdGUgKyAnKSguKiknLCAnaScpLFxuICAgIGxvY2F0aW9ucGM6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLmxvY2F0aW9ucGMgKyAnKSguKiknLCAnaScpLFxuICAgIGxvZ2ljYWxzZWw6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLmxvZ2ljYWxzZWwgKyAnKSguKiknLCAnaScpLFxuICAgIHBzZXVkb19ub3A6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLnBzZXVkb19ub3AgKyAnKSguKiknLCAnaScpLFxuICAgIHBzZXVkb19zbmc6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLnBzZXVkb19zbmcgKyAnKSguKiknLCAnaScpLFxuICAgIHBzZXVkb19kYmw6IFJlZ0V4cCgnXjooPzonICsgR1JPVVBTLnBzZXVkb19kYmwgKyAnKSguKiknLCAnaScpLFxuICAgIC8vIGNvbWJpbmF0b3Igc3ltYm9sc1xuICAgIGNoaWxkcmVuOiBSZWdFeHAoJ14nICsgV1NQICsgJz9cXFxcPicgKyBXU1AgKyAnPyguKiknKSxcbiAgICBhZGphY2VudDogUmVnRXhwKCdeJyArIFdTUCArICc/XFxcXCsnICsgV1NQICsgJz8oLiopJyksXG4gICAgcmVsYXRpdmU6IFJlZ0V4cCgnXicgKyBXU1AgKyAnP1xcXFx+JyArIFdTUCArICc/KC4qKScpLFxuICAgIGFuY2VzdG9yOiBSZWdFeHAoJ14nICsgV1NQICsgJysoLiopJyksXG4gICAvLyB1bml2ZXJzYWwgJiBuYW1lc3BhY2VcbiAgIHVuaXZlcnNhbDogUmVnRXhwKCdeKFxcXFwqKSguKiknKSxcbiAgIG5hbWVzcGFjZTogUmVnRXhwKCdeKFxcXFwqfFtcXFxcdy1dKyk/XFxcXHwoLiopJylcbiAgfSxcblxuICAvLyByZWdleHAgdG8gYmV0dGVyIGFwcm94aW1hdGUgZGV0ZWN0aW9uIG9mIFJUTCBsYW5ndWFnZXMgKEFyYWJpYylcbiAgUlRMID0gUmVnRXhwKCdeKD86W1xcXFx1MDYyNy1cXFxcdTA2NGFdfFtcXFxcdTA1OTEtXFxcXHUwOGZmXXxbXFxcXHVmYjFkLVxcXFx1ZmRmZF18W1xcXFx1ZmU3MC1cXFxcdWZlZmNdKSskJyksXG5cbiAgLy8gZW11bGF0ZSBmaXJlZm94IGVycm9yIHN0cmluZ3NcbiAgcXNOb3RBcmdzID0gJ05vdCBlbm91Z2ggYXJndW1lbnRzJyxcbiAgcXNJbnZhbGlkID0gJyBpcyBub3QgYSB2YWxpZCBzZWxlY3RvcicsXG5cbiAgLy8gZGV0ZWN0IHN0cnVjdHVyYWwgcHNldWRvLWNsYXNzZXMgaW4gc2VsZWN0b3JzXG4gIHJlTnRoRWxlbSA9IFJlZ0V4cCgnKDpudGgoPzotbGFzdCk/LWNoaWxkKScsICdpJyksXG4gIHJlTnRoVHlwZSA9IFJlZ0V4cCgnKDpudGgoPzotbGFzdCk/LW9mLXR5cGUpJywgJ2knKSxcblxuICAvLyBwbGFjZWhvbGRlciBmb3IgZ2xvYmFsIHJlZ2V4cFxuICByZU9wdGltaXplcixcbiAgcmVWYWxpZGF0b3IsXG5cbiAgLy8gc3BlY2lhbCBoYW5kbGluZyBjb25maWd1cmF0aW9uIGZsYWdzXG4gIENvbmZpZyA9IHtcbiAgICBJRFNfRFVQRVM6IHRydWUsXG4gICAgQU5PREVMSVNUOiBmYWxzZSxcbiAgICBMT0dFUlJPUlM6IHRydWUsXG4gICAgVVNSX0VWRU5UOiB0cnVlLFxuICAgIFZFUkJPU0lUWTogdHJ1ZVxuICB9LFxuXG4gIE5BTUVTUEFDRSxcbiAgUVVJUktTX01PREUsXG4gIEhUTUxfRE9DVU1FTlQsXG5cbiAgQVRUUl9TVERfT1BTID0ge1xuICAgICc9JzogMSwgJ149JzogMSwgJyQ9JzogMSwgJ3w9JzogMSwgJyo9JzogMSwgJ349JzogMVxuICB9LFxuXG4gIEhUTUxfVEFCTEUgPSB7XG4gICAgJ2FjY2VwdCc6IDEsICdhY2NlcHQtY2hhcnNldCc6IDEsICdhbGlnbic6IDEsICdhbGluayc6IDEsICdheGlzJzogMSxcbiAgICAnYmdjb2xvcic6IDEsICdjaGFyc2V0JzogMSwgJ2NoZWNrZWQnOiAxLCAnY2xlYXInOiAxLCAnY29kZXR5cGUnOiAxLCAnY29sb3InOiAxLFxuICAgICdjb21wYWN0JzogMSwgJ2RlY2xhcmUnOiAxLCAnZGVmZXInOiAxLCAnZGlyJzogMSwgJ2RpcmVjdGlvbic6IDEsICdkaXNhYmxlZCc6IDEsXG4gICAgJ2VuY3R5cGUnOiAxLCAnZmFjZSc6IDEsICdmcmFtZSc6IDEsICdocmVmbGFuZyc6IDEsICdodHRwLWVxdWl2JzogMSwgJ2xhbmcnOiAxLFxuICAgICdsYW5ndWFnZSc6IDEsICdsaW5rJzogMSwgJ21lZGlhJzogMSwgJ21ldGhvZCc6IDEsICdtdWx0aXBsZSc6IDEsICdub2hyZWYnOiAxLFxuICAgICdub3Jlc2l6ZSc6IDEsICdub3NoYWRlJzogMSwgJ25vd3JhcCc6IDEsICdyZWFkb25seSc6IDEsICdyZWwnOiAxLCAncmV2JzogMSxcbiAgICAncnVsZXMnOiAxLCAnc2NvcGUnOiAxLCAnc2Nyb2xsaW5nJzogMSwgJ3NlbGVjdGVkJzogMSwgJ3NoYXBlJzogMSwgJ3RhcmdldCc6IDEsXG4gICAgJ3RleHQnOiAxLCAndHlwZSc6IDEsICd2YWxpZ24nOiAxLCAndmFsdWV0eXBlJzogMSwgJ3ZsaW5rJzogMVxuICB9LFxuXG4gIENvbWJpbmF0b3JzID0geyB9LFxuXG4gIFNlbGVjdG9ycyA9IHsgfSxcblxuICBPcGVyYXRvcnMgPSB7XG4gICAgICc9JzogeyBwMTogJ14nLFxuICAgICAgICAgICAgcDI6ICckJyxcbiAgICAgICAgICAgIHAzOiAndHJ1ZScgfSxcbiAgICAnXj0nOiB7IHAxOiAnXicsXG4gICAgICAgICAgICBwMjogJycsXG4gICAgICAgICAgICBwMzogJ3RydWUnIH0sXG4gICAgJyQ9JzogeyBwMTogJycsXG4gICAgICAgICAgICBwMjogJyQnLFxuICAgICAgICAgICAgcDM6ICd0cnVlJyB9LFxuICAgICcqPSc6IHsgcDE6ICcnLFxuICAgICAgICAgICAgcDI6ICcnLFxuICAgICAgICAgICAgcDM6ICd0cnVlJyB9LFxuICAgICd8PSc6IHsgcDE6ICdeJyxcbiAgICAgICAgICAgIHAyOiAnKC18JCknLFxuICAgICAgICAgICAgcDM6ICd0cnVlJyB9LFxuICAgICd+PSc6IHsgcDE6ICcoXnxcXFxccyknLFxuICAgICAgICAgICAgcDI6ICcoXFxcXHN8JCknLFxuICAgICAgICAgICAgcDM6ICd0cnVlJyB9XG4gIH0sXG5cbiAgY29uY2F0Q2FsbCA9XG4gICAgZnVuY3Rpb24obm9kZXMsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGgsIGxpc3QgPSBBcnJheShsKTtcbiAgICAgIHdoaWxlIChsID4gaSkge1xuICAgICAgICBpZiAoZmFsc2UgPT09IGNhbGxiYWNrKGxpc3RbaV0gPSBub2Rlc1tpXSkpIGJyZWFrO1xuICAgICAgICArK2k7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGlzdDtcbiAgICB9LFxuXG4gIGNvbmNhdExpc3QgPVxuICAgIGZ1bmN0aW9uKGxpc3QsIG5vZGVzKSB7XG4gICAgICB2YXIgaSA9IC0xLCBsID0gbm9kZXMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGwtLSkgeyBsaXN0W2xpc3QubGVuZ3RoXSA9IG5vZGVzWysraV07IH1cbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sXG5cbiAgLy8gb25seSBkZWZpbmUgdGhlIHRvTm9kZUxpc3QgaGVscGVyIGlmIGV4cGxpY2l0bHkgZW5hYmxlZCBpbiBDb25maWcsXG4gIC8vIGEgc2FmZXR5IG1lYXN1cmUgZm9yIGhlYWRsZXNzIGhvc3RzIG1pc3NpbmcgZmVhdHVyZS9pbXBsZW1lbnRhdGlvblxuICB0b05vZGVMaXN0ID1cbiAgICBDb25maWcuQU5PREVMSVNUID09IGZhbHNlID9cbiAgICBmdW5jdGlvbih4KSB7IHJldHVybiB4OyB9IDpcbiAgICBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGNyZWF0ZSBhIERvY3VtZW50RnJhZ21lbnRcbiAgICAgIHZhciBlbXB0eU5MID0gZG9jLmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKS5jaGlsZE5vZGVzO1xuXG4gICAgICAvLyB0aGlzIGlzIHJldHVybmVkIGZyb20gYSBzZWxmLWV4ZWN1dGluZyBmdW5jdGlvbiBzbyB0aGF0XG4gICAgICAvLyB0aGUgRG9jdW1lbnRGcmFnbWVudCBpc24ndCByZXBlYXRlZGx5IGNyZWF0ZWRcbiAgICAgIHJldHVybiBmdW5jdGlvbihub2RlQXJyYXkpIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgaXQgaXMgYWxyZWFkeSBhIG5vZGVsaXN0XG4gICAgICAgIGlmIChub2RlQXJyYXkgaW5zdGFuY2VvZiBnbG9iYWwuTm9kZUxpc3QpIHJldHVybiBub2RlQXJyYXk7XG5cbiAgICAgICAgLy8gaWYgaXQncyBhIHNpbmdsZSBlbGVtZW50LCB3cmFwIGl0IGluIGEgY2xhc3NpYyBhcnJheVxuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkobm9kZUFycmF5KSkgbm9kZUFycmF5ID0gW25vZGVBcnJheV07XG5cbiAgICAgICAgLy8gYmFzZSBhbiBvYmplY3Qgb24gZW1wdHlOTFxuICAgICAgICB2YXIgZmFrZU5MID0gT2JqZWN0LmNyZWF0ZShlbXB0eU5MLCB7XG4gICAgICAgICAgJ2xlbmd0aCc6IHtcbiAgICAgICAgICAgIHZhbHVlOiBub2RlQXJyYXkubGVuZ3RoLCBlbnVtZXJhYmxlOiBmYWxzZVxuICAgICAgICAgIH0sXG4gICAgICAgICAgJ2l0ZW0nOiB7XG4gICAgICAgICAgICAndmFsdWUnOiBmdW5jdGlvbihpKSB7XG4gICAgICAgICAgICAgIHJldHVybiB0aGlzWytpIHx8IDBdO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGVudW1lcmFibGU6IGZhbHNlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBjb3B5IHRoZSBhcnJheSBlbGVtbnRzXG4gICAgICAgIG5vZGVBcnJheS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBpKSB7IGZha2VOTFtpXSA9IHY7IH0pO1xuXG4gICAgICAgIC8vIHJldHVybiBhbiBvYmplY3QgcHJldGVuZGluZyB0byBiZSBhIE5vZGVMaXN0LlxuICAgICAgICByZXR1cm4gZmFrZU5MO1xuICAgICAgfTtcbiAgICB9KCksXG5cbiAgZG9jdW1lbnRPcmRlciA9XG4gICAgZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYgKCFoYXNEdXBlcyAmJiBhID09PSBiKSB7XG4gICAgICAgIGhhc0R1cGVzID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICByZXR1cm4gYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihiKSAmIDQgPyAtMSA6IDE7XG4gICAgfSxcblxuICBoYXNEdXBlcyA9IGZhbHNlLFxuXG4gIHVuaXF1ZSA9XG4gICAgZnVuY3Rpb24obm9kZXMpIHtcbiAgICAgIHZhciBpID0gMCwgaiA9IC0xLCBsID0gbm9kZXMubGVuZ3RoICsgMSwgbGlzdCA9IFsgXTtcbiAgICAgIHdoaWxlICgtLWwpIHtcbiAgICAgICAgaWYgKG5vZGVzW2krK10gPT09IG5vZGVzW2ldKSBjb250aW51ZTtcbiAgICAgICAgbGlzdFsrK2pdID0gbm9kZXNbaSAtIDFdO1xuICAgICAgfVxuICAgICAgaGFzRHVwZXMgPSBmYWxzZTtcbiAgICAgIHJldHVybiBsaXN0O1xuICAgIH0sXG5cbiAgc3dpdGNoQ29udGV4dCA9XG4gICAgZnVuY3Rpb24oY29udGV4dCwgZm9yY2UpIHtcbiAgICAgIHZhciBvbGREb2MgPSBkb2M7XG4gICAgICBkb2MgPSBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dDtcbiAgICAgIGlmIChmb3JjZSB8fCBvbGREb2MgIT09IGRvYykge1xuICAgICAgICAvLyBmb3JjZSBhIG5ldyBjaGVjayBmb3IgZWFjaCBkb2N1bWVudCBjaGFuZ2VcbiAgICAgICAgLy8gcGVyZm9ybWVkIGJlZm9yZSB0aGUgbmV4dCBzZWxlY3Qgb3BlcmF0aW9uXG4gICAgICAgIHJvb3QgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuICAgICAgICBIVE1MX0RPQ1VNRU5UID0gaXNIVE1MKGRvYyk7XG4gICAgICAgIFFVSVJLU19NT0RFID0gSFRNTF9ET0NVTUVOVCAmJlxuICAgICAgICAgIGRvYy5jb21wYXRNb2RlLmluZGV4T2YoJ0NTUycpIDwgMDtcbiAgICAgICAgTkFNRVNQQUNFID0gcm9vdCAmJiByb290Lm5hbWVzcGFjZVVSSTtcbiAgICAgICAgU25hcHNob3QuZG9jID0gZG9jO1xuICAgICAgICBTbmFwc2hvdC5yb290ID0gcm9vdDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAoU25hcHNob3QuZnJvbSA9IGNvbnRleHQpO1xuICAgIH0sXG5cbiAgLy8gY29udmVydCBzaW5nbGUgY29kZXBvaW50IHRvIFVURi0xNiBlbmNvZGluZ1xuICBjb2RlUG9pbnRUb1VURjE2ID1cbiAgICBmdW5jdGlvbihjb2RlUG9pbnQpIHtcbiAgICAgIC8vIG91dCBvZiByYW5nZSwgdXNlIHJlcGxhY2VtZW50IGNoYXJhY3RlclxuICAgICAgaWYgKGNvZGVQb2ludCA8IDEgfHwgY29kZVBvaW50ID4gMHgxMGZmZmYgfHxcbiAgICAgICAgKGNvZGVQb2ludCA+IDB4ZDdmZiAmJiBjb2RlUG9pbnQgPCAweGUwMDApKSB7XG4gICAgICAgIHJldHVybiAnXFxcXHVmZmZkJztcbiAgICAgIH1cbiAgICAgIC8vIGphdmFzY3JpcHQgc3RyaW5ncyBhcmUgVVRGLTE2IGVuY29kZWRcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAweDEwMDAwKSB7XG4gICAgICAgIHZhciBsb3dIZXggPSAnMDAwJyArIGNvZGVQb2ludC50b1N0cmluZygxNik7XG4gICAgICAgIHJldHVybiAnXFxcXHUnICsgbG93SGV4LnN1YnN0cihsb3dIZXgubGVuZ3RoIC0gNCk7XG4gICAgICB9XG4gICAgICAvLyBzdXBwbGVtZW50YXJ5IGhpZ2ggKyBsb3cgc3Vycm9nYXRlc1xuICAgICAgcmV0dXJuICdcXFxcdScgKyAoKChjb2RlUG9pbnQgLSAweDEwMDAwKSA+PiAweDBhKSArIDB4ZDgwMCkudG9TdHJpbmcoMTYpICtcbiAgICAgICAgICAgICAnXFxcXHUnICsgKCgoY29kZVBvaW50IC0gMHgxMDAwMCkgJSAweDQwMCkgKyAweGRjMDApLnRvU3RyaW5nKDE2KTtcbiAgICB9LFxuXG4gIC8vIGNvbnZlcnQgc2luZ2xlIGNvZGVwb2ludCB0byBzdHJpbmdcbiAgc3RyaW5nRnJvbUNvZGVQb2ludCA9XG4gICAgZnVuY3Rpb24oY29kZVBvaW50KSB7XG4gICAgICAvLyBvdXQgb2YgcmFuZ2UsIHVzZSByZXBsYWNlbWVudCBjaGFyYWN0ZXJcbiAgICAgIGlmIChjb2RlUG9pbnQgPCAxIHx8IGNvZGVQb2ludCA+IDB4MTBmZmZmIHx8XG4gICAgICAgIChjb2RlUG9pbnQgPiAweGQ3ZmYgJiYgY29kZVBvaW50IDwgMHhlMDAwKSkge1xuICAgICAgICByZXR1cm4gJ1xcdWZmZmQnO1xuICAgICAgfVxuICAgICAgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNvZGVQb2ludCA/XG4gICAgICAgIFN0cmluZy5mcm9tQ29kZVBvaW50KGNvZGVQb2ludCkgOlxuICAgICAgICBTdHJpbmcuZnJvbUNoYXJDb2RlKFxuICAgICAgICAgICgoY29kZVBvaW50IC0gMHgxMDAwMCkgPj4gMHgwYSkgKyAweGQ4MDAsXG4gICAgICAgICAgKChjb2RlUG9pbnQgLSAweDEwMDAwKSAlIDB4NDAwKSArIDB4ZGMwMCk7XG4gICAgfSxcblxuICAvLyBjb252ZXJ0IGVzY2FwZSBzZXF1ZW5jZSBpbiBhIENTUyBzdHJpbmcgb3IgaWRlbnRpZmllclxuICAvLyB0byBqYXZhc2NyaXB0IHN0cmluZyB3aXRoIGphdmFzY3JpcHQgZXNjYXBlIHNlcXVlbmNlc1xuICBjb252ZXJ0RXNjYXBlcyA9XG4gICAgZnVuY3Rpb24oc3RyKSB7XG4gICAgICByZXR1cm4gUkVYLkhhc0VzY2FwZXMudGVzdChzdHIpID9cbiAgICAgICAgc3RyLnJlcGxhY2UoUkVYLkZpeEVzY2FwZXMsXG4gICAgICAgICAgZnVuY3Rpb24oc3Vic3RyaW5nLCBwMSwgcDIpIHtcbiAgICAgICAgICAgIC8vIHVuZXNjYXBlZCBcIiBvciAnXG4gICAgICAgICAgICByZXR1cm4gcDIgPyAnXFxcXCcgKyBwMiA6XG4gICAgICAgICAgICAgIC8vIGphdmFzY3JpcHQgc3RyaW5ncyBhcmUgVVRGLTE2IGVuY29kZWRcbiAgICAgICAgICAgICAgUkVYLkhleE51bWJlcnMudGVzdChwMSkgPyBjb2RlUG9pbnRUb1VURjE2KHBhcnNlSW50KHAxLCAxNikpIDpcbiAgICAgICAgICAgICAgLy8gXFwnIFxcXCJcbiAgICAgICAgICAgICAgUkVYLkVzY09yUXVvdGUudGVzdChwMSkgPyBzdWJzdHJpbmcgOlxuICAgICAgICAgICAgICAvLyBcXGcgXFxoIFxcLiBcXCMgZXRjXG4gICAgICAgICAgICAgIHAxO1xuICAgICAgICAgIH1cbiAgICAgICAgKSA6IHN0cjtcbiAgICB9LFxuXG4gIC8vIGNvbnZlcnQgZXNjYXBlIHNlcXVlbmNlIGluIGEgQ1NTIHN0cmluZyBvciBpZGVudGlmaWVyXG4gIC8vIHRvIGphdmFzY3JpcHQgc3RyaW5nIHdpdGggY2hhcmFjdGVycyByZXByZXNlbnRhdGlvbnNcbiAgdW5lc2NhcGVJZGVudGlmaWVyID1cbiAgICBmdW5jdGlvbihzdHIpIHtcbiAgICAgIHJldHVybiBSRVguSGFzRXNjYXBlcy50ZXN0KHN0cikgP1xuICAgICAgICBzdHIucmVwbGFjZShSRVguRml4RXNjYXBlcyxcbiAgICAgICAgICBmdW5jdGlvbihzdWJzdHJpbmcsIHAxLCBwMikge1xuICAgICAgICAgICAgLy8gdW5lc2NhcGVkIFwiIG9yICdcbiAgICAgICAgICAgIHJldHVybiBwMiA/IHAyIDpcbiAgICAgICAgICAgICAgLy8gamF2YXNjcmlwdCBzdHJpbmdzIGFyZSBVVEYtMTYgZW5jb2RlZFxuICAgICAgICAgICAgICBSRVguSGV4TnVtYmVycy50ZXN0KHAxKSA/IHN0cmluZ0Zyb21Db2RlUG9pbnQocGFyc2VJbnQocDEsIDE2KSkgOlxuICAgICAgICAgICAgICAvLyBcXCcgXFxcIlxuICAgICAgICAgICAgICBSRVguRXNjT3JRdW90ZS50ZXN0KHAxKSA/IHN1YnN0cmluZyA6XG4gICAgICAgICAgICAgIC8vIFxcZyBcXGggXFwuIFxcIyBldGNcbiAgICAgICAgICAgICAgcDE7XG4gICAgICAgICAgfVxuICAgICAgICApIDogc3RyO1xuICAgIH0sXG5cbiAgbWV0aG9kID0ge1xuICAgICcjJzogJ2dldEVsZW1lbnRCeUlkJyxcbiAgICAnKic6ICdnZXRFbGVtZW50c0J5VGFnTmFtZScsXG4gICAgJ3wnOiAnZ2V0RWxlbWVudHNCeVRhZ05hbWVOUycsXG4gICAgJy4nOiAnZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSdcbiAgICB9LFxuXG4gIGNvbXBhdCA9IHtcbiAgICAnIyc6IGZ1bmN0aW9uKGMsIG4pIHsgUkVYLkhhc0VzY2FwZXMudGVzdChuKSAmJiAobiA9IHVuZXNjYXBlSWRlbnRpZmllcihuKSk7IHJldHVybiBmdW5jdGlvbihlLCBmKSB7IHJldHVybiBieUlkKG4sIGMpOyB9OyB9LFxuICAgICcqJzogZnVuY3Rpb24oYywgbikgeyBSRVguSGFzRXNjYXBlcy50ZXN0KG4pICYmIChuID0gdW5lc2NhcGVJZGVudGlmaWVyKG4pKTsgcmV0dXJuIGZ1bmN0aW9uKGUsIGYpIHsgcmV0dXJuIGJ5VGFnKG4sIGMpOyB9OyB9LFxuICAgICd8JzogZnVuY3Rpb24oYywgbikgeyBSRVguSGFzRXNjYXBlcy50ZXN0KG4pICYmIChuID0gdW5lc2NhcGVJZGVudGlmaWVyKG4pKTsgcmV0dXJuIGZ1bmN0aW9uKGUsIGYpIHsgcmV0dXJuIGJ5VGFnTlMobiwgYyk7IH07IH0sXG4gICAgJy4nOiBmdW5jdGlvbihjLCBuKSB7IFJFWC5IYXNFc2NhcGVzLnRlc3QobikgJiYgKG4gPSB1bmVzY2FwZUlkZW50aWZpZXIobikpOyByZXR1cm4gZnVuY3Rpb24oZSwgZikgeyByZXR1cm4gYnlDbGFzcyhuLCBjKTsgfTsgfVxuICAgIH0sXG5cbiAgLy8gZmluZCBkdXBsaWNhdGUgaWRzIHVzaW5nIGl0ZXJhdGl2ZSB3YWxrXG4gIGJ5SWRSYXcgPVxuICAgIGZ1bmN0aW9uKGlkLCBjb250ZXh0KSB7XG4gICAgICB2YXIgbm9kZSA9IGNvbnRleHQsIG5vZGVzID0gWyBdLCBuZXh0ID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZDtcbiAgICAgIHdoaWxlICgobm9kZSA9IG5leHQpKSB7XG4gICAgICAgIG5vZGUuaWQgPT0gaWQgJiYgKG5vZGVzW25vZGVzLmxlbmd0aF0gPSBub2RlKTtcbiAgICAgICAgaWYgKChuZXh0ID0gbm9kZS5maXJzdEVsZW1lbnRDaGlsZCB8fCBub2RlLm5leHRFbGVtZW50U2libGluZykpIGNvbnRpbnVlO1xuICAgICAgICB3aGlsZSAoIW5leHQgJiYgKG5vZGUgPSBub2RlLnBhcmVudEVsZW1lbnQpICYmIG5vZGUgIT09IGNvbnRleHQpIHtcbiAgICAgICAgICBuZXh0ID0gbm9kZS5uZXh0RWxlbWVudFNpYmxpbmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBub2RlcztcbiAgICB9LFxuXG4gIC8vIGNvbnRleHQgYWdub3N0aWMgZ2V0RWxlbWVudEJ5SWRcbiAgYnlJZCA9XG4gICAgZnVuY3Rpb24oaWQsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlLCBpLCBsLCBub2RlcywgYXBpID0gbWV0aG9kWycjJ107XG5cbiAgICAgIC8vIGR1cGxpY2F0ZXMgaWQgYWxsb3dlZFxuICAgICAgaWYgKENvbmZpZy5JRFNfRFVQRVMgPT09IGZhbHNlKSB7XG4gICAgICAgIGlmIChhcGkgaW4gY29udGV4dCkge1xuICAgICAgICAgIHJldHVybiAoZSA9IGNvbnRleHRbYXBpXShpZCkpID8gWyBlIF0gOiBub25lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoJ2FsbCcgaW4gY29udGV4dCkge1xuICAgICAgICAgIGlmICgoZSA9IGNvbnRleHQuYWxsW2lkXSkpIHtcbiAgICAgICAgICAgIGlmIChlLm5vZGVUeXBlID09IDEpIHJldHVybiBlLmdldEF0dHJpYnV0ZSgnaWQnKSAhPSBpZCA/IFsgXSA6IFsgZSBdO1xuICAgICAgICAgICAgZWxzZSBpZiAoaWQgPT0gJ2xlbmd0aCcpIHJldHVybiAoZSA9IGNvbnRleHRbYXBpXShpZCkpID8gWyBlIF0gOiBub25lO1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbCA9IGUubGVuZ3RoLCBub2RlcyA9IFsgXTsgbCA+IGk7ICsraSkge1xuICAgICAgICAgICAgICBpZiAoZVtpXS5pZCA9PSBpZCkgbm9kZXNbbm9kZXMubGVuZ3RoXSA9IGVbaV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbm9kZXMgJiYgbm9kZXMubGVuZ3RoID8gbm9kZXMgOiBbIG5vZGVzIF07XG4gICAgICAgICAgfSBlbHNlIHJldHVybiBub25lO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBieUlkUmF3KGlkLCBjb250ZXh0KTtcbiAgICB9LFxuXG4gIC8vIHdyYXBwZWQgdXAgbmFtZXNwYWNlZCBUYWdOYW1lIGFwaSBjYWxsc1xuICBieVRhZ05TID1cbiAgICBmdW5jdGlvbihjb250ZXh0LCB0YWcpIHtcbiAgICAgIHJldHVybiBieVRhZyh0YWcsIGNvbnRleHQpO1xuICB9LFxuXG4gIC8vIGNvbnRleHQgYWdub3N0aWMgZ2V0RWxlbWVudHNCeVRhZ05hbWVcbiAgYnlUYWcgPVxuICAgIGZ1bmN0aW9uKHRhZywgY29udGV4dCkge1xuICAgICAgdmFyIGUsIG5vZGVzLCBhcGkgPSBtZXRob2RbJyonXTtcbiAgICAgIC8vIERPQ1VNRU5UX05PREUgKDkpICYgRUxFTUVOVF9OT0RFICgxKVxuICAgICAgaWYgKGFwaSBpbiBjb250ZXh0KSB7XG4gICAgICAgIHJldHVybiBzbGljZS5jYWxsKGNvbnRleHRbYXBpXSh0YWcpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRhZyA9IHRhZy50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAvLyBET0NVTUVOVF9GUkFHTUVOVF9OT0RFICgxMSlcbiAgICAgICAgaWYgKChlID0gY29udGV4dC5maXJzdEVsZW1lbnRDaGlsZCkpIHtcbiAgICAgICAgICBpZiAoIShlLm5leHRFbGVtZW50U2libGluZyB8fCB0YWcgPT0gJyonIHx8IGUubG9jYWxOYW1lID09IHRhZykpIHtcbiAgICAgICAgICAgIHJldHVybiBzbGljZS5jYWxsKGVbYXBpXSh0YWcpKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbm9kZXMgPSBbIF07XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIGlmICh0YWcgPT0gJyonIHx8IGUubG9jYWxOYW1lID09IHRhZykgbm9kZXNbbm9kZXMubGVuZ3RoXSA9IGU7XG4gICAgICAgICAgICAgIGNvbmNhdExpc3Qobm9kZXMsIGVbYXBpXSh0YWcpKTtcbiAgICAgICAgICAgIH0gd2hpbGUgKChlID0gZS5uZXh0RWxlbWVudFNpYmxpbmcpKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBub2RlcyA9IG5vbmU7XG4gICAgICB9XG4gICAgICByZXR1cm4gIUNvbmZpZy5BTk9ERUxJU1QgPyBub2RlcyA6IG5vZGVzIGluc3RhbmNlb2YgZ2xvYmFsLk5vZGVMaXN0ID8gbm9kZXMgOiB0b05vZGVMaXN0KG5vZGVzKTtcbiAgICB9LFxuXG4gIC8vIGNvbnRleHQgYWdub3N0aWMgZ2V0RWxlbWVudHNCeUNsYXNzTmFtZVxuICBieUNsYXNzID1cbiAgICBmdW5jdGlvbihjbHMsIGNvbnRleHQpIHtcbiAgICAgIHZhciBlLCBub2RlcywgYXBpID0gbWV0aG9kWycuJ10sIHJlQ2xzO1xuICAgICAgLy8gRE9DVU1FTlRfTk9ERSAoOSkgJiBFTEVNRU5UX05PREUgKDEpXG4gICAgICBpZiAoYXBpIGluIGNvbnRleHQpIHtcbiAgICAgICAgcmV0dXJuIHNsaWNlLmNhbGwoY29udGV4dFthcGldKGNscykpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRE9DVU1FTlRfRlJBR01FTlRfTk9ERSAoMTEpXG4gICAgICAgIGlmICgoZSA9IGNvbnRleHQuZmlyc3RFbGVtZW50Q2hpbGQpKSB7XG4gICAgICAgICAgcmVDbHMgPSBSZWdFeHAoJyhefFxcXFxzKScgKyBjbHMgKyAnKFxcXFxzfCQpJywgUVVJUktTX01PREUgPyAnaScgOiAnJyk7XG4gICAgICAgICAgaWYgKCEoZS5uZXh0RWxlbWVudFNpYmxpbmcgfHwgcmVDbHMudGVzdChlLmNsYXNzTmFtZSkpKSB7XG4gICAgICAgICAgICByZXR1cm4gc2xpY2UuY2FsbChlW2FwaV0oY2xzKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG5vZGVzID0gWyBdO1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBpZiAocmVDbHMudGVzdChlLmNsYXNzTmFtZSkpIG5vZGVzW25vZGVzLmxlbmd0aF0gPSBlO1xuICAgICAgICAgICAgICBjb25jYXRMaXN0KG5vZGVzLCBlW2FwaV0oY2xzKSk7XG4gICAgICAgICAgICB9IHdoaWxlICgoZSA9IGUubmV4dEVsZW1lbnRTaWJsaW5nKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Ugbm9kZXMgPSBub25lO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFDb25maWcuQU5PREVMSVNUID8gbm9kZXMgOiBub2RlcyBpbnN0YW5jZW9mIGdsb2JhbC5Ob2RlTGlzdCA/IG5vZGVzIDogdG9Ob2RlTGlzdChub2Rlcyk7XG4gICAgfSxcblxuICAvLyBuYW1lc3BhY2UgYXdhcmUgaGFzQXR0cmlidXRlXG4gIC8vIGhlbHBlciBmb3IgWE1ML1hIVE1MIGRvY3VtZW50c1xuICBoYXNBdHRyaWJ1dGVOUyA9XG4gICAgZnVuY3Rpb24oZSwgbmFtZSkge1xuICAgICAgdmFyIGksIGwsIGF0dHIgPSBlLmdldEF0dHJpYnV0ZU5hbWVzKCk7XG4gICAgICBuYW1lID0gUmVnRXhwKCc6PycgKyBuYW1lICsgJyQnLCBIVE1MX0RPQ1VNRU5UID8gJ2knIDogJycpO1xuICAgICAgZm9yIChpID0gMCwgbCA9IGF0dHIubGVuZ3RoOyBsID4gaTsgKytpKSB7XG4gICAgICAgIGlmIChuYW1lLnRlc3QoYXR0cltpXSkpIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgLy8gZmFzdCByZXNvbHZlciBmb3IgdGhlIDpudGgtY2hpbGQoKSBhbmQgOm50aC1sYXN0LWNoaWxkKCkgcHNldWRvLWNsYXNzZXNcbiAgbnRoRWxlbWVudCA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaWR4ID0gMCwgbGVuID0gMCwgc2V0ID0gMCwgcGFyZW50ID0gdW5kZWZpbmVkLCBwYXJlbnRzID0gQXJyYXkoKSwgbm9kZXMgPSBBcnJheSgpO1xuICAgIHJldHVybiBmdW5jdGlvbihlbGVtZW50LCBkaXIpIHtcbiAgICAgIC8vIGVuc3VyZSBjYWNoZXMgYXJlIGVtcHRpZWQgYWZ0ZXIgZWFjaCBydW4sIGludm9raW5nIHdpdGggZGlyID0gMlxuICAgICAgaWYgKGRpciA9PSAyKSB7XG4gICAgICAgIGlkeCA9IDA7IGxlbiA9IDA7IHNldCA9IDA7IG5vZGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHBhcmVudHMubGVuZ3RoID0gMDsgcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgZSwgaSwgaiwgaywgbDtcbiAgICAgIGlmIChwYXJlbnQgPT09IGVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgICBpID0gc2V0OyBqID0gaWR4OyBsID0gbGVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbCA9IHBhcmVudHMubGVuZ3RoO1xuICAgICAgICBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGZvciAoaSA9IC0xLCBqID0gMCwgayA9IGwgLSAxOyBsID4gajsgKytqLCAtLWspIHtcbiAgICAgICAgICBpZiAocGFyZW50c1tqXSA9PT0gcGFyZW50KSB7IGkgPSBqOyBicmVhazsgfVxuICAgICAgICAgIGlmIChwYXJlbnRzW2tdID09PSBwYXJlbnQpIHsgaSA9IGs7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCAwKSB7XG4gICAgICAgICAgcGFyZW50c1tpID0gbF0gPSBwYXJlbnQ7XG4gICAgICAgICAgbCA9IDA7IG5vZGVzW2ldID0gQXJyYXkoKTtcbiAgICAgICAgICBlID0gcGFyZW50ICYmIHBhcmVudC5maXJzdEVsZW1lbnRDaGlsZCB8fCBlbGVtZW50O1xuICAgICAgICAgIHdoaWxlIChlKSB7IG5vZGVzW2ldW2xdID0gZTsgaWYgKGUgPT09IGVsZW1lbnQpIGogPSBsOyBlID0gZS5uZXh0RWxlbWVudFNpYmxpbmc7ICsrbDsgfVxuICAgICAgICAgIHNldCA9IGk7IGlkeCA9IDA7IGxlbiA9IGw7XG4gICAgICAgICAgaWYgKGwgPCAyKSByZXR1cm4gbDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsID0gbm9kZXNbaV0ubGVuZ3RoO1xuICAgICAgICAgIHNldCA9IGk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChlbGVtZW50ICE9PSBub2Rlc1tpXVtqXSAmJiBlbGVtZW50ICE9PSBub2Rlc1tpXVtqID0gMF0pIHtcbiAgICAgICAgZm9yIChqID0gMCwgZSA9IG5vZGVzW2ldLCBrID0gbCAtIDE7IGwgPiBqOyArK2osIC0taykge1xuICAgICAgICAgIGlmIChlW2pdID09PSBlbGVtZW50KSB7IGJyZWFrOyB9XG4gICAgICAgICAgaWYgKGVba10gPT09IGVsZW1lbnQpIHsgaiA9IGs7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlkeCA9IGogKyAxOyBsZW4gPSBsO1xuICAgICAgcmV0dXJuIGRpciA/IGwgLSBqIDogaWR4O1xuICAgIH07XG4gIH0pKCksXG5cbiAgLy8gZmFzdCByZXNvbHZlciBmb3IgdGhlIDpudGgtb2YtdHlwZSgpIGFuZCA6bnRoLWxhc3Qtb2YtdHlwZSgpIHBzZXVkby1jbGFzc2VzXG4gIG50aE9mVHlwZSA9IChmdW5jdGlvbigpIHtcbiAgICB2YXIgaWR4ID0gMCwgbGVuID0gMCwgc2V0ID0gMCwgcGFyZW50ID0gdW5kZWZpbmVkLCBwYXJlbnRzID0gQXJyYXkoKSwgbm9kZXMgPSBBcnJheSgpO1xuICAgIHJldHVybiBmdW5jdGlvbihlbGVtZW50LCBkaXIpIHtcbiAgICAgIC8vIGVuc3VyZSBjYWNoZXMgYXJlIGVtcHRpZWQgYWZ0ZXIgZWFjaCBydW4sIGludm9raW5nIHdpdGggZGlyID0gMlxuICAgICAgaWYgKGRpciA9PSAyKSB7XG4gICAgICAgIGlkeCA9IDA7IGxlbiA9IDA7IHNldCA9IDA7IG5vZGVzLmxlbmd0aCA9IDA7XG4gICAgICAgIHBhcmVudHMubGVuZ3RoID0gMDsgcGFyZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgZSwgaSwgaiwgaywgbCwgbmFtZSA9IGVsZW1lbnQubG9jYWxOYW1lO1xuICAgICAgaWYgKG5vZGVzW3NldF0gJiYgbm9kZXNbc2V0XVtuYW1lXSAmJiBwYXJlbnQgPT09IGVsZW1lbnQucGFyZW50RWxlbWVudCkge1xuICAgICAgICBpID0gc2V0OyBqID0gaWR4OyBsID0gbGVuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbCA9IHBhcmVudHMubGVuZ3RoO1xuICAgICAgICBwYXJlbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICAgIGZvciAoaSA9IC0xLCBqID0gMCwgayA9IGwgLSAxOyBsID4gajsgKytqLCAtLWspIHtcbiAgICAgICAgICBpZiAocGFyZW50c1tqXSA9PT0gcGFyZW50KSB7IGkgPSBqOyBicmVhazsgfVxuICAgICAgICAgIGlmIChwYXJlbnRzW2tdID09PSBwYXJlbnQpIHsgaSA9IGs7IGJyZWFrOyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPCAwIHx8ICFub2Rlc1tpXVtuYW1lXSkge1xuICAgICAgICAgIHBhcmVudHNbaSA9IGxdID0gcGFyZW50O1xuICAgICAgICAgIG5vZGVzW2ldIHx8IChub2Rlc1tpXSA9IE9iamVjdCgpKTtcbiAgICAgICAgICBsID0gMDsgbm9kZXNbaV1bbmFtZV0gPSBBcnJheSgpO1xuICAgICAgICAgIGUgPSBwYXJlbnQgJiYgcGFyZW50LmZpcnN0RWxlbWVudENoaWxkIHx8IGVsZW1lbnQ7XG4gICAgICAgICAgd2hpbGUgKGUpIHsgaWYgKGUgPT09IGVsZW1lbnQpIGogPSBsOyBpZiAoZS5sb2NhbE5hbWUgPT0gbmFtZSkgeyBub2Rlc1tpXVtuYW1lXVtsXSA9IGU7ICsrbDsgfSBlID0gZS5uZXh0RWxlbWVudFNpYmxpbmc7IH1cbiAgICAgICAgICBzZXQgPSBpOyBpZHggPSBqOyBsZW4gPSBsO1xuICAgICAgICAgIGlmIChsIDwgMikgcmV0dXJuIGw7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbCA9IG5vZGVzW2ldW25hbWVdLmxlbmd0aDtcbiAgICAgICAgICBzZXQgPSBpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoZWxlbWVudCAhPT0gbm9kZXNbaV1bbmFtZV1bal0gJiYgZWxlbWVudCAhPT0gbm9kZXNbaV1bbmFtZV1baiA9IDBdKSB7XG4gICAgICAgIGZvciAoaiA9IDAsIGUgPSBub2Rlc1tpXVtuYW1lXSwgayA9IGwgLSAxOyBsID4gajsgKytqLCAtLWspIHtcbiAgICAgICAgICBpZiAoZVtqXSA9PT0gZWxlbWVudCkgeyBicmVhazsgfVxuICAgICAgICAgIGlmIChlW2tdID09PSBlbGVtZW50KSB7IGogPSBrOyBicmVhazsgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZHggPSBqICsgMTsgbGVuID0gbDtcbiAgICAgIHJldHVybiBkaXIgPyBsIC0gaiA6IGlkeDtcbiAgICB9O1xuICB9KSgpLFxuXG4gIC8vIGNoZWNrIGlmIHRoZSBkb2N1bWVudCB0eXBlIGlzIEhUTUxcbiAgaXNIVE1MID1cbiAgICBmdW5jdGlvbihub2RlKSB7XG4gICAgICB2YXIgZG9jID0gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGU7XG4gICAgICByZXR1cm4gZG9jLm5vZGVUeXBlID09IDkgJiZcbiAgICAgICAgLy8gY29udGVudFR5cGUgbm90IGluIElFIDw9IDExXG4gICAgICAgICdjb250ZW50VHlwZScgaW4gZG9jID9cbiAgICAgICAgICBkb2MuY29udGVudFR5cGUuaW5kZXhPZignL2h0bWwnKSA+IDAgOlxuICAgICAgICAgIGRvYy5jcmVhdGVFbGVtZW50KCdEaVYnKS5sb2NhbE5hbWUgPT0gJ2Rpdic7XG4gICAgfSxcblxuICAvLyByZXR1cm4gbm9kZSBpZiBub2RlIGlzIGZvY3VzYWJsZVxuICAvLyBvciBmYWxzZSBpZiBub2RlIGlzbid0IGZvY3VzYWJsZVxuICBpc0ZvY3VzYWJsZSA9XG4gICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGRvYyA9IG5vZGUub3duZXJEb2N1bWVudDtcbiAgICAgICBpZiAobm9kZS5jb250ZW50RG9jdW1lbnQmJm5vZGUubG9jYWxOYW1lPT0gJ2lmcmFtZScpIHsgcmV0dXJuIGZhbHNlOyB9XG4gICAgICAgaWYgKGRvYy5oYXNGb2N1cygpICYmIG5vZGUgPT09IGRvYy5hY3RpdmVFbGVtZW50KSB7XG4gICAgICAgIGlmIChub2RlLnR5cGUgfHwgbm9kZS5ocmVmIHx8IHR5cGVvZiBub2RlLnRhYkluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gIC8vIGNoZWNrIGlmIG5vZGUgY29udGVudCBpcyBlZGl0YWJsZVxuICBpc0NvbnRlbnRFZGl0YWJsZSA9XG4gICAgZnVuY3Rpb24obm9kZSkge1xuICAgICAgdmFyIGF0dHJWYWx1ZSA9ICdpbmhlcml0JztcbiAgICAgIGlmIChub2RlLmhhc0F0dHJpYnV0ZSgnY29udGVudGVkaXRhYmxlJykpIHtcbiAgICAgICAgYXR0clZhbHVlID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpO1xuICAgICAgfVxuICAgICAgc3dpdGNoIChhdHRyVmFsdWUpIHtcbiAgICAgICAgY2FzZSAnJzpcbiAgICAgICAgY2FzZSAncGxhaW50ZXh0LW9ubHknOlxuICAgICAgICBjYXNlICd0cnVlJzpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY2FzZSAnZmFsc2UnOlxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBpZiAobm9kZS5wYXJlbnROb2RlICYmIG5vZGUucGFyZW50Tm9kZS5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgcmV0dXJuIGlzQ29udGVudEVkaXRhYmxlKG5vZGUucGFyZW50Tm9kZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9LFxuXG4gIC8vIGNoZWNrIG1lZGlhIHJlc291cmNlcyBpcyBwbGF5aW5nXG4gIGlzUGxheWluZyA9XG4gICAgZnVuY3Rpb24obWVkaWEpIHtcbiAgICAgIC8vIGZvciA8YXVkaW8+LCA8dmlkZW8+LCA8c291cmNlPiBhbmQgPHRyYWNrPiBlbGVtZW50c1xuICAgICAgdmFyIHBhcmVudCA9IG1lZGlhIGluc3RhbmNlb2YgSFRNTE1lZGlhRWxlbWVudCA/IG51bGwgOiBtZWRpYS5wYXJlbnRFbGVtZW50O1xuICAgICAgcmV0dXJuIChcbiAgICAgICAgISEoIG1lZGlhICYmICBtZWRpYS5jdXJyZW50VGltZSA+IDAgJiYgICFtZWRpYS5wYXVzZWQgJiYgICFtZWRpYS5lbmRlZCAmJiAgbWVkaWEucmVhZHlTdGF0ZSA+IDIpIHx8XG4gICAgICAgICEhKHBhcmVudCAmJiBwYXJlbnQuY3VycmVudFRpbWUgPiAwICYmICFwYXJlbnQucGF1c2VkICYmICFwYXJlbnQuZW5kZWQgJiYgcGFyZW50LnJlYWR5U3RhdGUgPiAyKSk7XG4gICAgfSxcblxuICAvLyBjb25maWd1cmUgdGhlIGVuZ2luZSB0byB1c2Ugc3BlY2lhbCBoYW5kbGluZ1xuICBjb25maWd1cmUgPVxuICAgIGZ1bmN0aW9uKG9wdGlvbiwgY2xlYXIpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9uID09ICdzdHJpbmcnKSB7IHJldHVybiAhIUNvbmZpZ1tvcHRpb25dOyB9XG4gICAgICBpZiAodHlwZW9mIG9wdGlvbiAhPSAnb2JqZWN0JykgeyByZXR1cm4gQ29uZmlnOyB9XG4gICAgICBmb3IgKHZhciBpIGluIG9wdGlvbikge1xuICAgICAgICBDb25maWdbaV0gPSAhIW9wdGlvbltpXTtcbiAgICAgIH1cbiAgICAgIC8vIGNsZWFyIGxhbWJkYSBjYWNoZVxuICAgICAgaWYgKGNsZWFyKSB7XG4gICAgICAgIG1hdGNoUmVzb2x2ZXJzID0geyB9O1xuICAgICAgICBzZWxlY3RSZXNvbHZlcnMgPSB7IH07XG4gICAgICB9XG4gICAgICBzZXRJZGVudGlmaWVyU3ludGF4KCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9LFxuXG4gIC8vIGNlbnRyYWxpemVkIGVycm9yIGFuZCBleGNlcHRpb25zIGhhbmRsaW5nXG4gIGVtaXQgPVxuICAgIGZ1bmN0aW9uKG1lc3NhZ2UsIHByb3RvKSB7XG4gICAgICB2YXIgZXJyO1xuICAgICAgaWYgKENvbmZpZy5WRVJCT1NJVFkpIHtcbiAgICAgICAgaWYgKHByb3RvKSB7XG4gICAgICAgICAgZXJyID0gbmV3IHByb3RvKG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGVyciA9IG5ldyBnbG9iYWwuRE9NRXhjZXB0aW9uKG1lc3NhZ2UsICdTeW50YXhFcnJvcicpO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICAgIGlmIChDb25maWcuTE9HRVJST1JTICYmIGNvbnNvbGUgJiYgY29uc29sZS5sb2cpIHtcbiAgICAgICAgY29uc29sZS5sb2cobWVzc2FnZSk7XG4gICAgICB9XG4gICAgfSxcblxuICAvLyBleGVjdXRlIHRoZSBlbmdpbmUgaW5pdGlhbGl6YXRpb24gY29kZVxuICBpbml0aWFsaXplID1cbiAgICBmdW5jdGlvbihkb2MpIHtcbiAgICAgIHNldElkZW50aWZpZXJTeW50YXgoKTtcbiAgICAgIGxhc3RDb250ZXh0ID0gc3dpdGNoQ29udGV4dChkb2MsIHRydWUpO1xuICAgIH0sXG5cbiAgLy8gYnVpbGQgdmFsaWRhdGlvbiByZWdleHBzIHVzZWQgYnkgdGhlIGVuZ2luZVxuICBzZXRJZGVudGlmaWVyU3ludGF4ID1cbiAgICBmdW5jdGlvbigpIHtcblxuICAgICAgLy9cbiAgICAgIC8vIE5PVEU6IFNQRUNJQUwgQ0FTRVMgSU4gQ1NTIFNZTlRBWCBQQVJTSU5HIFJVTEVTXG4gICAgICAvL1xuICAgICAgLy8gVGhlIDxFT0YtdG9rZW4+IGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3Mtc3ludGF4LyN0eXBlZGVmLWVvZi10b2tlblxuICAgICAgLy8gYWxsb3cgbWFuZ2xlZHx1bmNsb3NlZCBzZWxlY3RvciBzeW50YXggYXQgdGhlIGVuZCBvZiBzZWxlY3RvcnMgc3RyaW5nc1xuICAgICAgLy9cbiAgICAgIC8vIExpdGVyYWwgZXF1aXZhbGVudCBoZXggcmVwcmVzZW50YXRpb25zIG9mIHRoZSBjaGFyYWN0ZXJzOiBcIiAnIGAgXSApXG4gICAgICAvL1xuICAgICAgLy8gICAgIFxcXFx4MjIgPSBcIiAtIGRvdWJsZSBxdW90ZXMgICAgXFxcXHg1YiA9IFsgLSBvcGVuIHNxdWFyZSBicmFja2V0XG4gICAgICAvLyAgICAgXFxcXHgyNyA9ICcgLSBzaW5nbGUgcXVvdGUgICAgIFxcXFx4NWQgPSBdIC0gY2xvc2VkIHNxdWFyZSBicmFja2V0XG4gICAgICAvLyAgICAgXFxcXHg2MCA9IGAgLSBiYWNrIHRpY2sgICAgICAgIFxcXFx4MjggPSAoIC0gb3BlbiByb3VuZCBwYXJlbnNcbiAgICAgIC8vICAgICBcXFxceDVjID0gXFwgLSBiYWNrIHNsYXNoICAgICAgIFxcXFx4MjkgPSApIC0gY2xvc2VkIHJvdW5kIHBhcmVuc1xuICAgICAgLy9cbiAgICAgIC8vIHVzaW5nIGhleCBmb3JtYXQgcHJldmVudHMgZmFsc2UgbWF0Y2hlcyBvZiBvcGVuZWQvY2xvc2VkIGluc3RhbmNlc1xuICAgICAgLy8gcGFpcnMsIGNvbG9yaW5nIGJyZWFrYWdlIGFuZCBvdGhlciBlZGl0b3JzIGhpZ2hsaWdodG5pbmcgcHJvYmxlbXMuXG4gICAgICAvL1xuXG4gICAgICB2YXJcblxuICAgICAgLy8gbm9uLWFzY2lpIGNoYXJzXG4gICAgICBub2FzY2lpID0gJ1teXFxcXHgwMC1cXFxceDlmXScsXG4gICAgICAvLyBlc2NhcGVkIGNoYXJzXG4gICAgICBlc2NhcGVkID0gJ1xcXFxcXFxcW15cXFxcclxcXFxuXFxcXGYwLTlhLWZBLUZdJyxcbiAgICAgIC8vIHVuaWNvZGUgY2hhcnNcbiAgICAgIHVuaWNvZGUgPSAnXFxcXFxcXFxbMC05YS1mQS1GXXsxLDZ9KD86XFxcXHJcXFxcbnxcXFxccyk/JyxcblxuICAgICAgLy8gY2FuIHN0YXJ0IHdpdGggc2luZ2xlL2RvdWJsZSBkYXNoXG4gICAgICAvLyBidXQgaXQgY2FuIG5vdCBzdGFydCB3aXRoIGEgZGlnaXRcbiAgICAgIGlkZW50aWZpZXIgPSAnLT8oPzpbYS16QS1aXy1dfCcgKyBub2FzY2lpICsgJ3wnICsgZXNjYXBlZCArICd8JyArIHVuaWNvZGUgKyAnKScgK1xuICAgICAgICAgICcoPzotezJ9fFswLTldfFthLXpBLVpfLV18JyArIG5vYXNjaWkgKyAnfCcgKyBlc2NhcGVkICsgJ3wnICsgdW5pY29kZSArICcpKicsXG5cbiAgICAgIHBzZXVkb25hbWVzID0gJ1stXFxcXHddKycsXG4gICAgICBwc2V1ZG9wYXJtcyA9ICcoPzpbLStdP1xcXFxkKikoPzpuXFxcXHM/Wy0rXT9cXFxccz9cXFxcZCopJyxcbiAgICAgIGRvdWJsZXF1b3RlID0gJ1wiW15cIlxcXFxcXFxcXSooPzpcXFxcXFxcXC5bXlwiXFxcXFxcXFxdKikqKD86XCJ8JCknLFxuICAgICAgc2luZ2xlcXVvdGUgPSBcIidbXidcXFxcXFxcXF0qKD86XFxcXFxcXFwuW14nXFxcXFxcXFxdKikqKD86J3wkKVwiLFxuXG4gICAgICBhdHRycGFyc2VyID0gaWRlbnRpZmllciArICd8JyArIGRvdWJsZXF1b3RlICsgJ3wnICsgc2luZ2xlcXVvdGUsXG5cbiAgICAgIGF0dHJ2YWx1ZXMgPSAnKFtcXFxceDIyXFxcXHgyN10/KSgoPyFcXFxcMykqfCg/OlxcXFxcXFxcPy4pKj8pKD86XFxcXDN8JCknLFxuXG4gICAgICBhdHRyaWJ1dGVzID1cbiAgICAgICAgJ1xcXFxbJyArXG4gICAgICAgICAgLy8gYXR0cmlidXRlIHByZXNlbmNlXG4gICAgICAgICAgJyg/OlxcXFwqXFxcXHwpPycgK1xuICAgICAgICAgIFdTUCArICc/JyArXG4gICAgICAgICAgJygnICsgaWRlbnRpZmllciArICcoPzo6JyArIGlkZW50aWZpZXIgKyAnKT8pJyArXG4gICAgICAgICAgV1NQICsgJz8nICtcbiAgICAgICAgICAnKD86JyArXG4gICAgICAgICAgICAnKCcgKyBDRkcub3BlcmF0b3JzICsgJyknICsgV1NQICsgJz8nICtcbiAgICAgICAgICAgICcoPzonICsgYXR0cnBhcnNlciArICcpJyArXG4gICAgICAgICAgJyk/JyArXG4gICAgICAgICAgLy8gYXR0cmlidXRlIGNhc2Ugc2Vuc2l0aXZpdHlcbiAgICAgICAgICAnKD86JyArIFdTUCArICc/XFxcXGIoaSkpPycgKyBXU1AgKyAnPycgK1xuICAgICAgICAnKD86XFxcXF18JCknLFxuXG4gICAgICBhdHRybWF0Y2hlciA9IGF0dHJpYnV0ZXMucmVwbGFjZShhdHRycGFyc2VyLCBhdHRydmFsdWVzKSxcblxuICAgICAgcHNldWRvY2xhc3MgPVxuICAgICAgICAnKD86XFxcXHgyOCcgKyBXU1AgKyAnKicgK1xuICAgICAgICAgICcoPzonICsgcHNldWRvcGFybXMgKyAnPyk/fCcgK1xuICAgICAgICAgIC8vIHVuaXZlcnNhbCAqICZcbiAgICAgICAgICAvLyBuYW1lc3BhY2UgKnwqXG4gICAgICAgICAgJyg/OlxcXFwqfFxcXFwqXFxcXHwpfCcgK1xuICAgICAgICAgICcoPzonICtcbiAgICAgICAgICAgICcoPzo6JyArIHBzZXVkb25hbWVzICtcbiAgICAgICAgICAgICAgJyg/OlxcXFx4MjgnICsgcHNldWRvcGFybXMgKyAnPyg/OlxcXFx4Mjl8JCkpP3wnICtcbiAgICAgICAgICAgICcpfCcgK1xuICAgICAgICAgICAgJyg/OlsuI10/JyArIGlkZW50aWZpZXIgKyAnKXwnICtcbiAgICAgICAgICAgICcoPzonICsgYXR0cmlidXRlcyArICcpJyArXG4gICAgICAgICAgJykrfCcgK1xuICAgICAgICAgICcoPzonICsgV1NQICsgJz9bPit+XVtePit+XScgKyBXU1AgKyAnPyl8JyArXG4gICAgICAgICAgJyg/OicgKyBXU1AgKyAnPywnICsgV1NQICsgJz8pfCcgK1xuICAgICAgICAgICcoPzonICsgV1NQICsgJz8pfCcgK1xuICAgICAgICAgICcoPzpcXFxceDI5fCQpJyArXG4gICAgICAgICcpKicsXG5cbiAgICAgIHN0YW5kYXJkVmFsaWRhdG9yID1cbiAgICAgICAgJyg/PScgKyBXU1AgKyAnP1tePit+KCl7fTw+XSknICtcbiAgICAgICAgJyg/OicgK1xuICAgICAgICAgIC8vIHVuaXZlcnNhbCAqICZcbiAgICAgICAgICAvLyBuYW1lc3BhY2UgKnwqXG4gICAgICAgICAgJyg/OlxcXFwqfFxcXFwqXFxcXHwpfCcgK1xuICAgICAgICAgICcoPzpbLiNdPycgKyBpZGVudGlmaWVyICsgJykrfCcgK1xuICAgICAgICAgICcoPzonICsgYXR0cmlidXRlcyArICcpK3wnICtcbiAgICAgICAgICAnKD86Ojo/JyArIHBzZXVkb25hbWVzICsgcHNldWRvY2xhc3MgKyAnKXwnICtcbiAgICAgICAgICAnKD86JyArIFdTUCArICc/JyArIENGRy5jb21iaW5hdG9ycyArIFdTUCArICc/KXwnICtcbiAgICAgICAgICAnKD86JyArIFdTUCArICc/LCcgKyBXU1AgKyAnPyl8JyArXG4gICAgICAgICAgJyg/OicgKyBXU1AgKyAnPyknICtcbiAgICAgICAgJykrJztcblxuICAgICAgLy8gdGhlIGZvbGxvd2luZyBnbG9iYWwgUkUgaXMgdXNlZCB0byByZXR1cm4gdGhlXG4gICAgICAvLyBkZWVwZXN0IGxvY2FsTmFtZSBpbiBzZWxlY3RvciBzdHJpbmdzIGFuZCB0aGVuXG4gICAgICAvLyB1c2UgaXQgdG8gcmV0cmlldmUgYWxsIHBvc3NpYmxlIG1hdGNoaW5nIG5vZGVzXG4gICAgICAvLyB0aGF0IHdpbGwgYmUgZmlsdGVyZWQgYnkgY29tcGlsZWQgcmVzb2x2ZXJzXG4gICAgICByZU9wdGltaXplciA9IFJlZ0V4cChcbiAgICAgICAgJyg/OihbLjojKl0/KScgK1xuICAgICAgICAnKCcgKyBpZGVudGlmaWVyICsgJyknICtcbiAgICAgICAgJyg/OicgK1xuICAgICAgICAgICc6Wy1cXFxcd10rfCcgK1xuICAgICAgICAgICdcXFxcW1teXFxcXF1dKyg/OlxcXFxdfCQpfCcgK1xuICAgICAgICAgICdcXFxceDI4W15cXFxceDI5XSsoPzpcXFxceDI5fCQpJyArXG4gICAgICAgICcpKikkJyk7XG5cbiAgICAgIC8vIGdsb2JhbFxuICAgICAgcmVWYWxpZGF0b3IgPSBSZWdFeHAoc3RhbmRhcmRWYWxpZGF0b3IsICdnJyk7XG5cbiAgICAgIFBhdHRlcm5zLmlkID0gUmVnRXhwKCdeIygnICsgaWRlbnRpZmllciArICcpKC4qKScpO1xuICAgICAgUGF0dGVybnMudGFnTmFtZSA9IFJlZ0V4cCgnXignICsgaWRlbnRpZmllciArICcpKC4qKScpO1xuICAgICAgUGF0dGVybnMuY2xhc3NOYW1lID0gUmVnRXhwKCdeXFxcXC4oJyArIGlkZW50aWZpZXIgKyAnKSguKiknKTtcbiAgICAgIFBhdHRlcm5zLmF0dHJpYnV0ZSA9IFJlZ0V4cCgnXig/OicgKyBhdHRybWF0Y2hlciArICcpKC4qKScpO1xuICAgIH0sXG5cbiAgRl9JTklUID0gJ1widXNlIHN0cmljdFwiO3JldHVybiBmdW5jdGlvbiBSZXNvbHZlcihjLGYseCxyKScsXG5cbiAgLypcbiAgLy8gUyAtIE0gLSBOXG4gIC8vXG4gIC8vIFNFTEVDVFxuICAvLyBNQVRDSFxuICAvLyBOT05FXG4gIC8vXG4gICovXG5cbiAgU19IRUFEID0gJ3ZhciBlLG4sbyxqPXIubGVuZ3RoLTEsaz0tMScsXG4gIE1fSEVBRCA9ICd2YXIgZSxuLG8nLFxuICBOX0hFQUQgPSAndmFyIGUsbixvJyxcblxuICBTX0xPT1AgPSAnbWFpbjp3aGlsZSgoZT1jWysra10pKScsXG4gIE1fTE9PUCA9ICdlPWM7JyxcbiAgTl9MT09QID0gJ21haW46d2hpbGUoKGU9Yy5pdGVtKCsraykpKScsXG5cbiAgU19CT0RZID0gJ3JbKytqXT1jW2tdOycsXG4gIE1fQk9EWSA9ICcnLFxuICBOX0JPRFkgPSAnclsrK2pdPWMuaXRlbShrKTsnLFxuXG4gIFNfVEFJTCA9ICdjb250aW51ZSBtYWluOycsXG4gIE1fVEFJTCA9ICdyPXRydWU7JyxcbiAgTl9UQUlMID0gJ3I9dHJ1ZTsnLFxuXG4gIFNfVEVTVCA9ICdpZihmKGNba10pKXticmVhayBtYWluO30nLFxuICBNX1RFU1QgPSAnZihjKTsnLFxuICBOX1RFU1QgPSAnaWYoZihjLml0ZW0oaykpKXticmVhayBtYWluO30nLFxuXG4gIFNfVkFSUyA9IFsgXSxcbiAgTV9WQVJTID0gWyBdLFxuICBOX1ZBUlMgPSBbIF0sXG5cbiAgLy8gY29tcGlsZSBncm91cHMgb3Igc2luZ2xlIHNlbGVjdG9yIHN0cmluZ3MgaW50b1xuICAvLyBleGVjdXRhYmxlIGZ1bmN0aW9ucyBmb3IgbWF0Y2hpbmcgb3Igc2VsZWN0aW5nXG5cbiAgU19URVNUID0gJ2lmKGYoY1trXSkpe2JyZWFrIG1haW47fScsXG4gIE1fVEVTVCA9ICdmKGMpOycsXG4gIE5fVEVTVCA9ICdpZihmKGMuaXRlbShrKSkpe2JyZWFrIG1haW47fScsXG5cbiAgU19WQVJTID0gWyBdLFxuICBNX1ZBUlMgPSBbIF0sXG4gIE5fVkFSUyA9IFsgXSxcblxuICAvLyBjb21waWxlIGdyb3VwcyBvciBzaW5nbGUgc2VsZWN0b3Igc3RyaW5ncyBpbnRvXG4gIC8vIGV4ZWN1dGFibGUgZnVuY3Rpb25zIGZvciBtYXRjaGluZyBvciBzZWxlY3RpbmdcbiAgY29tcGlsZSA9XG4gICAgZnVuY3Rpb24oc2VsZWN0b3IsIG1vZGUsIGNhbGxiYWNrKSB7XG4gICAgICB2YXIgZmFjdG9yeSwgdG9rZW4sIGhlYWQgPSAnJywgbG9vcCA9ICcnLCBtYWNybyA9ICcnLCBzb3VyY2UgPSAnJywgdmFycyA9ICcnO1xuXG4gICAgICAvLyAnbW9kZScgY2FuIGJlIGJvb2xlYW4gb3IgbnVsbFxuICAgICAgLy8gdHJ1ZSA9IHNlbGVjdCAvIGZhbHNlID0gbWF0Y2hcbiAgICAgIC8vIG51bGwgdG8gdXNlIGNvbGxlY3Rpb24uaXRlbSgpXG4gICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSB0cnVlOlxuICAgICAgICAgIGlmIChzZWxlY3RMYW1iZGFzW3NlbGVjdG9yXSkgeyByZXR1cm4gc2VsZWN0TGFtYmRhc1tzZWxlY3Rvcl07IH1cbiAgICAgICAgICBtYWNybyA9IFNfQk9EWSArIChjYWxsYmFjayA/IFNfVEVTVCA6ICcnKSArIFNfVEFJTDtcbiAgICAgICAgICBoZWFkID0gU19IRUFEO1xuICAgICAgICAgIGxvb3AgPSBTX0xPT1A7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZmFsc2U6XG4gICAgICAgICAgaWYgKG1hdGNoTGFtYmRhc1tzZWxlY3Rvcl0pIHsgcmV0dXJuIG1hdGNoTGFtYmRhc1tzZWxlY3Rvcl07IH1cbiAgICAgICAgICBtYWNybyA9IE1fQk9EWSArIChjYWxsYmFjayA/IE1fVEVTVCA6ICcnKSArIE1fVEFJTDtcbiAgICAgICAgICBoZWFkID0gTV9IRUFEO1xuICAgICAgICAgIGxvb3AgPSBNX0xPT1A7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICBpZiAoc2VsZWN0TGFtYmRhc1tzZWxlY3Rvcl0pIHsgcmV0dXJuIHNlbGVjdExhbWJkYXNbc2VsZWN0b3JdOyB9XG4gICAgICAgICAgbWFjcm8gPSBOX0JPRFkgKyAoY2FsbGJhY2sgPyBOX1RFU1QgOiAnJykgKyBOX1RBSUw7XG4gICAgICAgICAgaGVhZCA9IE5fSEVBRDtcbiAgICAgICAgICBsb29wID0gTl9MT09QO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBzb3VyY2UgPSBjb21waWxlU2VsZWN0b3Ioc2VsZWN0b3IsIG1hY3JvLCBtb2RlLCBjYWxsYmFjayk7XG5cbiAgICAgIGxvb3AgKz0gbW9kZSB8fCBtb2RlID09PSBudWxsID8gJ3snICsgc291cmNlICsgJ30nIDogc291cmNlO1xuXG4gICAgICBpZiAobW9kZSB8fCBtb2RlID09PSBudWxsICYmIHNlbGVjdG9yLmluY2x1ZGVzKCc6bnRoJykpIHtcbiAgICAgICAgbG9vcCArPSByZU50aEVsZW0udGVzdChzZWxlY3RvcikgPyAncy5udGhFbGVtZW50KG51bGwsIDIpOycgOiAnJztcbiAgICAgICAgbG9vcCArPSByZU50aFR5cGUudGVzdChzZWxlY3RvcikgPyAncy5udGhPZlR5cGUobnVsbCwgMik7JyA6ICcnO1xuICAgICAgfVxuXG4gICAgICBpZiAoU19WQVJTWzBdIHx8IE1fVkFSU1swXSB8fCBOX1ZBUlNbMF0pIHtcbiAgICAgICAgdmFycyA9ICcsJyArIChTX1ZBUlMuam9pbignLCcpIHx8IE1fVkFSUy5qb2luKCcsJykgfHwgTl9WQVJTWzBdKTtcbiAgICAgICAgU19WQVJTLmxlbmd0aCA9IDA7XG4gICAgICAgIE1fVkFSUy5sZW5ndGggPSAwO1xuICAgICAgICBOX1ZBUlMubGVuZ3RoID0gMDtcbiAgICAgIH1cblxuICAgICAgZmFjdG9yeSA9IEZ1bmN0aW9uKCdzJywgRl9JTklUICsgJ3snICsgaGVhZCArIHZhcnMgKyAnOycgKyBsb29wICsgJ3JldHVybiByO30nKShTbmFwc2hvdCk7XG5cbiAgICAgIHJldHVybiBtb2RlIHx8IG1vZGUgPT09IG51bGwgPyAoc2VsZWN0TGFtYmRhc1tzZWxlY3Rvcl0gPSBmYWN0b3J5KSA6IChtYXRjaExhbWJkYXNbc2VsZWN0b3JdID0gZmFjdG9yeSk7XG4gICAgfSxcblxuICAvLyBidWlsZCBjb25kaXRpb25hbCBjb2RlIHRvIGNoZWNrIGNvbXBvbmVudHMgb2Ygc2VsZWN0b3Igc3RyaW5nc1xuICBjb21waWxlU2VsZWN0b3IgPVxuICAgIGZ1bmN0aW9uKGV4cHJlc3Npb24sIHNvdXJjZSwgbW9kZSwgY2FsbGJhY2spIHtcblxuICAgICAgdmFyIGEsIGIsIG4sIGYsIGsgPSAwLCBuYW1lLCBOUywgcmVmZXJlbmNlRWxlbWVudCxcbiAgICAgIGNvbXBhdCwgZXhwciwgbWF0Y2gsIHJlc3VsdCwgc3RhdHVzLCBzeW1ib2wsIHRlc3QsXG4gICAgICB0eXBlLCBzZWxlY3RvciA9IGV4cHJlc3Npb24sIHNlbGVjdG9yX3N0cmluZywgdmFycztcblxuICAgICAgLy8gb3JpZ2luYWwgJ3NlbGVjdCcgb3IgJ21hdGNoJyBzZWxlY3RvciBzdHJpbmcgYmVmb3JlIG5vcm1hbGl6YXRpb25cbiAgICAgIHNlbGVjdG9yX3N0cmluZyA9IG1vZGUgPyBsYXN0U2VsZWN0ZWQgOiBsYXN0TWF0Y2hlZDtcblxuICAgICAgLy8gaXNvbGF0ZSBzZWxlY3RvciBjb21iaW5hdG9ycy9jb21wb25lbnRzIGFuZCBub3JtYWxpemUgd2hpdGVzcGFjZVxuICAgICAgc2VsZWN0b3IgPSBzZWxlY3Rvci5yZXBsYWNlKFNURC5jb21iaW5hdG9yLCAnJDEnKTsvLy5yZXBsYWNlKFNURC53aGl0ZXNwYWNlLCAnICcpO1xuXG4gICAgICAvLyBqYXZhc2NyaXB0IG5lZWRzIGEgbGFiZWwgdG8gYnJlYWtcbiAgICAgIC8vIG91dCBvZiB0aGUgd2hpbGUgbG9vcHMgcHJvY2Vzc2luZ1xuICAgICAgc2VsZWN0b3JfcmVjdXJzaW9uX2xhYmVsOlxuXG4gICAgICB3aGlsZSAoc2VsZWN0b3IpIHtcblxuICAgICAgICArK2s7XG5cbiAgICAgICAgLy8gZ2V0IG5hbWVzcGFjZSBwcmVmaXggaWYgcHJlc2VudCBvciBnZXQgZmlyc3QgY2hhciBvZiBzZWxlY3RvclxuICAgICAgICBzeW1ib2wgPSBTVEQuYXBpbWV0aG9kcy50ZXN0KHNlbGVjdG9yKSA/ICd8JyA6IHNlbGVjdG9yWzBdO1xuXG4gICAgICAgIHN3aXRjaCAoc3ltYm9sKSB7XG5cbiAgICAgICAgICAvLyB1bml2ZXJzYWwgcmVzb2x2ZXJcbiAgICAgICAgICBjYXNlICcqJzpcbiAgICAgICAgICAgIG1hdGNoID0gc2VsZWN0b3IubWF0Y2goUGF0dGVybnMudW5pdmVyc2FsKTtcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gaWQgcmVzb2x2ZXJcbiAgICAgICAgICBjYXNlICcjJzpcbiAgICAgICAgICAgIG1hdGNoID0gc2VsZWN0b3IubWF0Y2goUGF0dGVybnMuaWQpO1xuICAgICAgICAgICAgc291cmNlID0gJ2lmKCgvXicgKyBtYXRjaFsxXSArICckLy50ZXN0KGUuZ2V0QXR0cmlidXRlKFwiaWRcIikpKSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gY2xhc3MgbmFtZSByZXNvbHZlclxuICAgICAgICAgIGNhc2UgJy4nOlxuICAgICAgICAgICAgbWF0Y2ggPSBzZWxlY3Rvci5tYXRjaChQYXR0ZXJucy5jbGFzc05hbWUpO1xuICAgICAgICAgICAgY29tcGF0ID0gKFFVSVJLU19NT0RFID8gJ2knIDogJycpICsgJy50ZXN0KGUuZ2V0QXR0cmlidXRlKFwiY2xhc3NcIikpJztcbiAgICAgICAgICAgIHNvdXJjZSA9ICdpZigoLyhefFxcXFxzKScgKyBtYXRjaFsxXSArICcoXFxcXHN8JCkvJyArIGNvbXBhdCArICcpKXsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyB0YWcgbmFtZSByZXNvbHZlclxuICAgICAgICAgIGNhc2UgKC9bX2Etel0vaS50ZXN0KHN5bWJvbCkgPyBzeW1ib2wgOiB1bmRlZmluZWQpOlxuICAgICAgICAgICAgbWF0Y2ggPSBzZWxlY3Rvci5tYXRjaChQYXR0ZXJucy50YWdOYW1lKTtcbiAgICAgICAgICAgIHNvdXJjZSA9ICdpZigoZS5sb2NhbE5hbWU9PVwiJyArIG1hdGNoWzFdICsgJ1wiKSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gbmFtZXNwYWNlIHJlc29sdmVyXG4gICAgICAgICAgY2FzZSAnfCc6XG4gICAgICAgICAgICBtYXRjaCA9IHNlbGVjdG9yLm1hdGNoKFBhdHRlcm5zLm5hbWVzcGFjZSk7XG4gICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzFdID09ICcqJykge1xuICAgICAgICAgICAgICBzb3VyY2UgPSAnaWYodHJ1ZSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoIW1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgIHNvdXJjZSA9ICdpZigoIWUubmFtZXNwYWNlVVJJKSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG1hdGNoWzFdID09ICdzdHJpbmcnICYmIHJvb3QucHJlZml4ID09IG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgIHNvdXJjZSA9ICdpZigoZS5uYW1lc3BhY2VVUkk9PVwiJyArIE5BTUVTUEFDRSArICdcIikpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBlbWl0KCdcXCcnICsgc2VsZWN0b3Jfc3RyaW5nICsgJ1xcJycgKyBxc0ludmFsaWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyBhdHRyaWJ1dGVzIHJlc29sdmVyXG4gICAgICAgICAgY2FzZSAnWyc6XG4gICAgICAgICAgICBtYXRjaCA9IHNlbGVjdG9yLm1hdGNoKFBhdHRlcm5zLmF0dHJpYnV0ZSk7XG4gICAgICAgICAgICBOUyA9IG1hdGNoWzBdLm1hdGNoKFNURC5uYW1lc3BhY2VzKTtcbiAgICAgICAgICAgIG5hbWUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIGV4cHIgPSBuYW1lLnNwbGl0KCc6Jyk7XG4gICAgICAgICAgICBleHByID0gZXhwci5sZW5ndGggPT0gMiA/IGV4cHJbMV0gOiBleHByWzBdO1xuICAgICAgICAgICAgaWYgKG1hdGNoWzJdICYmICEodGVzdCA9IE9wZXJhdG9yc1ttYXRjaFsyXV0pKSB7XG4gICAgICAgICAgICAgIGVtaXQoJ1xcJycgKyBzZWxlY3Rvcl9zdHJpbmcgKyAnXFwnJyArIHFzSW52YWxpZCk7XG4gICAgICAgICAgICAgIHJldHVybiAnJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtYXRjaFs0XSA9PT0gJycpIHtcbiAgICAgICAgICAgICAgdGVzdCA9IG1hdGNoWzJdID09ICd+PScgP1xuICAgICAgICAgICAgICAgIHsgcDE6ICdeXFxcXHMnLCBwMjogJyskJywgcDM6ICd0cnVlJyB9IDpcbiAgICAgICAgICAgICAgICAgIG1hdGNoWzJdIGluIEFUVFJfU1REX09QUyAmJiBtYXRjaFsyXSAhPSAnfj0nID9cbiAgICAgICAgICAgICAgICB7IHAxOiAnXicsICAgIHAyOiAnJCcsICBwMzogJ3RydWUnIH0gOiB0ZXN0O1xuICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFsyXSA9PSAnfj0nICYmIG1hdGNoWzRdLmluY2x1ZGVzKCcgJykpIHtcbiAgICAgICAgICAgICAgLy8gd2hpdGVzcGFjZSBzZXBhcmF0ZWQgbGlzdCBidXQgdmFsdWUgY29udGFpbnMgc3BhY2VcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzRdKSB7XG4gICAgICAgICAgICAgIG1hdGNoWzRdID0gY29udmVydEVzY2FwZXMobWF0Y2hbNF0pLnJlcGxhY2UoUkVYLlJlZ0V4cENoYXIsICdcXFxcJCYnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGUgPSBtYXRjaFs1XSA9PSAnaScgfHwgKEhUTUxfRE9DVU1FTlQgJiYgSFRNTF9UQUJMRVtleHByLnRvTG93ZXJDYXNlKCldKSA/ICdpJyA6ICcnO1xuICAgICAgICAgICAgc291cmNlID0gJ2lmKCgnICtcbiAgICAgICAgICAgICAgKCFtYXRjaFsyXSA/IChOUyA/ICdzLmhhc0F0dHJpYnV0ZU5TKGUsXCInICsgbmFtZSArICdcIiknIDogJ2UuaGFzQXR0cmlidXRlJiZlLmhhc0F0dHJpYnV0ZShcIicgKyBuYW1lICsgJ1wiKScpIDpcbiAgICAgICAgICAgICAgIW1hdGNoWzRdICYmIEFUVFJfU1REX09QU1ttYXRjaFsyXV0gJiYgbWF0Y2hbMl0gIT0gJ349JyA/ICdlLmdldEF0dHJpYnV0ZSYmZS5nZXRBdHRyaWJ1dGUoXCInICsgbmFtZSArICdcIik9PVwiXCInIDpcbiAgICAgICAgICAgICAgJygvJyArIHRlc3QucDEgKyBtYXRjaFs0XSArIHRlc3QucDIgKyAnLycgKyB0eXBlICsgJykudGVzdChlLmdldEF0dHJpYnV0ZSYmZS5nZXRBdHRyaWJ1dGUoXCInICsgbmFtZSArICdcIikpPT0nICsgdGVzdC5wMykgK1xuICAgICAgICAgICAgICAnKSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gKioqIEdlbmVyYWwgc2libGluZyBjb21iaW5hdG9yXG4gICAgICAgICAgLy8gRSB+IEYgKEYgcmVsYXRpdmUgc2libGluZyBvZiBFKVxuICAgICAgICAgIGNhc2UgJ34nOlxuICAgICAgICAgICAgbWF0Y2ggPSBzZWxlY3Rvci5tYXRjaChQYXR0ZXJucy5yZWxhdGl2ZSk7XG4gICAgICAgICAgICBzb3VyY2UgPSAndmFyIE4nICsgayArICc9ZTt3aGlsZShlJiYoZT1lLnByZXZpb3VzRWxlbWVudFNpYmxpbmcpKXsnICsgc291cmNlICsgJ31lPU4nICsgayArICc7JztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIC8vICoqKiBBZGphY2VudCBzaWJsaW5nIGNvbWJpbmF0b3JcbiAgICAgICAgICAvLyBFICsgRiAoRiBhZGlhY2VudCBzaWJsaW5nIG9mIEUpXG4gICAgICAgICAgY2FzZSAnKyc6XG4gICAgICAgICAgICBtYXRjaCA9IHNlbGVjdG9yLm1hdGNoKFBhdHRlcm5zLmFkamFjZW50KTtcbiAgICAgICAgICAgIHNvdXJjZSA9ICd2YXIgTicgKyBrICsgJz1lO2lmKGUmJihlPWUucHJldmlvdXNFbGVtZW50U2libGluZykpeycgKyBzb3VyY2UgKyAnfWU9TicgKyBrICsgJzsnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gKioqIERlc2NlbmRhbnQgY29tYmluYXRvclxuICAgICAgICAgIC8vIEUgRiAoRSBhbmNlc3RvciBvZiBGKVxuICAgICAgICAgIGNhc2UgJ1xceDA5JzpcbiAgICAgICAgICBjYXNlICdcXHgyMCc6XG4gICAgICAgICAgICBtYXRjaCA9IHNlbGVjdG9yLm1hdGNoKFBhdHRlcm5zLmFuY2VzdG9yKTtcbiAgICAgICAgICAgIHNvdXJjZSA9ICd2YXIgTicgKyBrICsgJz1lO3doaWxlKGUmJihlPWUucGFyZW50RWxlbWVudCkpeycgKyBzb3VyY2UgKyAnfWU9TicgKyBrICsgJzsnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgLy8gKioqIENoaWxkIGNvbWJpbmF0b3JcbiAgICAgICAgICAvLyBFID4gRiAoRiBjaGlsZHJlbiBvZiBFKVxuICAgICAgICAgIGNhc2UgJz4nOlxuICAgICAgICAgICAgbWF0Y2ggPSBzZWxlY3Rvci5tYXRjaChQYXR0ZXJucy5jaGlsZHJlbik7XG4gICAgICAgICAgICBzb3VyY2UgPSAndmFyIE4nICsgayArICc9ZTtpZihlJiYoZT1lLnBhcmVudEVsZW1lbnQpKXsnICsgc291cmNlICsgJ31lPU4nICsgayArICc7JztcbiAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgLy8gKioqIHVzZXIgc3VwcGxpZWQgY29tYmluYXRvcnMgZXh0ZW5zaW9uc1xuICAgICAgICAgIGNhc2UgKHN5bWJvbCBpbiBDb21iaW5hdG9ycyA/IHN5bWJvbCA6IHVuZGVmaW5lZCk6XG4gICAgICAgICAgICAvLyBmb3Igb3RoZXIgcmVnaXN0ZXJlZCBjb21iaW5hdG9ycyBleHRlbnNpb25zXG4gICAgICAgICAgICBtYXRjaFttYXRjaC5sZW5ndGggLSAxXSA9ICcqJztcbiAgICAgICAgICAgIHNvdXJjZSA9IENvbWJpbmF0b3JzW3N5bWJvbF0obWF0Y2gpICsgc291cmNlO1xuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAvLyAqKiogdHJlZS1zdHJ1Y3R1cmFsIHBzZXVkby1jbGFzc2VzXG4gICAgICAgICAgLy8gOnJvb3QsIDplbXB0eSwgOmZpcnN0LWNoaWxkLCA6bGFzdC1jaGlsZCwgOm9ubHktY2hpbGQsIDpmaXJzdC1vZi10eXBlLCA6bGFzdC1vZi10eXBlLCA6b25seS1vZi10eXBlXG4gICAgICAgICAgY2FzZSAnOic6XG4gICAgICAgICAgICBpZiAoKG1hdGNoID0gc2VsZWN0b3IubWF0Y2goUGF0dGVybnMuc3RydWN0dXJhbCkpKSB7XG4gICAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgc3dpdGNoIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Njb3BlJzpcbiAgICAgICAgICAgICAgICAgIC8vIHVzZSB0aGUgcm9vdCAoZG9jdW1lbnRFbGVtZW50KSB3aGVuIGNvbXBhcmluZyBhZ2FpbnN0IGEgZG9jdW1lbnRcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdpZihlPT09KHMuZnJvbS5ub2RlVHlwZT09PTk/cy5yb290OnMuZnJvbSkpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyb290JzpcbiAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGNhbiBvbmx5IGJlIG9uZSA6cm9vdCBlbGVtZW50LCBzbyBleGl0IHRoZSBsb29wIG9uY2UgZm91bmRcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdpZigoZT09PXMucm9vdCkpeycgKyBzb3VyY2UgKyAobW9kZSA/ICdicmVhayBtYWluOycgOiAnJykgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdlbXB0eSc6XG4gICAgICAgICAgICAgICAgICAvLyBtYXRjaGVzIGVsZW1lbnRzIHRoYXQgZG9uJ3QgY29udGFpbiBlbGVtZW50cyBvciB0ZXh0IG5vZGVzXG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPSAnbj1lLmZpcnN0Q2hpbGQ7d2hpbGUobiYmISgvMXwzLykudGVzdChuLm5vZGVUeXBlKSl7bj1uLm5leHRTaWJsaW5nfWlmKCFuKXsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICAgICAgICAvLyAqKiogY2hpbGQtaW5kZXhlZCBwc2V1ZG8tY2xhc3Nlc1xuICAgICAgICAgICAgICAgIC8vIDpmaXJzdC1jaGlsZCwgOmxhc3QtY2hpbGQsIDpvbmx5LWNoaWxkXG4gICAgICAgICAgICAgICAgY2FzZSAnb25seS1jaGlsZCc6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPSAnaWYoKCFlLm5leHRFbGVtZW50U2libGluZyYmIWUucHJldmlvdXNFbGVtZW50U2libGluZykpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsYXN0LWNoaWxkJzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdpZigoIWUubmV4dEVsZW1lbnRTaWJsaW5nKSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZpcnN0LWNoaWxkJzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdpZigoIWUucHJldmlvdXNFbGVtZW50U2libGluZykpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcblxuICAgICAgICAgICAgICAgIC8vICoqKiB0eXBlZCBjaGlsZC1pbmRleGVkIHBzZXVkby1jbGFzc2VzXG4gICAgICAgICAgICAgICAgLy8gOm9ubHktb2YtdHlwZSwgOmxhc3Qtb2YtdHlwZSwgOmZpcnN0LW9mLXR5cGVcbiAgICAgICAgICAgICAgICBjYXNlICdvbmx5LW9mLXR5cGUnOlxuICAgICAgICAgICAgICAgICAgc291cmNlID0gJ289ZS5sb2NhbE5hbWU7JyArXG4gICAgICAgICAgICAgICAgICAgICduPWU7d2hpbGUoKG49bi5uZXh0RWxlbWVudFNpYmxpbmcpJiZuLmxvY2FsTmFtZSE9byk7aWYoIW4peycgK1xuICAgICAgICAgICAgICAgICAgICAnbj1lO3doaWxlKChuPW4ucHJldmlvdXNFbGVtZW50U2libGluZykmJm4ubG9jYWxOYW1lIT1vKTt9aWYoIW4peycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsYXN0LW9mLXR5cGUnOlxuICAgICAgICAgICAgICAgICAgc291cmNlID0gJ249ZTtvPWUubG9jYWxOYW1lO3doaWxlKChuPW4ubmV4dEVsZW1lbnRTaWJsaW5nKSYmbi5sb2NhbE5hbWUhPW8pO2lmKCFuKXsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmlyc3Qtb2YtdHlwZSc6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPSAnbj1lO289ZS5sb2NhbE5hbWU7d2hpbGUoKG49bi5wcmV2aW91c0VsZW1lbnRTaWJsaW5nKSYmbi5sb2NhbE5hbWUhPW8pO2lmKCFuKXsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGVtaXQoJ1xcJycgKyBzZWxlY3Rvcl9zdHJpbmcgKyAnXFwnJyArIHFzSW52YWxpZCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAqKiogY2hpbGQtaW5kZXhlZCAmIHR5cGVkIGNoaWxkLWluZGV4ZWQgcHNldWRvLWNsYXNzZXNcbiAgICAgICAgICAgIC8vIDpudGgtY2hpbGQsIDpudGgtb2YtdHlwZSwgOm50aC1sYXN0LWNoaWxkLCA6bnRoLWxhc3Qtb2YtdHlwZVxuICAgICAgICAgICAgZWxzZSBpZiAoKG1hdGNoID0gc2VsZWN0b3IubWF0Y2goUGF0dGVybnMudHJlZXN0cnVjdCkpKSB7XG4gICAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgc3dpdGNoIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ250aC1jaGlsZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnbnRoLW9mLXR5cGUnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ250aC1sYXN0LWNoaWxkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdudGgtbGFzdC1vZi10eXBlJzpcbiAgICAgICAgICAgICAgICAgIGV4cHIgPSAvLW9mLXR5cGUvaS50ZXN0KG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICAgIGlmIChtYXRjaFsxXSAmJiBtYXRjaFsyXSkge1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gL2xhc3QvaS50ZXN0KG1hdGNoWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoWzJdID09ICduJykge1xuICAgICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdpZih0cnVlKXsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzJdID09ICcxJykge1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3QgPSB0eXBlID8gJ25leHQnIDogJ3ByZXZpb3VzJztcbiAgICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSBleHByID8gJ249ZTtvPWUubG9jYWxOYW1lOycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ3doaWxlKChuPW4uJyArIHRlc3QgKyAnRWxlbWVudFNpYmxpbmcpJiZuLmxvY2FsTmFtZSE9byk7aWYoIW4peycgKyBzb3VyY2UgKyAnfScgOlxuICAgICAgICAgICAgICAgICAgICAgICAgJ2lmKCFlLicgKyB0ZXN0ICsgJ0VsZW1lbnRTaWJsaW5nKXsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG1hdGNoWzJdID09ICdldmVuJyB8fCBtYXRjaFsyXSA9PSAnMm4wJyB8fCBtYXRjaFsyXSA9PSAnMm4rMCcgfHwgbWF0Y2hbMl0gPT0gJzJuJykge1xuICAgICAgICAgICAgICAgICAgICAgIHRlc3QgPSAnbiUyPT0wJztcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChtYXRjaFsyXSA9PSAnb2RkJyAgfHwgbWF0Y2hbMl0gPT0gJzJuMScgfHwgbWF0Y2hbMl0gPT0gJzJuKzEnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdGVzdCA9ICduJTI9PTEnO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIGYgPSAvbi9pLnRlc3QobWF0Y2hbMl0pO1xuICAgICAgICAgICAgICAgICAgICAgIG4gPSBtYXRjaFsyXS5zcGxpdCgnbicpO1xuICAgICAgICAgICAgICAgICAgICAgIGEgPSBwYXJzZUludChuWzBdLCAxMCkgfHwgMDtcbiAgICAgICAgICAgICAgICAgICAgICBiID0gcGFyc2VJbnQoblsxXSwgMTApIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKG5bMF0gPT0gJy0nKSB7IGEgPSAtMTsgfVxuICAgICAgICAgICAgICAgICAgICAgIGlmIChuWzBdID09ICcrJykgeyBhID0gKzE7IH1cbiAgICAgICAgICAgICAgICAgICAgICB0ZXN0ID0gKGIgPyAnKG4nICsgKGIgPiAwID8gJy0nIDogJysnKSArIE1hdGguYWJzKGIpICsgJyknIDogJ24nKSArICclJyArIGEgKyAnPT0wJyA7XG4gICAgICAgICAgICAgICAgICAgICAgdGVzdCA9XG4gICAgICAgICAgICAgICAgICAgICAgICBhID49ICsxID8gKGYgPyAnbj4nICsgKGIgLSAxKSArIChNYXRoLmFicyhhKSAhPSAxID8gJyYmJyArIHRlc3QgOiAnJykgOiAnbj09JyArIGEpIDpcbiAgICAgICAgICAgICAgICAgICAgICAgIGEgPD0gLTEgPyAoZiA/ICduPCcgKyAoYiArIDEpICsgKE1hdGguYWJzKGEpICE9IDEgPyAnJiYnICsgdGVzdCA6ICcnKSA6ICduPT0nICsgYSkgOlxuICAgICAgICAgICAgICAgICAgICAgICAgYSA9PT0gMCA/IChuWzBdID8gJ249PScgKyBiIDogJ24+JyArIChiIC0gMSkpIDogJ2ZhbHNlJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBleHByID0gZXhwciA/ICdPZlR5cGUnIDogJ0VsZW1lbnQnO1xuICAgICAgICAgICAgICAgICAgICB0eXBlID0gdHlwZSA/ICd0cnVlJyA6ICdmYWxzZSc7XG4gICAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICduPXMubnRoJyArIGV4cHIgKyAnKGUsJyArIHR5cGUgKyAnKTtpZigoJyArIHRlc3QgKyAnKSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGVtaXQoJ1xcJycgKyBzZWxlY3Rvcl9zdHJpbmcgKyAnXFwnJyArIHFzSW52YWxpZCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgZW1pdCgnXFwnJyArIHNlbGVjdG9yX3N0cmluZyArICdcXCcnICsgcXNJbnZhbGlkKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICoqKiBsb2dpY2FsIGNvbWJpbmF0aW9uIHBzZXVkby1jbGFzc2VzXG4gICAgICAgICAgICAvLyA6aXMoIHMxLCBbIHMyLCAuLi4gXSksIDpub3QoIHMxLCBbIHMyLCAuLi4gXSlcbiAgICAgICAgICAgIC8vIDp3aGVyZSggczEsIFsgczIsIC4uLiBdKSwgOm1hdGNoZXMoIHMxLCBbIHMyLCAuLi4gXSksXG4gICAgICAgICAgICBlbHNlIGlmICgobWF0Y2ggPSBzZWxlY3Rvci5tYXRjaChQYXR0ZXJucy5sb2dpY2Fsc2VsKSkpIHtcbiAgICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBleHByID0gbWF0Y2hbMl0ucmVwbGFjZShSRVguQ29tbWFHcm91cCwgJywnKS5yZXBsYWNlKFJFWC5UcmltU3BhY2VzLCAnJyk7XG4gICAgICAgICAgICAgIGV4cHIgPSBleHByLnJlcGxhY2UoL1xceDIyL2csICdcXFxcXCInKTtcbiAgICAgICAgICAgICAgc3dpdGNoIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2lzJzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICAgICd0cnl7JyArXG4gICAgICAgICAgICAgICAgICAgICAgJ2lmKHMubWF0Y2goXCInICsgZXhwciArICdcIixlKSl7JyArIHNvdXJjZSArICd9JyArXG4gICAgICAgICAgICAgICAgICAgICd9Y2F0Y2goRSl7JyArXG4gICAgICAgICAgICAgICAgICAgICAgJ2NvbnNvbGUubG9nKEUpJyArXG4gICAgICAgICAgICAgICAgICAgICd9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3doZXJlJzpcbiAgICAgICAgICAgICAgICBjYXNlICdtYXRjaGVzJzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdpZihzLm1hdGNoKFwiJyArIGV4cHIgKyAnXCIsZSkpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdub3QnOlxuICAgICAgICAgICAgICAgICAgc291cmNlID0gJ2lmKCFzLm1hdGNoKFwiJyArIGV4cHIgKyAnXCIsZSkpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdoYXMnOlxuICAgICAgICAgICAgICAgICAgaWYgKC9eXFxzKihcXCt8XFx+KS8udGVzdChtYXRjaFsyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgc291cmNlID0gJ2lmKGUucGFyZW50RWxlbWVudCYmQXJyYXkuZnJvbShlLnBhcmVudEVsZW1lbnQnICtcbiAgICAgICAgICAgICAgICAgICAgICAoL15cXHMqWytdLy50ZXN0KG1hdGNoWzJdKSA/XG4gICAgICAgICAgICAgICAgICAgICAgICAnLnF1ZXJ5U2VsZWN0b3JBbGwoXCIqJyArIGV4cHIgKyAnXCIpJyA6ICcuY2hpbGRyZW4nKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnKS5pbmNsdWRlcyhlLm5leHRFbGVtZW50U2libGluZykpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBzb3VyY2UgPSAnaWYoZS5xdWVyeVNlbGVjdG9yKFwiOnNjb3BlICcgKyBleHByICsgJ1wiKSknICtcbiAgICAgICAgICAgICAgICAgICAgICAneycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgZW1pdCgnXFwnJyArIHNlbGVjdG9yX3N0cmluZyArICdcXCcnICsgcXNJbnZhbGlkKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICoqKiBsaW5ndWlzdGljIHBzZXVkby1jbGFzc2VzXG4gICAgICAgICAgICAvLyA6ZGlyKCBsdHIgLyBydGwgKSwgOmxhbmcoIGVuIClcbiAgICAgICAgICAgIGVsc2UgaWYgKChtYXRjaCA9IHNlbGVjdG9yLm1hdGNoKFBhdHRlcm5zLmxpbmd1aXN0aWMpKSkge1xuICAgICAgICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIHN3aXRjaCAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdkaXInOlxuICAgICAgICAgICAgICAgICAgc291cmNlID0gJ3ZhciBwO2lmKCgnICtcbiAgICAgICAgICAgICAgICAgICAgJygvJyArIG1hdGNoWzJdICsgJy9pLnRlc3QoZS5kaXIpKXx8KHA9cy5hbmNlc3RvcihcIltkaXJdXCIsIGUpKSYmJyArXG4gICAgICAgICAgICAgICAgICAgICcoLycgKyBtYXRjaFsyXSArICcvaS50ZXN0KHAuZGlyKSl8fChlLmRpcj09XCJcInx8ZS5kaXI9PVwiYXV0b1wiKSYmJyArXG4gICAgICAgICAgICAgICAgICAgICcoJyArIChtYXRjaFsyXSA9PSAnbHRyJyA/ICchJzonJykrIFJUTCArJy50ZXN0KGUudGV4dENvbnRlbnQpKSknICtcbiAgICAgICAgICAgICAgICAgICAgJyl7JyArIHNvdXJjZSArICd9Oyc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdsYW5nJzpcbiAgICAgICAgICAgICAgICAgIGV4cHIgPSAnKD86XnwtKScgKyBtYXRjaFsyXSArICcoPzotfCQpJztcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICd2YXIgcDtpZigoJyArXG4gICAgICAgICAgICAgICAgICAgICcoZS5pc0Nvbm5lY3RlZCYmKGUubGFuZz09XCJcIiYmKHA9cy5hbmNlc3RvcihcIltsYW5nXVwiLGUpKSkmJicgK1xuICAgICAgICAgICAgICAgICAgICAnKHAubGFuZz09XCInICsgbWF0Y2hbMl0gKyAnXCIpfHwvJysgZXhwciArJy9pLnRlc3QoZS5sYW5nKSkpJyArXG4gICAgICAgICAgICAgICAgICAgICcpeycgKyBzb3VyY2UgKyAnfTsnO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGVtaXQoJ1xcJycgKyBzZWxlY3Rvcl9zdHJpbmcgKyAnXFwnJyArIHFzSW52YWxpZCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAqKiogbG9jYXRpb24gcHNldWRvLWNsYXNzZXNcbiAgICAgICAgICAgIC8vIDphbnktbGluaywgOmxpbmssIDp2aXNpdGVkLCA6dGFyZ2V0LCA6ZGVmaW5lZFxuICAgICAgICAgICAgZWxzZSBpZiAoKG1hdGNoID0gc2VsZWN0b3IubWF0Y2goUGF0dGVybnMubG9jYXRpb25wYykpKSB7XG4gICAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgc3dpdGNoIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FueS1saW5rJzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdpZigoL15hfGFyZWEkL2kudGVzdChlLmxvY2FsTmFtZSkmJmUuaGFzQXR0cmlidXRlKFwiaHJlZlwiKXx8ZS52aXNpdGVkKSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xpbmsnOlxuICAgICAgICAgICAgICAgICAgc291cmNlID0gJ2lmKCgvXmF8YXJlYSQvaS50ZXN0KGUubG9jYWxOYW1lKSYmZS5oYXNBdHRyaWJ1dGUoXCJocmVmXCIpKSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3Zpc2l0ZWQnOlxuICAgICAgICAgICAgICAgICAgc291cmNlID0gJ2lmKCgvXmF8YXJlYSQvaS50ZXN0KGUubG9jYWxOYW1lKSYmZS5oYXNBdHRyaWJ1dGUoXCJocmVmXCIpJiZlLnZpc2l0ZWQpKXsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAndGFyZ2V0JzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdpZigoKHMuZG9jLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKGUpJjE2KSYmcy5kb2MubG9jYXRpb24uaGFzaCYmZS5pZD09cy5kb2MubG9jYXRpb24uaGFzaC5zbGljZSgxKSkpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkZWZpbmVkJzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICduPXMuZG9jLmRlZmF1bHRWaWV3LmN1c3RvbUVsZW1lbnRzLmdldChlLmxvY2FsTmFtZSk7aWYobiYmZSBpbnN0YW5jZW9mIG4peycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgZW1pdCgnXFwnJyArIHNlbGVjdG9yX3N0cmluZyArICdcXCcnICsgcXNJbnZhbGlkKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vICoqKiB1c2VyIGFjdGlvbnMgcHNldWRvLWNsYXNzZXNcbiAgICAgICAgICAgIC8vIDpob3ZlciwgOmFjdGl2ZSwgOmZvY3VzLCA6Zm9jdXMtdmlzaWJsZSwgOmZvY3VzLXdpdGhpblxuICAgICAgICAgICAgZWxzZSBpZiAoKG1hdGNoID0gc2VsZWN0b3IubWF0Y2goUGF0dGVybnMudXNlcmFjdGlvbikpKSB7XG4gICAgICAgICAgICAgIG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgc3dpdGNoIChtYXRjaFsxXSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2hvdmVyJzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdpZihlPT09cy5IT1ZFUil7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2FjdGl2ZSc6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPSAnaWYoZT09PXMuZG9jLmFjdGl2ZUVsZW1lbnQpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmb2N1cyc6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPSAnaWYocy5pc0ZvY3VzYWJsZShlKSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZvY3VzLXZpc2libGUnOlxuICAgICAgICAgICAgICAgICAgc291cmNlID0gJ2lmKG49cy5pc0ZvY3VzYWJsZShlKSl7JyArXG4gICAgICAgICAgICAgICAgICAgICdpZihlIT09bil7d2hpbGUoZSl7ZT1lLnBhcmVudEVsZW1lbnQ7aWYoZT09PW4pYnJlYWs7fX19JyArXG4gICAgICAgICAgICAgICAgICAgICdpZigoZT09PW58fGUuYXV0b2ZvY3VzKSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZvY3VzLXdpdGhpbic6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPSAnaWYobj1zLmlzRm9jdXNhYmxlKGUpKXsnICtcbiAgICAgICAgICAgICAgICAgICAgJ2lmKG4hPT1lKXt3aGlsZShuKXtuPW4ucGFyZW50RWxlbWVudDtpZihuPT09ZSlicmVhazt9fX0nICtcbiAgICAgICAgICAgICAgICAgICAgJ2lmKChuPT09ZXx8bi5hdXRvZm9jdXMpKXsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgIGVtaXQoJ1xcJycgKyBzZWxlY3Rvcl9zdHJpbmcgKyAnXFwnJyArIHFzSW52YWxpZCk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyAqKiogdXNlciBpbnRlcmZhY2UgYW5kIGZvcm0gcHNldWRvLWNsYXNzZXNcbiAgICAgICAgICAgIC8vIDplbmFibGVkLCA6ZGlzYWJsZWQsIDpyZWFkLW9ubHksIDpyZWFkLXdyaXRlLCA6cGxhY2Vob2xkZXItc2hvd24sIDpkZWZhdWx0XG4gICAgICAgICAgICBlbHNlIGlmICgobWF0Y2ggPSBzZWxlY3Rvci5tYXRjaChQYXR0ZXJucy5pbnB1dHN0YXRlKSkpIHtcbiAgICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnZW5hYmxlZCc6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPSAnaWYoKChcImZvcm1cIiBpbiBlfHwvXm9wdGdyb3VwJC9pLnRlc3QoZS5sb2NhbE5hbWUpKSYmXCJkaXNhYmxlZFwiIGluIGUgJiZlLmRpc2FibGVkPT09ZmFsc2UnICtcbiAgICAgICAgICAgICAgICAgICAgJykpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNhYmxlZCc6XG4gICAgICAgICAgICAgICAgICAvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNlbmFibGluZy1hbmQtZGlzYWJsaW5nLWZvcm0tY29udHJvbHM6LXRoZS1kaXNhYmxlZC1hdHRyaWJ1dGVcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdpZigoKFwiZm9ybVwiIGluIGV8fC9eb3B0Z3JvdXAkL2kudGVzdChlLmxvY2FsTmFtZSkpJiZcImRpc2FibGVkXCIgaW4gZSkpeycgK1xuICAgICAgICAgICAgICAgICAgICAvLyBGIGlzIHRydWUgaWYgYW55IG9mIHRoZSBmaWVsZHNldCBlbGVtZW50cyBpbiB0aGUgYW5jZXN0cnkgY2hhaW4gaGFzIHRoZSBkaXNhYmxlZCBhdHRyaWJ1dGUgc3BlY2lmaWVkXG4gICAgICAgICAgICAgICAgICAgIC8vIEwgaXMgdHJ1ZSBpZiB0aGUgZmlyc3QgbGVnZW5kIGVsZW1lbnQgb2YgdGhlIGZpZWxkc2V0IGNvbnRhaW5zIHRoZSBlbGVtZW50XG4gICAgICAgICAgICAgICAgICAgICd2YXIgeD0wLE49W10sRj1mYWxzZSxMPWZhbHNlOycgK1xuICAgICAgICAgICAgICAgICAgICAnaWYoISgvXihvcHRncm91cHxvcHRpb24pJC9pLnRlc3QoZS5sb2NhbE5hbWUpKSl7JyArXG4gICAgICAgICAgICAgICAgICAgICAgJ249ZS5wYXJlbnRFbGVtZW50OycgK1xuICAgICAgICAgICAgICAgICAgICAgICd3aGlsZShuKXsnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZihuLmxvY2FsTmFtZT09XCJmaWVsZHNldFwiKXsnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgJ05beCsrXT1uOycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnaWYobi5kaXNhYmxlZD09PXRydWUpeycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICdGPXRydWU7JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgJ2JyZWFrOycgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAnfScgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ30nICtcbiAgICAgICAgICAgICAgICAgICAgICAgICduPW4ucGFyZW50RWxlbWVudDsnICtcbiAgICAgICAgICAgICAgICAgICAgICAnfScgK1xuICAgICAgICAgICAgICAgICAgICAgICdmb3IodmFyIHg9MDt4PE4ubGVuZ3RoO3grKyl7JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAnaWYoKG49cy5maXJzdChcImxlZ2VuZFwiLE5beF0pKSYmbi5jb250YWlucyhlKSl7JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdMPXRydWU7JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICdicmVhazsnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgICAgICAgJ30nICtcbiAgICAgICAgICAgICAgICAgICAgJ30nICtcbiAgICAgICAgICAgICAgICAgICAgJ2lmKGUuZGlzYWJsZWQ9PT10cnVlfHwoRiYmIUwpKXsnICsgc291cmNlICsgJ319JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3JlYWQtb25seSc6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICAnaWYoJyArXG4gICAgICAgICAgICAgICAgICAgICAgJygvXnRleHRhcmVhJC9pLnRlc3QoZS5sb2NhbE5hbWUpJiYoZS5yZWFkT25seXx8ZS5kaXNhYmxlZCkpfHwnICtcbiAgICAgICAgICAgICAgICAgICAgICAnKC9eaW5wdXQkL2kudGVzdChlLmxvY2FsTmFtZSkmJihcInxkYXRlfGRhdGV0aW1lLWxvY2FsfGVtYWlsfG1vbnRofG51bWJlcnxwYXNzd29yZHxzZWFyY2h8dGVsfHRleHR8dGltZXx1cmx8d2Vla3xcIi5pbmNsdWRlcyhcInxcIitlLnR5cGUrXCJ8XCIpPyhlLnJlYWRPbmx5fHxlLmRpc2FibGVkKTp0cnVlKSl8fCcgK1xuICAgICAgICAgICAgICAgICAgICAgICcoIS9eKD86aW5wdXR8dGV4dGFyZWEpJC9pLnRlc3QoZS5sb2NhbE5hbWUpICYmICFzLmlzQ29udGVudEVkaXRhYmxlKGUpKScgK1xuICAgICAgICAgICAgICAgICAgICAnKXsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAncmVhZC13cml0ZSc6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICAnaWYoJyArXG4gICAgICAgICAgICAgICAgICAgICAgJygvXnRleHRhcmVhJC9pLnRlc3QoZS5sb2NhbE5hbWUpJiYhZS5yZWFkT25seSYmIWUuZGlzYWJsZWQpfHwnICtcbiAgICAgICAgICAgICAgICAgICAgICAnKC9eaW5wdXQkL2kudGVzdChlLmxvY2FsTmFtZSkmJlwifGRhdGV8ZGF0ZXRpbWUtbG9jYWx8ZW1haWx8bW9udGh8bnVtYmVyfHBhc3N3b3JkfHNlYXJjaHx0ZWx8dGV4dHx0aW1lfHVybHx3ZWVrfFwiLmluY2x1ZGVzKFwifFwiK2UudHlwZStcInxcIikmJiFlLnJlYWRPbmx5JiYhZS5kaXNhYmxlZCl8fCcgK1xuICAgICAgICAgICAgICAgICAgICAgICcoIS9eKD86aW5wdXR8dGV4dGFyZWEpJC9pLnRlc3QoZS5sb2NhbE5hbWUpICYmIHMuaXNDb250ZW50RWRpdGFibGUoZSkpJyArXG4gICAgICAgICAgICAgICAgICAgICcpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdwbGFjZWhvbGRlci1zaG93bic6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICAnaWYoKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICcoL15pbnB1dHx0ZXh0YXJlYSQvaS50ZXN0KGUubG9jYWxOYW1lKSkmJmUuaGFzQXR0cmlidXRlKFwicGxhY2Vob2xkZXJcIikmJicgK1xuICAgICAgICAgICAgICAgICAgICAgICcoXCJ8dGV4dGFyZWF8cGFzc3dvcmR8bnVtYmVyfHNlYXJjaHxlbWFpbHx0ZXh0fHRlbHx1cmx8XCIuaW5jbHVkZXMoXCJ8XCIrZS50eXBlK1wifFwiKSkmJicgK1xuICAgICAgICAgICAgICAgICAgICAgICcoIXMubWF0Y2goXCI6Zm9jdXNcIixlKSknICtcbiAgICAgICAgICAgICAgICAgICAgJykpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkZWZhdWx0JzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICAgICdpZigoXCJmb3JtXCIgaW4gZSAmJiBlLmZvcm0pKXsnICtcbiAgICAgICAgICAgICAgICAgICAgICAndmFyIHg9MDtuPVtdOycgK1xuICAgICAgICAgICAgICAgICAgICAgICdpZihlLnR5cGU9PVwiaW1hZ2VcIiluPWUuZm9ybS5nZXRFbGVtZW50c0J5VGFnTmFtZShcImlucHV0XCIpOycgK1xuICAgICAgICAgICAgICAgICAgICAgICdpZihlLnR5cGU9PVwic3VibWl0XCIpbj1lLmZvcm0uZWxlbWVudHM7JyArXG4gICAgICAgICAgICAgICAgICAgICAgJ3doaWxlKG5beF0mJmUhPT1uW3hdKXsnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZihuW3hdLnR5cGU9PVwiaW1hZ2VcIilicmVhazsnICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdpZihuW3hdLnR5cGU9PVwic3VibWl0XCIpYnJlYWs7JyArXG4gICAgICAgICAgICAgICAgICAgICAgICAneCsrOycgK1xuICAgICAgICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgICAgICd9JyArXG4gICAgICAgICAgICAgICAgICAgICdpZigoZS5mb3JtJiYoZT09PW5beF0mJlwifGltYWdlfHN1Ym1pdHxcIi5pbmNsdWRlcyhcInxcIitlLnR5cGUrXCJ8XCIpKXx8JyArXG4gICAgICAgICAgICAgICAgICAgICAgJygoL15vcHRpb24kL2kudGVzdChlLmxvY2FsTmFtZSkpJiZlLmRlZmF1bHRTZWxlY3RlZCl8fCcgK1xuICAgICAgICAgICAgICAgICAgICAgICcoKFwifHJhZGlvfGNoZWNrYm94fFwiLmluY2x1ZGVzKFwifFwiK2UudHlwZStcInxcIikpJiZlLmRlZmF1bHRDaGVja2VkKScgK1xuICAgICAgICAgICAgICAgICAgICAnKSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBlbWl0KCdcXCcnICsgc2VsZWN0b3Jfc3RyaW5nICsgJ1xcJycgKyBxc0ludmFsaWQpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gKioqIGlucHV0IHBzZXVkby1jbGFzc2VzIChmb3IgZm9ybSB2YWxpZGF0aW9uKVxuICAgICAgICAgICAgLy8gOmNoZWNrZWQsIDppbmRldGVybWluYXRlLCA6dmFsaWQsIDppbnZhbGlkLCA6aW4tcmFuZ2UsIDpvdXQtb2YtcmFuZ2UsIDpyZXF1aXJlZCwgOm9wdGlvbmFsXG4gICAgICAgICAgICBlbHNlIGlmICgobWF0Y2ggPSBzZWxlY3Rvci5tYXRjaChQYXR0ZXJucy5pbnB1dHZhbHVlKSkpIHtcbiAgICAgICAgICAgICAgbWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tlZCc6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPSAnaWYoKC9eaW5wdXQkL2kudGVzdChlLmxvY2FsTmFtZSkmJicgK1xuICAgICAgICAgICAgICAgICAgICAnKFwifHJhZGlvfGNoZWNrYm94fFwiLmluY2x1ZGVzKFwifFwiK2UudHlwZStcInxcIikmJmUuY2hlY2tlZCl8fCcgK1xuICAgICAgICAgICAgICAgICAgICAnKC9eb3B0aW9uJC9pLnRlc3QoZS5sb2NhbE5hbWUpJiYoZS5zZWxlY3RlZHx8ZS5jaGVja2VkKSknICtcbiAgICAgICAgICAgICAgICAgICAgJykpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbmRldGVybWluYXRlJzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICAgICdpZigoL15wcm9ncmVzcyQvaS50ZXN0KGUubG9jYWxOYW1lKSYmIWUuaGFzQXR0cmlidXRlKFwidmFsdWVcIikpfHwnICtcbiAgICAgICAgICAgICAgICAgICAgICAnKC9eaW5wdXQkL2kudGVzdChlLmxvY2FsTmFtZSkmJihcImNoZWNrYm94XCI9PWUudHlwZSYmZS5pbmRldGVybWluYXRlKXx8JyArXG4gICAgICAgICAgICAgICAgICAgICAgJyhcInJhZGlvXCI9PWUudHlwZSYmZS5uYW1lJiYhcy5maXJzdChcImlucHV0W25hbWU9XCIrZS5uYW1lK1wiXTpjaGVja2VkXCIsZS5mb3JtKSknICtcbiAgICAgICAgICAgICAgICAgICAgJykpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdyZXF1aXJlZCc6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPVxuICAgICAgICAgICAgICAgICAgICAnaWYoKC9eaW5wdXR8c2VsZWN0fHRleHRhcmVhJC9pLnRlc3QoZS5sb2NhbE5hbWUpJiZlLnJlcXVpcmVkKScgK1xuICAgICAgICAgICAgICAgICAgICAnKXsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnb3B0aW9uYWwnOlxuICAgICAgICAgICAgICAgICAgc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgJ2lmKCgvXmlucHV0fHNlbGVjdHx0ZXh0YXJlYSQvaS50ZXN0KGUubG9jYWxOYW1lKSYmIWUucmVxdWlyZWQpJyArXG4gICAgICAgICAgICAgICAgICAgICcpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdpbnZhbGlkJzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICAgICdpZigoKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICcoL15mb3JtJC9pLnRlc3QoZS5sb2NhbE5hbWUpJiYhZS5ub1ZhbGlkYXRlKXx8JyArXG4gICAgICAgICAgICAgICAgICAgICAgJyhlLndpbGxWYWxpZGF0ZSYmIWUuZm9ybU5vVmFsaWRhdGUpKSYmIWUuY2hlY2tWYWxpZGl0eSgpKXx8JyArXG4gICAgICAgICAgICAgICAgICAgICAgJygvXmZpZWxkc2V0JC9pLnRlc3QoZS5sb2NhbE5hbWUpJiZzLmZpcnN0KFwiOmludmFsaWRcIixlKSknICtcbiAgICAgICAgICAgICAgICAgICAgJyl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3ZhbGlkJzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICAgICdpZigoKCcgK1xuICAgICAgICAgICAgICAgICAgICAgICcoL15mb3JtJC9pLnRlc3QoZS5sb2NhbE5hbWUpJiYhZS5ub1ZhbGlkYXRlKXx8JyArXG4gICAgICAgICAgICAgICAgICAgICAgJyhlLndpbGxWYWxpZGF0ZSYmIWUuZm9ybU5vVmFsaWRhdGUpKSYmZS5jaGVja1ZhbGlkaXR5KCkpfHwnICtcbiAgICAgICAgICAgICAgICAgICAgICAnKC9eZmllbGRzZXQkL2kudGVzdChlLmxvY2FsTmFtZSkmJnMuZmlyc3QoXCI6dmFsaWRcIixlKSknICtcbiAgICAgICAgICAgICAgICAgICAgJyl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2luLXJhbmdlJzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9XG4gICAgICAgICAgICAgICAgICAgICdpZigoL15pbnB1dCQvaS50ZXN0KGUubG9jYWxOYW1lKSkmJicgK1xuICAgICAgICAgICAgICAgICAgICAgICcoZS53aWxsVmFsaWRhdGUmJiFlLmZvcm1Ob1ZhbGlkYXRlKSYmJyArXG4gICAgICAgICAgICAgICAgICAgICAgJyghZS52YWxpZGl0eS5yYW5nZVVuZGVyZmxvdyYmIWUudmFsaWRpdHkucmFuZ2VPdmVyZmxvdykmJicgK1xuICAgICAgICAgICAgICAgICAgICAgICcoXCJ8ZGF0ZXxkYXRldGltZS1sb2NhbHxtb250aHxudW1iZXJ8cmFuZ2V8dGltZXx3ZWVrfFwiLmluY2x1ZGVzKFwifFwiK2UudHlwZStcInxcIikpJiYnICtcbiAgICAgICAgICAgICAgICAgICAgICAnKFwicmFuZ2VcIj09ZS50eXBlfHxlLmdldEF0dHJpYnV0ZShcIm1pblwiKXx8ZS5nZXRBdHRyaWJ1dGUoXCJtYXhcIikpJyArXG4gICAgICAgICAgICAgICAgICAgICcpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdvdXQtb2YtcmFuZ2UnOlxuICAgICAgICAgICAgICAgICAgc291cmNlID1cbiAgICAgICAgICAgICAgICAgICAgJ2lmKCgvXmlucHV0JC9pLnRlc3QoZS5sb2NhbE5hbWUpKSYmJyArXG4gICAgICAgICAgICAgICAgICAgICAgJyhlLndpbGxWYWxpZGF0ZSYmIWUuZm9ybU5vVmFsaWRhdGUpJiYnICtcbiAgICAgICAgICAgICAgICAgICAgICAnKGUudmFsaWRpdHkucmFuZ2VVbmRlcmZsb3d8fGUudmFsaWRpdHkucmFuZ2VPdmVyZmxvdykmJicgK1xuICAgICAgICAgICAgICAgICAgICAgICcoXCJ8ZGF0ZXxkYXRldGltZS1sb2NhbHxtb250aHxudW1iZXJ8cmFuZ2V8dGltZXx3ZWVrfFwiLmluY2x1ZGVzKFwifFwiK2UudHlwZStcInxcIikpJiYnICtcbiAgICAgICAgICAgICAgICAgICAgICAnKFwicmFuZ2VcIj09ZS50eXBlfHxlLmdldEF0dHJpYnV0ZShcIm1pblwiKXx8ZS5nZXRBdHRyaWJ1dGUoXCJtYXhcIikpJyArXG4gICAgICAgICAgICAgICAgICAgICcpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgZW1pdCgnXFwnJyArIHNlbGVjdG9yX3N0cmluZyArICdcXCcnICsgcXNJbnZhbGlkKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIHJlc291cmNlcyBzdGF0ZSBwc2V1ZG8tY2xhc3NlcyAobXVsdGltZWRpYSBzdGF0ZSlcbiAgICAgICAgICAgIC8vIDpwbGF5aW5nLCA6cGF1c2VkLCA6c2Vla2luZywgOmJ1ZmZlcmluZywgOnN0YWxsZWQsIDptdXRlZCwgOnZvbHVtZS1sb2NrZWRcbiAgICAgICAgICAgIGVsc2UgaWYgKChtYXRjaCA9IHNlbGVjdG9yLm1hdGNoKFBhdHRlcm5zLnJzcmNfc3RhdGUpKSkge1xuICAgICAgICAgICAgICBtYXRjaFsxXSA9IG1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICAgIHN3aXRjaCAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlICdwbGF5aW5nJzpcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9ICdpZihzLmlzUGxheWluZyhlKSl7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3BhdXNlZCc6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPSAnaWYoIXMuaXNQbGF5aW5nKGUpKXsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnc2Vla2luZyc6XG4gICAgICAgICAgICAgICAgICBzb3VyY2UgPSAnaWYoIXMuaXNQbGF5aW5nKGUpKXsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnYnVmZmVyaW5nJzpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ3N0YWxsZWQnOlxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnbXV0ZWQnOlxuICAgICAgICAgICAgICAgICAgc291cmNlID0gJ2lmKGUubG9jYWxOYW1lPT1cImF1ZGlvXCImJmUuZ2V0QXR0cmlidXRlKFwibXV0ZWRcIikpeycgKyBzb3VyY2UgKyAnfSc7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICd2b2x1bWUtbG9ja2VkJzpcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBwbGFjZWhvbGRlciBmb3IgcGFyc2Ugb25seSBuby1vcCBzZWxlY3RvcnNcbiAgICAgICAgICAgIGVsc2UgaWYgKChtYXRjaCA9IHNlbGVjdG9yLm1hdGNoKFBhdHRlcm5zLnBzZXVkb19ub3ApKSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxsb3cgcHNldWRvLWVsZW1lbnRzIHN0YXJ0aW5nIHdpdGggc2luZ2xlIGNvbG9uICg6KVxuICAgICAgICAgICAgLy8gOmFmdGVyLCA6YmVmb3JlLCA6Zmlyc3QtbGV0dGVyLCA6Zmlyc3QtbGluZVxuICAgICAgICAgICAgLy8gYXNzZXJ0OiBlLnR5cGUgaXMgaW4gZG91YmxlLWNvbG9uIGZvcm1hdCwgbGlrZSA6OmFmdGVyXG4gICAgICAgICAgICBlbHNlIGlmICgobWF0Y2ggPSBzZWxlY3Rvci5tYXRjaChQYXR0ZXJucy5wc2V1ZG9fc25nKSkpIHtcbiAgICAgICAgICAgICAgc291cmNlID0gJ2lmKGUuZWxlbWVudCYmZS50eXBlLnRvTG93ZXJDYXNlKCk9PVwiJyArXG4gICAgICAgICAgICAgICAgJzonICsgbWF0Y2hbMF0udG9Mb3dlckNhc2UoKSArICdcIil7ZT1lLmVsZW1lbnQ7JyArIHNvdXJjZSArICd9JztcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gYWxsb3cgcHNldWRvLWVsZW1lbnRzIHN0YXJ0aW5nIHdpdGggZG91YmxlIGNvbG9uICg6OilcbiAgICAgICAgICAgIC8vIDo6YWZ0ZXIsIDo6YmVmb3JlLCA6Om1hcmtlciwgOjpwbGFjZWhvbGRlciwgOjppbmFjdGl2ZS1zZWxlY3Rpb24sIDo6c2VsZWN0aW9uLCA6Oi13ZWJraXQtPGZvby1iYXI+XG4gICAgICAgICAgICAvLyBhc3NlcnQ6IGUudHlwZSBpcyBpbiBkb3VibGUtY29sb24gZm9ybWF0LCBsaWtlIDo6YWZ0ZXJcbiAgICAgICAgICAgIGVsc2UgaWYgKChtYXRjaCA9IHNlbGVjdG9yLm1hdGNoKFBhdHRlcm5zLnBzZXVkb19kYmwpKSkge1xuICAgICAgICAgICAgICBzb3VyY2UgPSAnaWYoZS5lbGVtZW50JiZlLnR5cGUudG9Mb3dlckNhc2UoKT09XCInICtcbiAgICAgICAgICAgICAgICBtYXRjaFswXS50b0xvd2VyQ2FzZSgpICsgJ1wiKXtlPWUuZWxlbWVudDsnICsgc291cmNlICsgJ30nO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBlbHNlIHtcblxuICAgICAgICAgICAgICAvLyByZXNldFxuICAgICAgICAgICAgICBleHByID0gZmFsc2U7XG4gICAgICAgICAgICAgIHN0YXR1cyA9IGZhbHNlO1xuXG4gICAgICAgICAgICAgIC8vIHByb2Nlc3MgcmVnaXN0ZXJlZCBzZWxlY3RvciBleHRlbnNpb25zXG4gICAgICAgICAgICAgIGZvciAoZXhwciBpbiBTZWxlY3RvcnMpIHtcbiAgICAgICAgICAgICAgICBpZiAoKG1hdGNoID0gc2VsZWN0b3IubWF0Y2goU2VsZWN0b3JzW2V4cHJdLkV4cHJlc3Npb24pKSkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gU2VsZWN0b3JzW2V4cHJdLkNhbGxiYWNrKG1hdGNoLCBzb3VyY2UsIG1vZGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgIGlmICgnbWF0Y2gnIGluIHJlc3VsdCkgeyBtYXRjaCA9IHJlc3VsdC5tYXRjaDsgfVxuICAgICAgICAgICAgICAgICAgdmFycyA9IHJlc3VsdC5tb2R2YXI7XG4gICAgICAgICAgICAgICAgICBpZiAobW9kZSkge1xuICAgICAgICAgICAgICAgICAgICAgLy8gYWRkIGV4dHJhIHNlbGVjdCgpIHZhcnNcbiAgICAgICAgICAgICAgICAgICAgIHZhcnMgJiYgU19WQVJTLmluZGV4T2YodmFycykgPCAwICYmIChTX1ZBUlNbU19WQVJTLmxlbmd0aF0gPSB2YXJzKTtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAvLyBhZGQgZXh0cmEgbWF0Y2goKSB2YXJzXG4gICAgICAgICAgICAgICAgICAgICB2YXJzICYmIE1fVkFSUy5pbmRleE9mKHZhcnMpIDwgMCAmJiAoTV9WQVJTW01fVkFSUy5sZW5ndGhdID0gdmFycyk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBleHRlbnNpb24gc291cmNlIGNvZGVcbiAgICAgICAgICAgICAgICAgIHNvdXJjZSA9IHJlc3VsdC5zb3VyY2U7XG4gICAgICAgICAgICAgICAgICAvLyBleHRlbnNpb24gc3RhdHVzIGNvZGVcbiAgICAgICAgICAgICAgICAgIHN0YXR1cyA9IHJlc3VsdC5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAvLyBicmVhayBvbiBzdGF0dXMgZXJyb3JcbiAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXMpIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIXN0YXR1cykge1xuICAgICAgICAgICAgICAgIGVtaXQoJ3Vua25vd24gcHNldWRvLWNsYXNzIHNlbGVjdG9yIFxcJycgKyBzZWxlY3RvciArICdcXCcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBpZiAoIWV4cHIpIHtcbiAgICAgICAgICAgICAgICBlbWl0KCd1bmtub3duIHRva2VuIGluIHNlbGVjdG9yIFxcJycgKyBzZWxlY3RvciArICdcXCcnKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gJyc7XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICBlbWl0KCdcXCcnICsgc2VsZWN0b3Jfc3RyaW5nICsgJ1xcJycgKyBxc0ludmFsaWQpO1xuICAgICAgICAgIGJyZWFrIHNlbGVjdG9yX3JlY3Vyc2lvbl9sYWJlbDtcblxuICAgICAgICB9XG4gICAgICAgIC8vIGVuZCBvZiBzd2l0Y2ggc3ltYm9sXG5cbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgIGVtaXQoJ1xcJycgKyBzZWxlY3Rvcl9zdHJpbmcgKyAnXFwnJyArIHFzSW52YWxpZCk7XG4gICAgICAgICAgcmV0dXJuICcnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcG9wIGxhc3QgY29tcG9uZW50XG4gICAgICAgIHNlbGVjdG9yID0gbWF0Y2gucG9wKCk7XG4gICAgICB9XG4gICAgICAvLyBlbmQgb2Ygd2hpbGUgc2VsZWN0b3JcblxuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9LFxuXG4gIC8vIHJlcGxhY2UgOnNjb3BlIGNvbnRleHQgZWxlbWVudCBhcyBhXG4gIC8vIGEgcmVmZXJlbmNlIGluIHRoZSBzZWxlY3RvciBzdHJpbmdcbiAgbWFrZXJlZiA9XG4gICAgZnVuY3Rpb24oc2VsZWN0b3JzLCBlbGVtZW50KSB7XG4gICAgICAvLyByZXBsYWNlIERPQ1VNRU5UIHdpdGggZmlyc3QgZWxlbWVudCAocm9vdClcbiAgICAgIGlmIChlbGVtZW50Lm5vZGVUeXBlID09PSA5KSB7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBzZWxlY3RvcnMucmVwbGFjZSgvOnNjb3BlL2ksXG4gICAgICAgIChlbGVtZW50LmxvY2FsTmFtZSkgK1xuICAgICAgICAoZWxlbWVudC5pZCA/ICcjJyArIGVzY2FwZShlbGVtZW50LmlkKSA6ICcnKSArXG4gICAgICAgIChlbGVtZW50LmNsYXNzTmFtZSA/ICcuJyArIGVzY2FwZShlbGVtZW50LmNsYXNzTGlzdFswXSkgOiAnJykpO1xuICAgIH0sXG5cbiAgLy8gZXF1aXZhbGVudCBvZiB3M2MgJ2Nsb3Nlc3QnIG1ldGhvZFxuICBhbmNlc3RvciA9XG4gICAgZnVuY3Rpb24gX2Nsb3Nlc3Qoc2VsZWN0b3JzLCBlbGVtZW50LCBjYWxsYmFjaykge1xuICAgICAgcGFyc2Uoc2VsZWN0b3JzLCB0cnVlKTtcbiAgICAgIHNlbGVjdG9ycyA9IG1ha2VyZWYoc2VsZWN0b3JzLCBlbGVtZW50KTtcbiAgICAgIHdoaWxlIChlbGVtZW50KSB7XG4gICAgICAgIGlmIChtYXRjaChzZWxlY3RvcnMsIGVsZW1lbnQsIGNhbGxiYWNrKSkgYnJlYWs7XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudEVsZW1lbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZWxlbWVudDtcbiAgICB9LFxuXG4gIG1hdGNoX2Fzc2VydCA9XG4gICAgZnVuY3Rpb24oZiwgZWxlbWVudCwgY2FsbGJhY2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZi5sZW5ndGgsIHIgPSBmYWxzZTsgbCA+IGk7ICsraSlcbiAgICAgICAgZltpXShlbGVtZW50LCBjYWxsYmFjaywgbnVsbCwgZmFsc2UpICYmIChyID0gdHJ1ZSk7XG4gICAgICByZXR1cm4gcjtcbiAgICB9LFxuXG4gIG1hdGNoX2NvbGxlY3QgPVxuICAgIGZ1bmN0aW9uKHNlbGVjdG9ycywgY2FsbGJhY2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gc2VsZWN0b3JzLmxlbmd0aCwgZiA9IFsgXTsgbCA+IGk7ICsraSlcbiAgICAgICAgZltpXSA9IGNvbXBpbGUoc2VsZWN0b3JzW2ldLCBmYWxzZSwgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuIHsgZmFjdG9yeTogZiB9O1xuICAgIH0sXG5cbiAgLy8gdW5pcXVlIHBhcnNlciBlbnRyeSBwb2ludCBmb3IgYWxsXG4gIC8vIG1ldGhvZHMgKHR5cGUgbWF0Y2hpbmcvc2VsZWN0aW5nKVxuICBwYXJzZSA9XG4gICAgZnVuY3Rpb24oc2VsZWN0b3JzLCB0eXBlKSB7XG5cbiAgICAgIHZhciBwYXJzZWQ7XG5cbiAgICAgIC8vIGFyZ3VtZW50cyB2YWxpZGF0aW9uXG4gICAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBlbWl0KHFzTm90QXJncywgVHlwZUVycm9yKTtcbiAgICAgICAgcmV0dXJuIENvbmZpZy5WRVJCT1NJVFkgPyB1bmRlZmluZWQgOiAodHlwZSA/IG5vbmUgOiBmYWxzZSk7XG4gICAgICB9IGVsc2UgaWYgKGFyZ3VtZW50c1swXSA9PT0gJycpIHtcbiAgICAgICAgZW1pdCgnXFwnXFwnJyArIHFzSW52YWxpZCk7XG4gICAgICAgIHJldHVybiBDb25maWcuVkVSQk9TSVRZID8gdW5kZWZpbmVkIDogKHR5cGUgPyBub25lIDogZmFsc2UpO1xuICAgICAgfVxuXG4gICAgICAvLyBpbnB1dCBOVUxMIG9yIFVOREVGSU5FRFxuICAgICAgaWYgKHR5cGVvZiBzZWxlY3RvcnMgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgc2VsZWN0b3JzID0gJycgKyBzZWxlY3RvcnM7XG4gICAgICB9XG5cbiAgICAgIGlmICgoLzpzY29wZS9pKS50ZXN0KHNlbGVjdG9ycykpIHtcbiAgICAgICAgc2VsZWN0b3JzID0gbWFrZXJlZihzZWxlY3RvcnMsIFNuYXBzaG90LmZyb20pO1xuICAgICAgfVxuXG4gICAgICAvLyBub3JtYWxpemUgaW5wdXQgc3RyaW5nXG4gICAgICBwYXJzZWQgPSBzZWxlY3RvcnMuXG4gICAgICAgIHJlcGxhY2UoL1xceDAwfFxcXFwkL2csICdcXHVmZmZkJykuXG4gICAgICAgIHJlcGxhY2UoUkVYLkNvbWJpbmVXU1AsICdcXHgyMCcpLlxuICAgICAgICByZXBsYWNlKFJFWC5Qc2V1ZG9zV1NQLCAnJDEnKS5cbiAgICAgICAgcmVwbGFjZShSRVguVGFiQ2hhcldTUCwgJ1xcdCcpLlxuICAgICAgICByZXBsYWNlKFJFWC5Db21tYUdyb3VwLCAnLCcpLlxuICAgICAgICByZXBsYWNlKFJFWC5UcmltU3BhY2VzLCAnJyk7XG5cbiAgICAgIC8vIHBhcnNlLCB2YWxpZGF0ZSBhbmQgc3BsaXQgcG9zc2libGUgY29tcG91bmQgc2VsZWN0b3JzXG4gICAgICBpZiAoKHNlbGVjdG9ycyA9IHBhcnNlZC5tYXRjaChyZVZhbGlkYXRvcikpICYmIHNlbGVjdG9ycy5qb2luKCcnKSA9PSBwYXJzZWQpIHtcbiAgICAgICAgc2VsZWN0b3JzID0gcGFyc2VkLm1hdGNoKFJFWC5TcGxpdEdyb3VwKTtcbiAgICAgICAgaWYgKHBhcnNlZFtwYXJzZWQubGVuZ3RoIC0gMV0gPT0gJywnKSB7XG4gICAgICAgICAgZW1pdChxc0ludmFsaWQpO1xuICAgICAgICAgIHJldHVybiBDb25maWcuVkVSQk9TSVRZID8gdW5kZWZpbmVkIDogKHR5cGUgPyBub25lIDogZmFsc2UpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbWl0KCdcXCcnICsgc2VsZWN0b3JzICsgJ1xcJycgKyBxc0ludmFsaWQpO1xuICAgICAgICByZXR1cm4gQ29uZmlnLlZFUkJPU0lUWSA/IHVuZGVmaW5lZCA6ICh0eXBlID8gbm9uZSA6IGZhbHNlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNlbGVjdG9ycztcbiAgICB9LFxuXG4gIC8vIGVxdWl2YWxlbnQgb2YgdzNjICdtYXRjaGVzJyBtZXRob2RcbiAgbWF0Y2ggPVxuICAgIGZ1bmN0aW9uIF9tYXRjaGVzKHNlbGVjdG9ycywgZWxlbWVudCwgY2FsbGJhY2spIHtcblxuICAgICAgaWYgKGVsZW1lbnQgJiYgbWF0Y2hSZXNvbHZlcnNbc2VsZWN0b3JzXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hfYXNzZXJ0KG1hdGNoUmVzb2x2ZXJzW3NlbGVjdG9yc10uZmFjdG9yeSwgZWxlbWVudCwgY2FsbGJhY2spO1xuICAgICAgfVxuXG4gICAgICBtYXRjaFJlc29sdmVyc1tzZWxlY3RvcnNdID0gbWF0Y2hfY29sbGVjdChwYXJzZShzZWxlY3RvcnMsIGZhbHNlKSwgY2FsbGJhY2spO1xuXG4gICAgICByZXR1cm4gbWF0Y2hfYXNzZXJ0KG1hdGNoUmVzb2x2ZXJzW3NlbGVjdG9yc10uZmFjdG9yeSwgZWxlbWVudCwgY2FsbGJhY2spO1xuICAgIH0sXG5cbiAgLy8gZXF1aXZhbGVudCBvZiB3M2MgJ3F1ZXJ5U2VsZWN0b3InIG1ldGhvZFxuICBmaXJzdCA9XG4gICAgZnVuY3Rpb24gX3F1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3JzLCBjb250ZXh0LCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHNlbGVjdChzZWxlY3RvcnMsIGNvbnRleHQsXG4gICAgICAgIHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nID9cbiAgICAgICAgZnVuY3Rpb24gZmlyc3RNYXRjaChlbGVtZW50KSB7XG4gICAgICAgICAgY2FsbGJhY2soZWxlbWVudCk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9IDpcbiAgICAgICAgZnVuY3Rpb24gZmlyc3RNYXRjaCgpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIClbMF0gfHwgbnVsbDtcbiAgICB9LFxuXG4gIC8vIGVxdWl2YWxlbnQgb2YgdzNjICdxdWVyeVNlbGVjdG9yQWxsJyBtZXRob2RcbiAgc2VsZWN0ID1cbiAgICBmdW5jdGlvbiBfcXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcnMsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG5cbiAgICAgIHZhciBub2RlcyA9IFsgXSwgcmVzb2x2ZXI7XG5cbiAgICAgIGFyZ3VtZW50cy5sZW5ndGggPT0gMCAmJlxuICAgICAgICBlbWl0KHFzTm90QXJncywgVHlwZUVycm9yKTtcblxuICAgICAgY29udGV4dCB8fCAoY29udGV4dCA9IGRvYyk7XG4gICAgICAgIGxhc3RDb250ZXh0ICE9PSBjb250ZXh0ICYmXG4gICAgICAgICAgKGxhc3RDb250ZXh0ID0gc3dpdGNoQ29udGV4dChjb250ZXh0KSk7XG5cbiAgICAgIGlmIChzZWxlY3RvcnMpIHtcbiAgICAgICAgaWYgKChyZXNvbHZlciA9IHNlbGVjdFJlc29sdmVyc1tzZWxlY3RvcnNdKSkge1xuICAgICAgICAgIGlmIChyZXNvbHZlci5jb250ZXh0ID09PSBjb250ZXh0ICYmIHJlc29sdmVyLmNhbGxiYWNrID09PSBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIGYgPSByZXNvbHZlci5mYWN0b3J5LCBoID0gcmVzb2x2ZXIuaHRtbHNldCwgbiA9IHJlc29sdmVyLm5vZGVzZXQ7XG4gICAgICAgICAgICBpZiAobi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbi5sZW5ndGgsIGxpc3Q7IGwgPiBpOyArK2kpIHtcbiAgICAgICAgICAgICAgICBsaXN0ID0gY29tcGF0W25baV1bMF1dKGNvbnRleHQsIG5baV0uc2xpY2UoMSkpKCk7XG4gICAgICAgICAgICAgICAgaWYgKGZbaV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIGZbaV0obGlzdCwgY2FsbGJhY2ssIGNvbnRleHQsIG5vZGVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbm9kZXMgPSBub2Rlcy5jb25jYXQobGlzdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChsID4gMSAmJiBub2Rlcy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbm9kZXMuc29ydChkb2N1bWVudE9yZGVyKTtcbiAgICAgICAgICAgICAgICBoYXNEdXBlcyAmJiAobm9kZXMgPSB1bmlxdWUobm9kZXMpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgaWYgKGZbMF0pIHtcbiAgICAgICAgICAgICAgICBub2RlcyA9IGZbMF0oaFswXSgpLCBjYWxsYmFjaywgY29udGV4dCwgbm9kZXMpO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIG5vZGVzID0gaFswXSgpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgbm9kZXMgPSBjb25jYXRDYWxsKG5vZGVzLCBjYWxsYmFjayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gIUNvbmZpZy5BTk9ERUxJU1QgPyBub2RlcyA6IG5vZGVzIGluc3RhbmNlb2YgZ2xvYmFsLk5vZGVMaXN0ID8gbm9kZXMgOiB0b05vZGVMaXN0KG5vZGVzKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gc2F2ZS9yZXVzZSBmYWN0b3J5IGFuZCBjbG9zdXJlIGNvbGxlY3Rpb25cbiAgICAgIHNlbGVjdFJlc29sdmVyc1tzZWxlY3RvcnNdID0gY29sbGVjdChwYXJzZShzZWxlY3RvcnMsIHRydWUpLCBjb250ZXh0LCBjYWxsYmFjayk7XG5cbiAgICAgIG5vZGVzID0gc2VsZWN0UmVzb2x2ZXJzW3NlbGVjdG9yc10ucmVzdWx0cztcblxuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIG5vZGVzID0gY29uY2F0Q2FsbChub2RlcywgY2FsbGJhY2spO1xuICAgICAgfVxuICAgICAgcmV0dXJuICFDb25maWcuQU5PREVMSVNUID8gbm9kZXMgOiBub2RlcyBpbnN0YW5jZW9mIGdsb2JhbC5Ob2RlTGlzdCA/IG5vZGVzIDogdG9Ob2RlTGlzdChub2Rlcyk7XG4gICAgfSxcblxuICAvLyBvcHRpbWl6ZSBzZWxlY3RvcnMgYXZvaWRpbmcgZHVwbGljYXRlZCBjaGVja3NcbiAgb3B0aW1pemUgPVxuICAgIGZ1bmN0aW9uKHNlbGVjdG9yLCB0b2tlbikge1xuICAgICAgdmFyIGluZGV4ID0gdG9rZW4uaW5kZXgsXG4gICAgICBsZW5ndGggPSB0b2tlblsxXS5sZW5ndGggKyB0b2tlblsyXS5sZW5ndGg7XG4gICAgICByZXR1cm4gc2VsZWN0b3Iuc2xpY2UoMCwgaW5kZXgpICtcbiAgICAgICAgKCcgPit+Jy5pbmRleE9mKHNlbGVjdG9yLmNoYXJBdChpbmRleCAtIDEpKSA+IC0xID9cbiAgICAgICAgICAoJzpbJy5pbmRleE9mKHNlbGVjdG9yLmNoYXJBdChpbmRleCArIGxlbmd0aCArIDEpKSA+IC0xID9cbiAgICAgICAgICAnKicgOiAnJykgOiAnJykgKyBzZWxlY3Rvci5zbGljZShpbmRleCArIGxlbmd0aCAtICh0b2tlblsxXSA9PSAnKicgPyAxIDogMCkpO1xuICAgIH0sXG5cbiAgLy8gcHJlcGFyZSBmYWN0b3J5IHJlc29sdmVycyBhbmQgY2xvc3VyZSBjb2xsZWN0aW9uc1xuICBjb2xsZWN0ID1cbiAgICBmdW5jdGlvbihzZWxlY3RvcnMsIGNvbnRleHQsIGNhbGxiYWNrKSB7XG5cbiAgICAgIHZhciBpLCBsLCBzZWVuID0geyB9LCB0b2tlbiA9IFsnJywgJyonLCAnKiddLCBvcHRpbWl6ZWQgPSBzZWxlY3RvcnMsXG4gICAgICBmYWN0b3J5ID0gWyBdLCBodG1sc2V0ID0gWyBdLCBub2Rlc2V0ID0gWyBdLCByZXN1bHRzID0gWyBdLCB0eXBlO1xuXG4gICAgICBmb3IgKGkgPSAwLCBsID0gc2VsZWN0b3JzLmxlbmd0aDsgbCA+IGk7ICsraSkge1xuXG4gICAgICAgIGlmICghc2VlbltzZWxlY3RvcnNbaV1dICYmIChzZWVuW3NlbGVjdG9yc1tpXV0gPSB0cnVlKSkge1xuICAgICAgICAgIHR5cGUgPSBzZWxlY3RvcnNbaV0ubWF0Y2gocmVPcHRpbWl6ZXIpO1xuICAgICAgICAgIGlmICh0eXBlICYmIHR5cGVbMV0gIT0gJzonICYmICh0b2tlbiA9IHR5cGUpKSB7XG4gICAgICAgICAgICB0b2tlblsxXSB8fCAodG9rZW5bMV0gPSAnKicpO1xuICAgICAgICAgICAgb3B0aW1pemVkW2ldID0gb3B0aW1pemUob3B0aW1pemVkW2ldLCB0b2tlbik7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRva2VuID0gWycnLCAnKicsICcqJ107XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbm9kZXNldFtpXSA9IHRva2VuWzFdICsgdG9rZW5bMl07XG4gICAgICAgIGh0bWxzZXRbaV0gPSBjb21wYXRbdG9rZW5bMV1dKGNvbnRleHQsIHRva2VuWzJdKTtcbiAgICAgICAgZmFjdG9yeVtpXSA9IGNvbXBpbGUob3B0aW1pemVkW2ldLCB0cnVlLCBudWxsKTtcblxuICAgICAgICBmYWN0b3J5W2ldID9cbiAgICAgICAgICBmYWN0b3J5W2ldKGh0bWxzZXRbaV0oKSwgY2FsbGJhY2ssIGNvbnRleHQsIHJlc3VsdHMpIDpcbiAgICAgICAgICByZXN1bHRzLmNvbmNhdChodG1sc2V0W2ldKCkpO1xuICAgICAgfVxuXG4gICAgICBpZiAobCA+IDEpIHtcbiAgICAgICAgcmVzdWx0cy5zb3J0KGRvY3VtZW50T3JkZXIpO1xuICAgICAgICBoYXNEdXBlcyAmJiAocmVzdWx0cyA9IHVuaXF1ZShyZXN1bHRzKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNhbGxiYWNrOiBjYWxsYmFjayxcbiAgICAgICAgY29udGV4dDogY29udGV4dCxcbiAgICAgICAgZmFjdG9yeTogZmFjdG9yeSxcbiAgICAgICAgaHRtbHNldDogaHRtbHNldCxcbiAgICAgICAgbm9kZXNldDogbm9kZXNldCxcbiAgICAgICAgcmVzdWx0czogcmVzdWx0c1xuICAgICAgfTtcblxuICAgIH0sXG5cbiAgLy8gaGFuZGxlcnMgbmVlZGVkIGZvciB0aGUgOmhvdmVyIHBzZXVkby1jbGFzc1xuICAvLyB0cmFjayBzdGF0ZSBjaGFuZ2UgaW4gYnJvd3NlcnMgYW5kIGhlYWRsZXNzXG4gIGluaXRFbnYgPVxuICAgIChmdW5jdGlvbigpIHtcbiAgICAgIGRvYy5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW92ZXInLCBmdW5jdGlvbihlKSB7IFNuYXBzaG90LkhPVkVSID0gZS50YXJnZXQ7IH0sIHRydWUpO1xuICAgICAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlb3V0JywgZnVuY3Rpb24oZSkgeyBTbmFwc2hvdC5IT1ZFUiA9IG51bGw7IH0sIHRydWUpO1xuICAgIH0pKCksXG5cbiAgLy8gUVNBIHBsYWNlaG9sZGVycyB0byBuYXRpdmUgcmVmZXJlbmNlc1xuICBfY2xvc2VzdCwgX21hdGNoZXMsXG4gIF9xdWVyeVNlbGVjdG9yLCBfcXVlcnlTZWxlY3RvckFsbCxcbiAgX3F1ZXJ5U2VsZWN0b3JEb2MsIF9xdWVyeVNlbGVjdG9yQWxsRG9jLFxuXG4gIC8vIG92ZXJyaWRlcyBRU0EgbWV0aG9kcyAob25seSBmb3IgYnJvd3NlcnMpXG4gIGluc3RhbGwgPVxuICAgIGZ1bmN0aW9uKGFsbCkge1xuICAgICAgLy8gc2F2ZSByZWZlcmVuY2VzXG4gICAgICBfY2xvc2VzdCA9IEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3Q7XG4gICAgICBfbWF0Y2hlcyA9IEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXM7XG5cbiAgICAgIF9xdWVyeVNlbGVjdG9yID0gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvcjtcbiAgICAgIF9xdWVyeVNlbGVjdG9yQWxsID0gRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbDtcblxuICAgICAgX3F1ZXJ5U2VsZWN0b3JEb2MgPSBEb2N1bWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvcjtcbiAgICAgIF9xdWVyeVNlbGVjdG9yQWxsRG9jID0gRG9jdW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGw7XG5cbiAgICAgIGZ1bmN0aW9uIHBhcnNlUVNBcmdzKCkge1xuICAgICAgICB2YXIgbWV0aG9kID0gYXJndW1lbnRzW2FyZ3VtZW50cy5sZW5ndGggLSAxXTtcbiAgICAgICAgcmV0dXJuIChcbiAgICAgICAgICBhcmd1bWVudHMubGVuZ3RoIDwgMiA/XG4gICAgICAgICAgICBtZXRob2QuYXBwbHkodGhpcywgWyBdKSA6XG4gICAgICAgICAgYXJndW1lbnRzLmxlbmd0aCA8IDMgP1xuICAgICAgICAgICAgbWV0aG9kLmFwcGx5KHRoaXMsIFsgYXJndW1lbnRzWzBdLCB0aGlzIF0pIDpcbiAgICAgICAgICAgIG1ldGhvZC5hcHBseSh0aGlzLCBbIGFyZ3VtZW50c1swXSwgdGhpcyxcbiAgICAgICAgICAgICAgdHlwZW9mIGFyZ3VtZW50c1sxXSA9PSAnZnVuY3Rpb24nID8gYXJndW1lbnRzWzFdIDogdW5kZWZpbmVkIF0pKTtcbiAgICAgIH1cblxuICAgICAgRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCA9XG4gICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCA9XG4gICAgICAgIGZ1bmN0aW9uIGNsb3Nlc3QoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUVNBcmdzLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5jb25jYXQoYW5jZXN0b3IpKTtcbiAgICAgICAgfTtcblxuICAgICAgRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9XG4gICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUubWF0Y2hlcyA9XG4gICAgICAgIGZ1bmN0aW9uIG1hdGNoZXMoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUVNBcmdzLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5jb25jYXQobWF0Y2gpKTtcbiAgICAgICAgfTtcblxuICAgICAgRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvciA9XG4gICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvciA9XG4gICAgICAgIGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3IoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUVNBcmdzLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5jb25jYXQoZmlyc3QpKTtcbiAgICAgICAgfTtcblxuICAgICAgRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9XG4gICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9XG4gICAgICAgIGZ1bmN0aW9uIHF1ZXJ5U2VsZWN0b3JBbGwoKSB7XG4gICAgICAgICAgcmV0dXJuIHBhcnNlUVNBcmdzLmFwcGx5KHRoaXMsIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzKS5jb25jYXQoc2VsZWN0KSk7XG4gICAgICAgIH07XG5cbiAgICAgIERvY3VtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID1cbiAgICAgIERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IgPVxuICAgICAgICBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yKCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZVFTQXJncy5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuY29uY2F0KGZpcnN0KSk7XG4gICAgICAgIH07XG5cbiAgICAgIERvY3VtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID1cbiAgICAgIERvY3VtZW50RnJhZ21lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3JBbGwgPVxuICAgICAgICBmdW5jdGlvbiBxdWVyeVNlbGVjdG9yQWxsKCkge1xuICAgICAgICAgIHJldHVybiBwYXJzZVFTQXJncy5hcHBseSh0aGlzLCBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cykuY29uY2F0KHNlbGVjdCkpO1xuICAgICAgfTtcblxuICAgICAgaWYgKGFsbCkge1xuICAgICAgICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignbG9hZCcsIGZ1bmN0aW9uKGUpIHtcbiAgICAgICAgICB2YXIgYywgZCwgciwgcywgdCA9IGUudGFyZ2V0O1xuICAgICAgICAgIGlmICgvaWZyYW1lL2kudGVzdCh0LmxvY2FsTmFtZSkpIHtcbiAgICAgICAgICAgIGMgPSAnKCcgKyBFeHBvcnQgKyAnKSh0aGlzLCAnICsgRmFjdG9yeSArICcpOyc7IGQgPSB0Lm93bmVyRG9jdW1lbnQ7XG4gICAgICAgICAgICBzID0gZC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKTsgcy50ZXh0Q29udGVudCA9IGMgKyAnTlcuRG9tLmluc3RhbGwodHJ1ZSknO1xuICAgICAgICAgICAgciA9IGQuZG9jdW1lbnRFbGVtZW50OyByLnJlbW92ZUNoaWxkKHIuaW5zZXJ0QmVmb3JlKHMsIHIuZmlyc3RDaGlsZCkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgICB9XG5cbiAgICB9LFxuXG4gIC8vIHJlc3RvcmUgUVNBIG1ldGhvZHMgKG9ubHkgZm9yIGJyb3dzZXJzKVxuICB1bmluc3RhbGwgPVxuICAgIGZ1bmN0aW9uKCkge1xuICAgICAgLy8gcmVzdG9yZSByZWZlcmVuY2VzXG4gICAgICBpZiAoX2Nsb3Nlc3QpIHtcbiAgICAgICAgRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCA9IF9jbG9zZXN0O1xuICAgICAgICBIVE1MRWxlbWVudC5wcm90b3R5cGUuY2xvc2VzdCA9IF9jbG9zZXN0O1xuICAgICAgfVxuICAgICAgaWYgKF9tYXRjaGVzKSB7XG4gICAgICAgIEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgPSBfbWF0Y2hlcztcbiAgICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLm1hdGNoZXMgPSBfbWF0Y2hlcztcbiAgICAgIH1cbiAgICAgIGlmIChfcXVlcnlTZWxlY3Rvcikge1xuICAgICAgICBFbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID1cbiAgICAgICAgSFRNTEVsZW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IgPSBfcXVlcnlTZWxlY3RvcjtcbiAgICAgICAgRWxlbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9XG4gICAgICAgIEhUTUxFbGVtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID0gX3F1ZXJ5U2VsZWN0b3I7XG4gICAgICB9XG4gICAgICBpZiAoX3F1ZXJ5U2VsZWN0b3JBbGxEb2MpIHtcbiAgICAgICAgRG9jdW1lbnQucHJvdG90eXBlLnF1ZXJ5U2VsZWN0b3IgPVxuICAgICAgICBEb2N1bWVudEZyYWdtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yID0gX3F1ZXJ5U2VsZWN0b3JEb2M7XG4gICAgICAgIERvY3VtZW50LnByb3RvdHlwZS5xdWVyeVNlbGVjdG9yQWxsID1cbiAgICAgICAgRG9jdW1lbnRGcmFnbWVudC5wcm90b3R5cGUucXVlcnlTZWxlY3RvckFsbCA9IF9xdWVyeVNlbGVjdG9yQWxsRG9jO1xuICAgICAgfVxuICAgIH0sXG5cbiAgLy8gZW1wdHkgc2V0XG4gIG5vbmUgPSBBcnJheSgpLFxuXG4gIC8vIGNvbnRleHRcbiAgbGFzdENvbnRleHQsXG5cbiAgLy8gc2VsZWN0b3JcbiAgbGFzdE1hdGNoZWQsXG4gIGxhc3RTZWxlY3RlZCxcblxuICAvLyBjYWNoZWQgbGFtYmRhc1xuICBtYXRjaExhbWJkYXMgPSB7IH0sXG4gIHNlbGVjdExhbWJkYXMgPSB7IH0sXG5cbiAgLy8gY2FjaGVkIHJlc29sdmVyc1xuICBtYXRjaFJlc29sdmVycyA9IHsgfSxcbiAgc2VsZWN0UmVzb2x2ZXJzID0geyB9LFxuXG4gIC8vIHBhc3NlZCB0byByZXNvbHZlcnNcbiAgU25hcHNob3QgPSB7XG5cbiAgICBkb2M6IGRvYyxcbiAgICBmcm9tOiBkb2MsXG4gICAgcm9vdDogcm9vdCxcblxuICAgIGJ5VGFnOiBieVRhZyxcblxuICAgIGZpcnN0OiBmaXJzdCxcbiAgICBtYXRjaDogbWF0Y2gsXG5cbiAgICBhbmNlc3RvcjogYW5jZXN0b3IsXG5cbiAgICBudGhPZlR5cGU6IG50aE9mVHlwZSxcbiAgICBudGhFbGVtZW50OiBudGhFbGVtZW50LFxuXG4gICAgaXNGb2N1c2FibGU6IGlzRm9jdXNhYmxlLFxuICAgIGlzQ29udGVudEVkaXRhYmxlOiBpc0NvbnRlbnRFZGl0YWJsZSxcbiAgICBoYXNBdHRyaWJ1dGVOUzogaGFzQXR0cmlidXRlTlNcbiAgfSxcblxuICAvLyBwdWJsaWMgZXhwb3J0ZWQgbWV0aG9kcy9vYmplY3RzXG4gIERvbSA9IHtcblxuICAgIC8vIGV4cG9ydGVkIGNhY2hlIG9iamVjdHNcblxuICAgIGxhc3RNYXRjaGVkOiBsYXN0TWF0Y2hlZCxcbiAgICBsYXN0U2VsZWN0ZWQ6IGxhc3RTZWxlY3RlZCxcblxuICAgIG1hdGNoTGFtYmRhczogbWF0Y2hMYW1iZGFzLFxuICAgIHNlbGVjdExhbWJkYXM6IHNlbGVjdExhbWJkYXMsXG5cbiAgICBtYXRjaFJlc29sdmVyczogbWF0Y2hSZXNvbHZlcnMsXG4gICAgc2VsZWN0UmVzb2x2ZXJzOiBzZWxlY3RSZXNvbHZlcnMsXG5cbiAgICAvLyBleHBvcnRlZCBjb21waWxlciBtYWNyb3NcblxuICAgIENGRzogQ0ZHLFxuXG4gICAgU19CT0RZOiBTX0JPRFksXG4gICAgTV9CT0RZOiBNX0JPRFksXG4gICAgTl9CT0RZOiBNX0JPRFksXG5cbiAgICBTX1RFU1Q6IFNfVEVTVCxcbiAgICBNX1RFU1Q6IE1fVEVTVCxcbiAgICBOX1RFU1Q6IE5fVEVTVCxcblxuICAgIC8vIGV4cG9ydGVkIGVuZ2luZSBtZXRob2RzXG5cbiAgICBieUlkOiBieUlkLFxuICAgIGJ5VGFnOiBieVRhZyxcbiAgICBieUNsYXNzOiBieUNsYXNzLFxuXG4gICAgbWF0Y2g6IG1hdGNoLFxuICAgIGZpcnN0OiBmaXJzdCxcbiAgICBzZWxlY3Q6IHNlbGVjdCxcbiAgICBjbG9zZXN0OiBhbmNlc3RvcixcblxuICAgIGNvbXBpbGU6IGNvbXBpbGUsXG4gICAgY29uZmlndXJlOiBjb25maWd1cmUsXG5cbiAgICBlbWl0OiBlbWl0LFxuICAgIENvbmZpZzogQ29uZmlnLFxuICAgIFNuYXBzaG90OiBTbmFwc2hvdCxcblxuICAgIFZlcnNpb246IHZlcnNpb24sXG5cbiAgICBpbnN0YWxsOiBpbnN0YWxsLFxuICAgIHVuaW5zdGFsbDogdW5pbnN0YWxsLFxuXG4gICAgT3BlcmF0b3JzOiBPcGVyYXRvcnMsXG4gICAgU2VsZWN0b3JzOiBTZWxlY3RvcnMsXG5cbiAgICAvLyByZWdpc3RlciBhIG5ldyBzZWxlY3RvciBjb21iaW5hdG9yIHN5bWJvbCBhbmQgaXRzIHJlbGF0ZWQgZnVuY3Rpb24gcmVzb2x2ZXJcbiAgICByZWdpc3RlckNvbWJpbmF0b3I6XG4gICAgICBmdW5jdGlvbihjb21iaW5hdG9yLCByZXNvbHZlcikge1xuICAgICAgICB2YXIgaSA9IDAsIGwgPSBjb21iaW5hdG9yLmxlbmd0aCwgc3ltYm9sO1xuICAgICAgICBmb3IgKDsgbCA+IGk7ICsraSkge1xuICAgICAgICAgIGlmIChjb21iaW5hdG9yW2ldICE9ICc9Jykge1xuICAgICAgICAgICAgc3ltYm9sID0gY29tYmluYXRvcltpXTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoQ0ZHLmNvbWJpbmF0b3JzLmluZGV4T2Yoc3ltYm9sKSA8IDApIHtcbiAgICAgICAgICBDRkcuY29tYmluYXRvcnMgPSBDRkcuY29tYmluYXRvcnMucmVwbGFjZSgnXSgnLCBzeW1ib2wgKyAnXSgnKTtcbiAgICAgICAgICBDRkcuY29tYmluYXRvcnMgPSBDRkcuY29tYmluYXRvcnMucmVwbGFjZSgnXSknLCBzeW1ib2wgKyAnXSknKTtcbiAgICAgICAgICBDb21iaW5hdG9yc1tjb21iaW5hdG9yXSA9IHJlc29sdmVyO1xuICAgICAgICAgIHNldElkZW50aWZpZXJTeW50YXgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IHRoZSBcXCcnICsgY29tYmluYXRvciArICdcXCcgY29tYmluYXRvciBpcyBhbHJlYWR5IHJlZ2lzdGVyZWQuJyk7XG4gICAgICAgIH1cbiAgICAgIH0sXG5cbiAgICAvLyByZWdpc3RlciBhIG5ldyBhdHRyaWJ1dGUgb3BlcmF0b3Igc3ltYm9sIGFuZCBpdHMgcmVsYXRlZCBmdW5jdGlvbiByZXNvbHZlclxuICAgIHJlZ2lzdGVyT3BlcmF0b3I6XG4gICAgICBmdW5jdGlvbihvcGVyYXRvciwgcmVzb2x2ZXIpIHtcbiAgICAgICAgdmFyIGkgPSAwLCBsID0gb3BlcmF0b3IubGVuZ3RoLCBzeW1ib2w7XG4gICAgICAgIGZvciAoOyBsID4gaTsgKytpKSB7XG4gICAgICAgICAgaWYgKG9wZXJhdG9yW2ldICE9ICc9Jykge1xuICAgICAgICAgICAgc3ltYm9sID0gb3BlcmF0b3JbaV07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENGRy5vcGVyYXRvcnMuaW5kZXhPZihzeW1ib2wpIDwgMCAmJiAhT3BlcmF0b3JzW29wZXJhdG9yXSkge1xuICAgICAgICAgIENGRy5vcGVyYXRvcnMgPSBDRkcub3BlcmF0b3JzLnJlcGxhY2UoJ109Jywgc3ltYm9sICsgJ109Jyk7XG4gICAgICAgICAgT3BlcmF0b3JzW29wZXJhdG9yXSA9IHJlc29sdmVyO1xuICAgICAgICAgIHNldElkZW50aWZpZXJTeW50YXgoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1dhcm5pbmc6IHRoZSBcXCcnICsgb3BlcmF0b3IgKyAnXFwnIG9wZXJhdG9yIGlzIGFscmVhZHkgcmVnaXN0ZXJlZC4nKTtcbiAgICAgICAgfVxuICAgICAgfSxcblxuICAgIC8vIHJlZ2lzdGVyIGEgbmV3IHNlbGVjdG9yIHN5bWJvbCBhbmQgaXRzIHJlbGF0ZWQgZnVuY3Rpb24gcmVzb2x2ZXJcbiAgICByZWdpc3RlclNlbGVjdG9yOlxuICAgICAgZnVuY3Rpb24obmFtZSwgcmV4cCwgZnVuYykge1xuICAgICAgICBTZWxlY3RvcnNbbmFtZV0gfHwgKFNlbGVjdG9yc1tuYW1lXSA9IHtcbiAgICAgICAgICBFeHByZXNzaW9uOiByZXhwLFxuICAgICAgICAgIENhbGxiYWNrOiBmdW5jXG4gICAgICAgIH0pO1xuICAgICAgfVxuICB9O1xuXG4gIGluaXRpYWxpemUoZG9jKTtcblxuICByZXR1cm4gRG9tO1xufSk7XG4iXSwibmFtZXMiOlsiRXhwb3J0IiwiZ2xvYmFsIiwiZmFjdG9yeSIsIm1vZHVsZSIsImV4cG9ydHMiLCJkZWZpbmUiLCJOVyIsIkRvbSIsIkZhY3RvcnkiLCJ2ZXJzaW9uIiwiZG9jIiwiZG9jdW1lbnQiLCJyb290IiwiZG9jdW1lbnRFbGVtZW50Iiwic2xpY2UiLCJBcnJheSIsInByb3RvdHlwZSIsIkhTUCIsIlZTUCIsIldTUCIsIkNGRyIsIm9wZXJhdG9ycyIsImNvbWJpbmF0b3JzIiwiTk9UIiwiZG91YmxlX2VuYyIsInNpbmdsZV9lbmMiLCJwYXJlbnNfZW5jIiwic3F1YXJlX2VuYyIsIlJFWCIsIkhhc0VzY2FwZXMiLCJSZWdFeHAiLCJIZXhOdW1iZXJzIiwiRXNjT3JRdW90ZSIsIlJlZ0V4cENoYXIiLCJUcmltU3BhY2VzIiwiU3BsaXRHcm91cCIsIkNvbW1hR3JvdXAiLCJGaXhFc2NhcGVzIiwiQ29tYmluZVdTUCIsIlRhYkNoYXJXU1AiLCJQc2V1ZG9zV1NQIiwiU1REIiwiY29tYmluYXRvciIsImFwaW1ldGhvZHMiLCJuYW1lc3BhY2VzIiwiR1JPVVBTIiwibGluZ3Vpc3RpYyIsImxvZ2ljYWxzZWwiLCJ0cmVlc3RydWN0IiwibG9jYXRpb25wYyIsInVzZXJhY3Rpb24iLCJzdHJ1Y3R1cmFsIiwiaW5wdXRzdGF0ZSIsImlucHV0dmFsdWUiLCJyc3JjX3N0YXRlIiwiZGlzcF9zdGF0ZSIsInRpbWVfc3RhdGUiLCJwc2V1ZG9fbm9wIiwicHNldWRvX3NuZyIsInBzZXVkb19kYmwiLCJQYXR0ZXJucyIsImNoaWxkcmVuIiwiYWRqYWNlbnQiLCJyZWxhdGl2ZSIsImFuY2VzdG9yIiwidW5pdmVyc2FsIiwibmFtZXNwYWNlIiwiUlRMIiwicXNOb3RBcmdzIiwicXNJbnZhbGlkIiwicmVOdGhFbGVtIiwicmVOdGhUeXBlIiwicmVPcHRpbWl6ZXIiLCJyZVZhbGlkYXRvciIsIkNvbmZpZyIsIklEU19EVVBFUyIsIkFOT0RFTElTVCIsIkxPR0VSUk9SUyIsIlVTUl9FVkVOVCIsIlZFUkJPU0lUWSIsIk5BTUVTUEFDRSIsIlFVSVJLU19NT0RFIiwiSFRNTF9ET0NVTUVOVCIsIkFUVFJfU1REX09QUyIsIkhUTUxfVEFCTEUiLCJDb21iaW5hdG9ycyIsIlNlbGVjdG9ycyIsIk9wZXJhdG9ycyIsInAxIiwicDIiLCJwMyIsImNvbmNhdENhbGwiLCJub2RlcyIsImNhbGxiYWNrIiwiaSIsImwiLCJsZW5ndGgiLCJsaXN0IiwiY29uY2F0TGlzdCIsInRvTm9kZUxpc3QiLCJ4IiwiZW1wdHlOTCIsImNyZWF0ZURvY3VtZW50RnJhZ21lbnQiLCJjaGlsZE5vZGVzIiwibm9kZUFycmF5IiwiTm9kZUxpc3QiLCJpc0FycmF5IiwiZmFrZU5MIiwiT2JqZWN0IiwiY3JlYXRlIiwidmFsdWUiLCJlbnVtZXJhYmxlIiwiZm9yRWFjaCIsInYiLCJkb2N1bWVudE9yZGVyIiwiYSIsImIiLCJoYXNEdXBlcyIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwidW5pcXVlIiwiaiIsInN3aXRjaENvbnRleHQiLCJjb250ZXh0IiwiZm9yY2UiLCJvbGREb2MiLCJvd25lckRvY3VtZW50IiwiaXNIVE1MIiwiY29tcGF0TW9kZSIsImluZGV4T2YiLCJuYW1lc3BhY2VVUkkiLCJTbmFwc2hvdCIsImZyb20iLCJjb2RlUG9pbnRUb1VURjE2IiwiY29kZVBvaW50IiwibG93SGV4IiwidG9TdHJpbmciLCJzdWJzdHIiLCJzdHJpbmdGcm9tQ29kZVBvaW50IiwiU3RyaW5nIiwiZnJvbUNoYXJDb2RlIiwiZnJvbUNvZGVQb2ludCIsImNvbnZlcnRFc2NhcGVzIiwic3RyIiwidGVzdCIsInJlcGxhY2UiLCJzdWJzdHJpbmciLCJwYXJzZUludCIsInVuZXNjYXBlSWRlbnRpZmllciIsIm1ldGhvZCIsImNvbXBhdCIsImMiLCJuIiwiZSIsImYiLCJieUlkIiwiYnlUYWciLCJieVRhZ05TIiwiYnlDbGFzcyIsImJ5SWRSYXciLCJpZCIsIm5vZGUiLCJuZXh0IiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJuZXh0RWxlbWVudFNpYmxpbmciLCJwYXJlbnRFbGVtZW50IiwiYXBpIiwibm9uZSIsImFsbCIsIm5vZGVUeXBlIiwiZ2V0QXR0cmlidXRlIiwidGFnIiwiY2FsbCIsInRvTG93ZXJDYXNlIiwibG9jYWxOYW1lIiwiY2xzIiwicmVDbHMiLCJjbGFzc05hbWUiLCJoYXNBdHRyaWJ1dGVOUyIsIm5hbWUiLCJhdHRyIiwiZ2V0QXR0cmlidXRlTmFtZXMiLCJudGhFbGVtZW50IiwiaWR4IiwibGVuIiwic2V0IiwicGFyZW50IiwidW5kZWZpbmVkIiwicGFyZW50cyIsImVsZW1lbnQiLCJkaXIiLCJrIiwibnRoT2ZUeXBlIiwiY29udGVudFR5cGUiLCJjcmVhdGVFbGVtZW50IiwiaXNGb2N1c2FibGUiLCJjb250ZW50RG9jdW1lbnQiLCJoYXNGb2N1cyIsImFjdGl2ZUVsZW1lbnQiLCJ0eXBlIiwiaHJlZiIsInRhYkluZGV4IiwiaXNDb250ZW50RWRpdGFibGUiLCJhdHRyVmFsdWUiLCJoYXNBdHRyaWJ1dGUiLCJwYXJlbnROb2RlIiwiaXNQbGF5aW5nIiwibWVkaWEiLCJIVE1MTWVkaWFFbGVtZW50IiwiY3VycmVudFRpbWUiLCJwYXVzZWQiLCJlbmRlZCIsInJlYWR5U3RhdGUiLCJjb25maWd1cmUiLCJvcHRpb24iLCJjbGVhciIsIm1hdGNoUmVzb2x2ZXJzIiwic2VsZWN0UmVzb2x2ZXJzIiwic2V0SWRlbnRpZmllclN5bnRheCIsImVtaXQiLCJtZXNzYWdlIiwicHJvdG8iLCJlcnIiLCJET01FeGNlcHRpb24iLCJjb25zb2xlIiwibG9nIiwiaW5pdGlhbGl6ZSIsImxhc3RDb250ZXh0Iiwibm9hc2NpaSIsImVzY2FwZWQiLCJ1bmljb2RlIiwiaWRlbnRpZmllciIsInBzZXVkb25hbWVzIiwicHNldWRvcGFybXMiLCJkb3VibGVxdW90ZSIsInNpbmdsZXF1b3RlIiwiYXR0cnBhcnNlciIsImF0dHJ2YWx1ZXMiLCJhdHRyaWJ1dGVzIiwiYXR0cm1hdGNoZXIiLCJwc2V1ZG9jbGFzcyIsInN0YW5kYXJkVmFsaWRhdG9yIiwidGFnTmFtZSIsImF0dHJpYnV0ZSIsIkZfSU5JVCIsIlNfSEVBRCIsIk1fSEVBRCIsIk5fSEVBRCIsIlNfTE9PUCIsIk1fTE9PUCIsIk5fTE9PUCIsIlNfQk9EWSIsIk1fQk9EWSIsIk5fQk9EWSIsIlNfVEFJTCIsIk1fVEFJTCIsIk5fVEFJTCIsIlNfVEVTVCIsIk1fVEVTVCIsIk5fVEVTVCIsIlNfVkFSUyIsIk1fVkFSUyIsIk5fVkFSUyIsImNvbXBpbGUiLCJzZWxlY3RvciIsIm1vZGUiLCJ0b2tlbiIsImhlYWQiLCJsb29wIiwibWFjcm8iLCJzb3VyY2UiLCJ2YXJzIiwic2VsZWN0TGFtYmRhcyIsIm1hdGNoTGFtYmRhcyIsImNvbXBpbGVTZWxlY3RvciIsImluY2x1ZGVzIiwiam9pbiIsIkZ1bmN0aW9uIiwiZXhwcmVzc2lvbiIsIk5TIiwicmVmZXJlbmNlRWxlbWVudCIsImV4cHIiLCJtYXRjaCIsInJlc3VsdCIsInN0YXR1cyIsInN5bWJvbCIsInNlbGVjdG9yX3N0cmluZyIsImxhc3RTZWxlY3RlZCIsImxhc3RNYXRjaGVkIiwic2VsZWN0b3JfcmVjdXJzaW9uX2xhYmVsIiwicHJlZml4Iiwic3BsaXQiLCJNYXRoIiwiYWJzIiwiRXhwcmVzc2lvbiIsIkNhbGxiYWNrIiwibW9kdmFyIiwicG9wIiwibWFrZXJlZiIsInNlbGVjdG9ycyIsImVzY2FwZSIsImNsYXNzTGlzdCIsIl9jbG9zZXN0IiwicGFyc2UiLCJtYXRjaF9hc3NlcnQiLCJyIiwibWF0Y2hfY29sbGVjdCIsInBhcnNlZCIsImFyZ3VtZW50cyIsIlR5cGVFcnJvciIsIl9tYXRjaGVzIiwiZmlyc3QiLCJfcXVlcnlTZWxlY3RvciIsInNlbGVjdCIsImZpcnN0TWF0Y2giLCJfcXVlcnlTZWxlY3RvckFsbCIsInJlc29sdmVyIiwiaCIsImh0bWxzZXQiLCJub2Rlc2V0IiwiY29uY2F0Iiwic29ydCIsImNvbGxlY3QiLCJyZXN1bHRzIiwib3B0aW1pemUiLCJpbmRleCIsImNoYXJBdCIsInNlZW4iLCJvcHRpbWl6ZWQiLCJpbml0RW52IiwiYWRkRXZlbnRMaXN0ZW5lciIsIkhPVkVSIiwidGFyZ2V0IiwiX3F1ZXJ5U2VsZWN0b3JEb2MiLCJfcXVlcnlTZWxlY3RvckFsbERvYyIsImluc3RhbGwiLCJFbGVtZW50IiwiY2xvc2VzdCIsIm1hdGNoZXMiLCJxdWVyeVNlbGVjdG9yIiwicXVlcnlTZWxlY3RvckFsbCIsIkRvY3VtZW50IiwicGFyc2VRU0FyZ3MiLCJhcHBseSIsIkhUTUxFbGVtZW50IiwiRG9jdW1lbnRGcmFnbWVudCIsImQiLCJzIiwidCIsInRleHRDb250ZW50IiwicmVtb3ZlQ2hpbGQiLCJpbnNlcnRCZWZvcmUiLCJmaXJzdENoaWxkIiwidW5pbnN0YWxsIiwiVmVyc2lvbiIsInJlZ2lzdGVyQ29tYmluYXRvciIsIndhcm4iLCJyZWdpc3Rlck9wZXJhdG9yIiwib3BlcmF0b3IiLCJyZWdpc3RlclNlbGVjdG9yIiwicmV4cCIsImZ1bmMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/nwsapi/src/nwsapi.js\n");

/***/ })

};
;