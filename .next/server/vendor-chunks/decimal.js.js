/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/decimal.js";
exports.ids = ["vendor-chunks/decimal.js"];
exports.modules = {

/***/ "(ssr)/./node_modules/decimal.js/decimal.js":
/*!********************************************!*\
  !*** ./node_modules/decimal.js/decimal.js ***!
  \********************************************/
/***/ (function(module, exports, __webpack_require__) {

eval("var __WEBPACK_AMD_DEFINE_RESULT__;;\n(function(globalScope) {\n    \"use strict\";\n    /*!\r\n   *  decimal.js v10.6.0\r\n   *  An arbitrary-precision Decimal type for JavaScript.\r\n   *  https://github.com/MikeMcl/decimal.js\r\n   *  Copyright (c) 2025 Michael Mclaughlin <M8ch88l@gmail.com>\r\n   *  MIT Licence\r\n   */ // -----------------------------------  EDITABLE DEFAULTS  ------------------------------------ //\n    // The maximum exponent magnitude.\n    // The limit on the value of `toExpNeg`, `toExpPos`, `minE` and `maxE`.\n    var EXP_LIMIT = 9e15, // The limit on the value of `precision`, and on the value of the first argument to\n    // `toDecimalPlaces`, `toExponential`, `toFixed`, `toPrecision` and `toSignificantDigits`.\n    MAX_DIGITS = 1e9, // Base conversion alphabet.\n    NUMERALS = \"0123456789abcdef\", // The natural logarithm of 10 (1025 digits).\n    LN10 = \"2.3025850929940456840179914546843642076011014886287729760333279009675726096773524802359972050895982983419677840422862486334095254650828067566662873690987816894829072083255546808437998948262331985283935053089653777326288461633662222876982198867465436674744042432743651550489343149393914796194044002221051017141748003688084012647080685567743216228355220114804663715659121373450747856947683463616792101806445070648000277502684916746550586856935673420670581136429224554405758925724208241314695689016758940256776311356919292033376587141660230105703089634572075440370847469940168269282808481184289314848524948644871927809676271275775397027668605952496716674183485704422507197965004714951050492214776567636938662976979522110718264549734772662425709429322582798502585509785265383207606726317164309505995087807523710333101197857547331541421808427543863591778117054309827482385045648019095610299291824318237525357709750539565187697510374970888692180205189339507238539205144634197265287286965110862571492198849978748873771345686209167058\", // Pi (1025 digits).\n    PI = \"3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632789\", // The initial configuration properties of the Decimal constructor.\n    DEFAULTS = {\n        // These values must be integers within the stated ranges (inclusive).\n        // Most of these values can be changed at run-time using the `Decimal.config` method.\n        // The maximum number of significant digits of the result of a calculation or base conversion.\n        // E.g. `Decimal.config({ precision: 20 });`\n        precision: 20,\n        // The rounding mode used when rounding to `precision`.\n        //\n        // ROUND_UP         0 Away from zero.\n        // ROUND_DOWN       1 Towards zero.\n        // ROUND_CEIL       2 Towards +Infinity.\n        // ROUND_FLOOR      3 Towards -Infinity.\n        // ROUND_HALF_UP    4 Towards nearest neighbour. If equidistant, up.\n        // ROUND_HALF_DOWN  5 Towards nearest neighbour. If equidistant, down.\n        // ROUND_HALF_EVEN  6 Towards nearest neighbour. If equidistant, towards even neighbour.\n        // ROUND_HALF_CEIL  7 Towards nearest neighbour. If equidistant, towards +Infinity.\n        // ROUND_HALF_FLOOR 8 Towards nearest neighbour. If equidistant, towards -Infinity.\n        //\n        // E.g.\n        // `Decimal.rounding = 4;`\n        // `Decimal.rounding = Decimal.ROUND_HALF_UP;`\n        rounding: 4,\n        // The modulo mode used when calculating the modulus: a mod n.\n        // The quotient (q = a / n) is calculated according to the corresponding rounding mode.\n        // The remainder (r) is calculated as: r = a - n * q.\n        //\n        // UP         0 The remainder is positive if the dividend is negative, else is negative.\n        // DOWN       1 The remainder has the same sign as the dividend (JavaScript %).\n        // FLOOR      3 The remainder has the same sign as the divisor (Python %).\n        // HALF_EVEN  6 The IEEE 754 remainder function.\n        // EUCLID     9 Euclidian division. q = sign(n) * floor(a / abs(n)). Always positive.\n        //\n        // Truncated division (1), floored division (3), the IEEE 754 remainder (6), and Euclidian\n        // division (9) are commonly used for the modulus operation. The other rounding modes can also\n        // be used, but they may not give useful results.\n        modulo: 1,\n        // The exponent value at and beneath which `toString` returns exponential notation.\n        // JavaScript numbers: -7\n        toExpNeg: -7,\n        // The exponent value at and above which `toString` returns exponential notation.\n        // JavaScript numbers: 21\n        toExpPos: 21,\n        // The minimum exponent value, beneath which underflow to zero occurs.\n        // JavaScript numbers: -324  (5e-324)\n        minE: -EXP_LIMIT,\n        // The maximum exponent value, above which overflow to Infinity occurs.\n        // JavaScript numbers: 308  (1.7976931348623157e+308)\n        maxE: EXP_LIMIT,\n        // Whether to use cryptographically-secure random number generation, if available.\n        crypto: false // true/false\n    }, // ----------------------------------- END OF EDITABLE DEFAULTS ------------------------------- //\n    Decimal, inexact, noConflict, quadrant, external = true, decimalError = \"[DecimalError] \", invalidArgument = decimalError + \"Invalid argument: \", precisionLimitExceeded = decimalError + \"Precision limit exceeded\", cryptoUnavailable = decimalError + \"crypto unavailable\", tag = \"[object Decimal]\", mathfloor = Math.floor, mathpow = Math.pow, isBinary = /^0b([01]+(\\.[01]*)?|\\.[01]+)(p[+-]?\\d+)?$/i, isHex = /^0x([0-9a-f]+(\\.[0-9a-f]*)?|\\.[0-9a-f]+)(p[+-]?\\d+)?$/i, isOctal = /^0o([0-7]+(\\.[0-7]*)?|\\.[0-7]+)(p[+-]?\\d+)?$/i, isDecimal = /^(\\d+(\\.\\d*)?|\\.\\d+)(e[+-]?\\d+)?$/i, BASE = 1e7, LOG_BASE = 7, MAX_SAFE_INTEGER = 9007199254740991, LN10_PRECISION = LN10.length - 1, PI_PRECISION = PI.length - 1, // Decimal.prototype object\n    P = {\n        toStringTag: tag\n    };\n    // Decimal prototype methods\n    /*\r\n   *  absoluteValue             abs\r\n   *  ceil\r\n   *  clampedTo                 clamp\r\n   *  comparedTo                cmp\r\n   *  cosine                    cos\r\n   *  cubeRoot                  cbrt\r\n   *  decimalPlaces             dp\r\n   *  dividedBy                 div\r\n   *  dividedToIntegerBy        divToInt\r\n   *  equals                    eq\r\n   *  floor\r\n   *  greaterThan               gt\r\n   *  greaterThanOrEqualTo      gte\r\n   *  hyperbolicCosine          cosh\r\n   *  hyperbolicSine            sinh\r\n   *  hyperbolicTangent         tanh\r\n   *  inverseCosine             acos\r\n   *  inverseHyperbolicCosine   acosh\r\n   *  inverseHyperbolicSine     asinh\r\n   *  inverseHyperbolicTangent  atanh\r\n   *  inverseSine               asin\r\n   *  inverseTangent            atan\r\n   *  isFinite\r\n   *  isInteger                 isInt\r\n   *  isNaN\r\n   *  isNegative                isNeg\r\n   *  isPositive                isPos\r\n   *  isZero\r\n   *  lessThan                  lt\r\n   *  lessThanOrEqualTo         lte\r\n   *  logarithm                 log\r\n   *  [maximum]                 [max]\r\n   *  [minimum]                 [min]\r\n   *  minus                     sub\r\n   *  modulo                    mod\r\n   *  naturalExponential        exp\r\n   *  naturalLogarithm          ln\r\n   *  negated                   neg\r\n   *  plus                      add\r\n   *  precision                 sd\r\n   *  round\r\n   *  sine                      sin\r\n   *  squareRoot                sqrt\r\n   *  tangent                   tan\r\n   *  times                     mul\r\n   *  toBinary\r\n   *  toDecimalPlaces           toDP\r\n   *  toExponential\r\n   *  toFixed\r\n   *  toFraction\r\n   *  toHexadecimal             toHex\r\n   *  toNearest\r\n   *  toNumber\r\n   *  toOctal\r\n   *  toPower                   pow\r\n   *  toPrecision\r\n   *  toSignificantDigits       toSD\r\n   *  toString\r\n   *  truncated                 trunc\r\n   *  valueOf                   toJSON\r\n   */ /*\r\n   * Return a new Decimal whose value is the absolute value of this Decimal.\r\n   *\r\n   */ P.absoluteValue = P.abs = function() {\n        var x = new this.constructor(this);\n        if (x.s < 0) x.s = 1;\n        return finalise(x);\n    };\n    /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of positive Infinity.\r\n   *\r\n   */ P.ceil = function() {\n        return finalise(new this.constructor(this), this.e + 1, 2);\n    };\n    /*\r\n   * Return a new Decimal whose value is the value of this Decimal clamped to the range\r\n   * delineated by `min` and `max`.\r\n   *\r\n   * min {number|string|bigint|Decimal}\r\n   * max {number|string|bigint|Decimal}\r\n   *\r\n   */ P.clampedTo = P.clamp = function(min, max) {\n        var k, x = this, Ctor = x.constructor;\n        min = new Ctor(min);\n        max = new Ctor(max);\n        if (!min.s || !max.s) return new Ctor(NaN);\n        if (min.gt(max)) throw Error(invalidArgument + max);\n        k = x.cmp(min);\n        return k < 0 ? min : x.cmp(max) > 0 ? max : new Ctor(x);\n    };\n    /*\r\n   * Return\r\n   *   1    if the value of this Decimal is greater than the value of `y`,\r\n   *  -1    if the value of this Decimal is less than the value of `y`,\r\n   *   0    if they have the same value,\r\n   *   NaN  if the value of either Decimal is NaN.\r\n   *\r\n   */ P.comparedTo = P.cmp = function(y) {\n        var i, j, xdL, ydL, x = this, xd = x.d, yd = (y = new x.constructor(y)).d, xs = x.s, ys = y.s;\n        // Either NaN or ±Infinity?\n        if (!xd || !yd) {\n            return !xs || !ys ? NaN : xs !== ys ? xs : xd === yd ? 0 : !xd ^ xs < 0 ? 1 : -1;\n        }\n        // Either zero?\n        if (!xd[0] || !yd[0]) return xd[0] ? xs : yd[0] ? -ys : 0;\n        // Signs differ?\n        if (xs !== ys) return xs;\n        // Compare exponents.\n        if (x.e !== y.e) return x.e > y.e ^ xs < 0 ? 1 : -1;\n        xdL = xd.length;\n        ydL = yd.length;\n        // Compare digit by digit.\n        for(i = 0, j = xdL < ydL ? xdL : ydL; i < j; ++i){\n            if (xd[i] !== yd[i]) return xd[i] > yd[i] ^ xs < 0 ? 1 : -1;\n        }\n        // Compare lengths.\n        return xdL === ydL ? 0 : xdL > ydL ^ xs < 0 ? 1 : -1;\n    };\n    /*\r\n   * Return a new Decimal whose value is the cosine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * cos(0)         = 1\r\n   * cos(-0)        = 1\r\n   * cos(Infinity)  = NaN\r\n   * cos(-Infinity) = NaN\r\n   * cos(NaN)       = NaN\r\n   *\r\n   */ P.cosine = P.cos = function() {\n        var pr, rm, x = this, Ctor = x.constructor;\n        if (!x.d) return new Ctor(NaN);\n        // cos(0) = cos(-0) = 1\n        if (!x.d[0]) return new Ctor(1);\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n        Ctor.rounding = 1;\n        x = cosine(Ctor, toLessThanHalfPi(Ctor, x));\n        Ctor.precision = pr;\n        Ctor.rounding = rm;\n        return finalise(quadrant == 2 || quadrant == 3 ? x.neg() : x, pr, rm, true);\n    };\n    /*\r\n   *\r\n   * Return a new Decimal whose value is the cube root of the value of this Decimal, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   *  cbrt(0)  =  0\r\n   *  cbrt(-0) = -0\r\n   *  cbrt(1)  =  1\r\n   *  cbrt(-1) = -1\r\n   *  cbrt(N)  =  N\r\n   *  cbrt(-I) = -I\r\n   *  cbrt(I)  =  I\r\n   *\r\n   * Math.cbrt(x) = (x < 0 ? -Math.pow(-x, 1/3) : Math.pow(x, 1/3))\r\n   *\r\n   */ P.cubeRoot = P.cbrt = function() {\n        var e, m, n, r, rep, s, sd, t, t3, t3plusx, x = this, Ctor = x.constructor;\n        if (!x.isFinite() || x.isZero()) return new Ctor(x);\n        external = false;\n        // Initial estimate.\n        s = x.s * mathpow(x.s * x, 1 / 3);\n        // Math.cbrt underflow/overflow?\n        // Pass x to Math.pow as integer, then adjust the exponent of the result.\n        if (!s || Math.abs(s) == 1 / 0) {\n            n = digitsToString(x.d);\n            e = x.e;\n            // Adjust n exponent so it is a multiple of 3 away from x exponent.\n            if (s = (e - n.length + 1) % 3) n += s == 1 || s == -2 ? \"0\" : \"00\";\n            s = mathpow(n, 1 / 3);\n            // Rarely, e may be one less than the result exponent value.\n            e = mathfloor((e + 1) / 3) - (e % 3 == (e < 0 ? -1 : 2));\n            if (s == 1 / 0) {\n                n = \"5e\" + e;\n            } else {\n                n = s.toExponential();\n                n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n            }\n            r = new Ctor(n);\n            r.s = x.s;\n        } else {\n            r = new Ctor(s.toString());\n        }\n        sd = (e = Ctor.precision) + 3;\n        // Halley's method.\n        // TODO? Compare Newton's method.\n        for(;;){\n            t = r;\n            t3 = t.times(t).times(t);\n            t3plusx = t3.plus(x);\n            r = divide(t3plusx.plus(x).times(t), t3plusx.plus(t3), sd + 2, 1);\n            // TODO? Replace with for-loop and checkRoundingDigits.\n            if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n                n = n.slice(sd - 3, sd + 1);\n                // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or 4999\n                // , i.e. approaching a rounding boundary, continue the iteration.\n                if (n == \"9999\" || !rep && n == \"4999\") {\n                    // On the first iteration only, check to see if rounding up gives the exact result as the\n                    // nines may infinitely repeat.\n                    if (!rep) {\n                        finalise(t, e + 1, 0);\n                        if (t.times(t).times(t).eq(x)) {\n                            r = t;\n                            break;\n                        }\n                    }\n                    sd += 4;\n                    rep = 1;\n                } else {\n                    // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\n                    // If not, then there are further digits and m will be truthy.\n                    if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                        // Truncate to the first rounding digit.\n                        finalise(r, e + 1, 1);\n                        m = !r.times(r).times(r).eq(x);\n                    }\n                    break;\n                }\n            }\n        }\n        external = true;\n        return finalise(r, e, Ctor.rounding, m);\n    };\n    /*\r\n   * Return the number of decimal places of the value of this Decimal.\r\n   *\r\n   */ P.decimalPlaces = P.dp = function() {\n        var w, d = this.d, n = NaN;\n        if (d) {\n            w = d.length - 1;\n            n = (w - mathfloor(this.e / LOG_BASE)) * LOG_BASE;\n            // Subtract the number of trailing zeros of the last word.\n            w = d[w];\n            if (w) for(; w % 10 == 0; w /= 10)n--;\n            if (n < 0) n = 0;\n        }\n        return n;\n    };\n    /*\r\n   *  n / 0 = I\r\n   *  n / N = N\r\n   *  n / I = 0\r\n   *  0 / n = 0\r\n   *  0 / 0 = N\r\n   *  0 / N = N\r\n   *  0 / I = 0\r\n   *  N / n = N\r\n   *  N / 0 = N\r\n   *  N / N = N\r\n   *  N / I = N\r\n   *  I / n = I\r\n   *  I / 0 = I\r\n   *  I / N = N\r\n   *  I / I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal divided by `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */ P.dividedBy = P.div = function(y) {\n        return divide(this, new this.constructor(y));\n    };\n    /*\r\n   * Return a new Decimal whose value is the integer part of dividing the value of this Decimal\r\n   * by the value of `y`, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */ P.dividedToIntegerBy = P.divToInt = function(y) {\n        var x = this, Ctor = x.constructor;\n        return finalise(divide(x, new Ctor(y), 0, 1, 1), Ctor.precision, Ctor.rounding);\n    };\n    /*\r\n   * Return true if the value of this Decimal is equal to the value of `y`, otherwise return false.\r\n   *\r\n   */ P.equals = P.eq = function(y) {\n        return this.cmp(y) === 0;\n    };\n    /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number in the\r\n   * direction of negative Infinity.\r\n   *\r\n   */ P.floor = function() {\n        return finalise(new this.constructor(this), this.e + 1, 3);\n    };\n    /*\r\n   * Return true if the value of this Decimal is greater than the value of `y`, otherwise return\r\n   * false.\r\n   *\r\n   */ P.greaterThan = P.gt = function(y) {\n        return this.cmp(y) > 0;\n    };\n    /*\r\n   * Return true if the value of this Decimal is greater than or equal to the value of `y`,\r\n   * otherwise return false.\r\n   *\r\n   */ P.greaterThanOrEqualTo = P.gte = function(y) {\n        var k = this.cmp(y);\n        return k == 1 || k === 0;\n    };\n    /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [1, Infinity]\r\n   *\r\n   * cosh(x) = 1 + x^2/2! + x^4/4! + x^6/6! + ...\r\n   *\r\n   * cosh(0)         = 1\r\n   * cosh(-0)        = 1\r\n   * cosh(Infinity)  = Infinity\r\n   * cosh(-Infinity) = Infinity\r\n   * cosh(NaN)       = NaN\r\n   *\r\n   *  x        time taken (ms)   result\r\n   * 1000      9                 9.8503555700852349694e+433\r\n   * 10000     25                4.4034091128314607936e+4342\r\n   * 100000    171               1.4033316802130615897e+43429\r\n   * 1000000   3817              1.5166076984010437725e+434294\r\n   * 10000000  abandoned after 2 minute wait\r\n   *\r\n   * TODO? Compare performance of cosh(x) = 0.5 * (exp(x) + exp(-x))\r\n   *\r\n   */ P.hyperbolicCosine = P.cosh = function() {\n        var k, n, pr, rm, len, x = this, Ctor = x.constructor, one = new Ctor(1);\n        if (!x.isFinite()) return new Ctor(x.s ? 1 / 0 : NaN);\n        if (x.isZero()) return one;\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n        Ctor.rounding = 1;\n        len = x.d.length;\n        // Argument reduction: cos(4x) = 1 - 8cos^2(x) + 8cos^4(x) + 1\n        // i.e. cos(x) = 1 - cos^2(x/4)(8 - 8cos^2(x/4))\n        // Estimate the optimum number of times to use the argument reduction.\n        // TODO? Estimation reused from cosine() and may not be optimal here.\n        if (len < 32) {\n            k = Math.ceil(len / 3);\n            n = (1 / tinyPow(4, k)).toString();\n        } else {\n            k = 16;\n            n = \"2.3283064365386962890625e-10\";\n        }\n        x = taylorSeries(Ctor, 1, x.times(n), new Ctor(1), true);\n        // Reverse argument reduction\n        var cosh2_x, i = k, d8 = new Ctor(8);\n        for(; i--;){\n            cosh2_x = x.times(x);\n            x = one.minus(cosh2_x.times(d8.minus(cosh2_x.times(d8))));\n        }\n        return finalise(x, Ctor.precision = pr, Ctor.rounding = rm, true);\n    };\n    /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * sinh(x) = x + x^3/3! + x^5/5! + x^7/7! + ...\r\n   *\r\n   * sinh(0)         = 0\r\n   * sinh(-0)        = -0\r\n   * sinh(Infinity)  = Infinity\r\n   * sinh(-Infinity) = -Infinity\r\n   * sinh(NaN)       = NaN\r\n   *\r\n   * x        time taken (ms)\r\n   * 10       2 ms\r\n   * 100      5 ms\r\n   * 1000     14 ms\r\n   * 10000    82 ms\r\n   * 100000   886 ms            1.4033316802130615897e+43429\r\n   * 200000   2613 ms\r\n   * 300000   5407 ms\r\n   * 400000   8824 ms\r\n   * 500000   13026 ms          8.7080643612718084129e+217146\r\n   * 1000000  48543 ms\r\n   *\r\n   * TODO? Compare performance of sinh(x) = 0.5 * (exp(x) - exp(-x))\r\n   *\r\n   */ P.hyperbolicSine = P.sinh = function() {\n        var k, pr, rm, len, x = this, Ctor = x.constructor;\n        if (!x.isFinite() || x.isZero()) return new Ctor(x);\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        Ctor.precision = pr + Math.max(x.e, x.sd()) + 4;\n        Ctor.rounding = 1;\n        len = x.d.length;\n        if (len < 3) {\n            x = taylorSeries(Ctor, 2, x, x, true);\n        } else {\n            // Alternative argument reduction: sinh(3x) = sinh(x)(3 + 4sinh^2(x))\n            // i.e. sinh(x) = sinh(x/3)(3 + 4sinh^2(x/3))\n            // 3 multiplications and 1 addition\n            // Argument reduction: sinh(5x) = sinh(x)(5 + sinh^2(x)(20 + 16sinh^2(x)))\n            // i.e. sinh(x) = sinh(x/5)(5 + sinh^2(x/5)(20 + 16sinh^2(x/5)))\n            // 4 multiplications and 2 additions\n            // Estimate the optimum number of times to use the argument reduction.\n            k = 1.4 * Math.sqrt(len);\n            k = k > 16 ? 16 : k | 0;\n            x = x.times(1 / tinyPow(5, k));\n            x = taylorSeries(Ctor, 2, x, x, true);\n            // Reverse argument reduction\n            var sinh2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n            for(; k--;){\n                sinh2_x = x.times(x);\n                x = x.times(d5.plus(sinh2_x.times(d16.times(sinh2_x).plus(d20))));\n            }\n        }\n        Ctor.precision = pr;\n        Ctor.rounding = rm;\n        return finalise(x, pr, rm, true);\n    };\n    /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of the value in radians of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * tanh(x) = sinh(x) / cosh(x)\r\n   *\r\n   * tanh(0)         = 0\r\n   * tanh(-0)        = -0\r\n   * tanh(Infinity)  = 1\r\n   * tanh(-Infinity) = -1\r\n   * tanh(NaN)       = NaN\r\n   *\r\n   */ P.hyperbolicTangent = P.tanh = function() {\n        var pr, rm, x = this, Ctor = x.constructor;\n        if (!x.isFinite()) return new Ctor(x.s);\n        if (x.isZero()) return new Ctor(x);\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        Ctor.precision = pr + 7;\n        Ctor.rounding = 1;\n        return divide(x.sinh(), x.cosh(), Ctor.precision = pr, Ctor.rounding = rm);\n    };\n    /*\r\n   * Return a new Decimal whose value is the arccosine (inverse cosine) in radians of the value of\r\n   * this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [0, pi]\r\n   *\r\n   * acos(x) = pi/2 - asin(x)\r\n   *\r\n   * acos(0)       = pi/2\r\n   * acos(-0)      = pi/2\r\n   * acos(1)       = 0\r\n   * acos(-1)      = pi\r\n   * acos(1/2)     = pi/3\r\n   * acos(-1/2)    = 2*pi/3\r\n   * acos(|x| > 1) = NaN\r\n   * acos(NaN)     = NaN\r\n   *\r\n   */ P.inverseCosine = P.acos = function() {\n        var x = this, Ctor = x.constructor, k = x.abs().cmp(1), pr = Ctor.precision, rm = Ctor.rounding;\n        if (k !== -1) {\n            return k === 0 ? x.isNeg() ? getPi(Ctor, pr, rm) : new Ctor(0) : new Ctor(NaN);\n        }\n        if (x.isZero()) return getPi(Ctor, pr + 4, rm).times(0.5);\n        // TODO? Special case acos(0.5) = pi/3 and acos(-0.5) = 2*pi/3\n        Ctor.precision = pr + 6;\n        Ctor.rounding = 1;\n        // See https://github.com/MikeMcl/decimal.js/pull/217\n        x = new Ctor(1).minus(x).div(x.plus(1)).sqrt().atan();\n        Ctor.precision = pr;\n        Ctor.rounding = rm;\n        return x.times(2);\n    };\n    /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [1, Infinity]\r\n   * Range: [0, Infinity]\r\n   *\r\n   * acosh(x) = ln(x + sqrt(x^2 - 1))\r\n   *\r\n   * acosh(x < 1)     = NaN\r\n   * acosh(NaN)       = NaN\r\n   * acosh(Infinity)  = Infinity\r\n   * acosh(-Infinity) = NaN\r\n   * acosh(0)         = NaN\r\n   * acosh(-0)        = NaN\r\n   * acosh(1)         = 0\r\n   * acosh(-1)        = NaN\r\n   *\r\n   */ P.inverseHyperbolicCosine = P.acosh = function() {\n        var pr, rm, x = this, Ctor = x.constructor;\n        if (x.lte(1)) return new Ctor(x.eq(1) ? 0 : NaN);\n        if (!x.isFinite()) return new Ctor(x);\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        Ctor.precision = pr + Math.max(Math.abs(x.e), x.sd()) + 4;\n        Ctor.rounding = 1;\n        external = false;\n        x = x.times(x).minus(1).sqrt().plus(x);\n        external = true;\n        Ctor.precision = pr;\n        Ctor.rounding = rm;\n        return x.ln();\n    };\n    /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * asinh(x) = ln(x + sqrt(x^2 + 1))\r\n   *\r\n   * asinh(NaN)       = NaN\r\n   * asinh(Infinity)  = Infinity\r\n   * asinh(-Infinity) = -Infinity\r\n   * asinh(0)         = 0\r\n   * asinh(-0)        = -0\r\n   *\r\n   */ P.inverseHyperbolicSine = P.asinh = function() {\n        var pr, rm, x = this, Ctor = x.constructor;\n        if (!x.isFinite() || x.isZero()) return new Ctor(x);\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        Ctor.precision = pr + 2 * Math.max(Math.abs(x.e), x.sd()) + 6;\n        Ctor.rounding = 1;\n        external = false;\n        x = x.times(x).plus(1).sqrt().plus(x);\n        external = true;\n        Ctor.precision = pr;\n        Ctor.rounding = rm;\n        return x.ln();\n    };\n    /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent in radians of the\r\n   * value of this Decimal.\r\n   *\r\n   * Domain: [-1, 1]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * atanh(x) = 0.5 * ln((1 + x) / (1 - x))\r\n   *\r\n   * atanh(|x| > 1)   = NaN\r\n   * atanh(NaN)       = NaN\r\n   * atanh(Infinity)  = NaN\r\n   * atanh(-Infinity) = NaN\r\n   * atanh(0)         = 0\r\n   * atanh(-0)        = -0\r\n   * atanh(1)         = Infinity\r\n   * atanh(-1)        = -Infinity\r\n   *\r\n   */ P.inverseHyperbolicTangent = P.atanh = function() {\n        var pr, rm, wpr, xsd, x = this, Ctor = x.constructor;\n        if (!x.isFinite()) return new Ctor(NaN);\n        if (x.e >= 0) return new Ctor(x.abs().eq(1) ? x.s / 0 : x.isZero() ? x : NaN);\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        xsd = x.sd();\n        if (Math.max(xsd, pr) < 2 * -x.e - 1) return finalise(new Ctor(x), pr, rm, true);\n        Ctor.precision = wpr = xsd - x.e;\n        x = divide(x.plus(1), new Ctor(1).minus(x), wpr + pr, 1);\n        Ctor.precision = pr + 4;\n        Ctor.rounding = 1;\n        x = x.ln();\n        Ctor.precision = pr;\n        Ctor.rounding = rm;\n        return x.times(0.5);\n    };\n    /*\r\n   * Return a new Decimal whose value is the arcsine (inverse sine) in radians of the value of this\r\n   * Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * asin(x) = 2*atan(x/(1 + sqrt(1 - x^2)))\r\n   *\r\n   * asin(0)       = 0\r\n   * asin(-0)      = -0\r\n   * asin(1/2)     = pi/6\r\n   * asin(-1/2)    = -pi/6\r\n   * asin(1)       = pi/2\r\n   * asin(-1)      = -pi/2\r\n   * asin(|x| > 1) = NaN\r\n   * asin(NaN)     = NaN\r\n   *\r\n   * TODO? Compare performance of Taylor series.\r\n   *\r\n   */ P.inverseSine = P.asin = function() {\n        var halfPi, k, pr, rm, x = this, Ctor = x.constructor;\n        if (x.isZero()) return new Ctor(x);\n        k = x.abs().cmp(1);\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        if (k !== -1) {\n            // |x| is 1\n            if (k === 0) {\n                halfPi = getPi(Ctor, pr + 4, rm).times(0.5);\n                halfPi.s = x.s;\n                return halfPi;\n            }\n            // |x| > 1 or x is NaN\n            return new Ctor(NaN);\n        }\n        // TODO? Special case asin(1/2) = pi/6 and asin(-1/2) = -pi/6\n        Ctor.precision = pr + 6;\n        Ctor.rounding = 1;\n        x = x.div(new Ctor(1).minus(x.times(x)).sqrt().plus(1)).atan();\n        Ctor.precision = pr;\n        Ctor.rounding = rm;\n        return x.times(2);\n    };\n    /*\r\n   * Return a new Decimal whose value is the arctangent (inverse tangent) in radians of the value\r\n   * of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi/2, pi/2]\r\n   *\r\n   * atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\r\n   *\r\n   * atan(0)         = 0\r\n   * atan(-0)        = -0\r\n   * atan(1)         = pi/4\r\n   * atan(-1)        = -pi/4\r\n   * atan(Infinity)  = pi/2\r\n   * atan(-Infinity) = -pi/2\r\n   * atan(NaN)       = NaN\r\n   *\r\n   */ P.inverseTangent = P.atan = function() {\n        var i, j, k, n, px, t, r, wpr, x2, x = this, Ctor = x.constructor, pr = Ctor.precision, rm = Ctor.rounding;\n        if (!x.isFinite()) {\n            if (!x.s) return new Ctor(NaN);\n            if (pr + 4 <= PI_PRECISION) {\n                r = getPi(Ctor, pr + 4, rm).times(0.5);\n                r.s = x.s;\n                return r;\n            }\n        } else if (x.isZero()) {\n            return new Ctor(x);\n        } else if (x.abs().eq(1) && pr + 4 <= PI_PRECISION) {\n            r = getPi(Ctor, pr + 4, rm).times(0.25);\n            r.s = x.s;\n            return r;\n        }\n        Ctor.precision = wpr = pr + 10;\n        Ctor.rounding = 1;\n        // TODO? if (x >= 1 && pr <= PI_PRECISION) atan(x) = halfPi * x.s - atan(1 / x);\n        // Argument reduction\n        // Ensure |x| < 0.42\n        // atan(x) = 2 * atan(x / (1 + sqrt(1 + x^2)))\n        k = Math.min(28, wpr / LOG_BASE + 2 | 0);\n        for(i = k; i; --i)x = x.div(x.times(x).plus(1).sqrt().plus(1));\n        external = false;\n        j = Math.ceil(wpr / LOG_BASE);\n        n = 1;\n        x2 = x.times(x);\n        r = new Ctor(x);\n        px = x;\n        // atan(x) = x - x^3/3 + x^5/5 - x^7/7 + ...\n        for(; i !== -1;){\n            px = px.times(x2);\n            t = r.minus(px.div(n += 2));\n            px = px.times(x2);\n            r = t.plus(px.div(n += 2));\n            if (r.d[j] !== void 0) for(i = j; r.d[i] === t.d[i] && i--;);\n        }\n        if (k) r = r.times(2 << k - 1);\n        external = true;\n        return finalise(r, Ctor.precision = pr, Ctor.rounding = rm, true);\n    };\n    /*\r\n   * Return true if the value of this Decimal is a finite number, otherwise return false.\r\n   *\r\n   */ P.isFinite = function() {\n        return !!this.d;\n    };\n    /*\r\n   * Return true if the value of this Decimal is an integer, otherwise return false.\r\n   *\r\n   */ P.isInteger = P.isInt = function() {\n        return !!this.d && mathfloor(this.e / LOG_BASE) > this.d.length - 2;\n    };\n    /*\r\n   * Return true if the value of this Decimal is NaN, otherwise return false.\r\n   *\r\n   */ P.isNaN = function() {\n        return !this.s;\n    };\n    /*\r\n   * Return true if the value of this Decimal is negative, otherwise return false.\r\n   *\r\n   */ P.isNegative = P.isNeg = function() {\n        return this.s < 0;\n    };\n    /*\r\n   * Return true if the value of this Decimal is positive, otherwise return false.\r\n   *\r\n   */ P.isPositive = P.isPos = function() {\n        return this.s > 0;\n    };\n    /*\r\n   * Return true if the value of this Decimal is 0 or -0, otherwise return false.\r\n   *\r\n   */ P.isZero = function() {\n        return !!this.d && this.d[0] === 0;\n    };\n    /*\r\n   * Return true if the value of this Decimal is less than `y`, otherwise return false.\r\n   *\r\n   */ P.lessThan = P.lt = function(y) {\n        return this.cmp(y) < 0;\n    };\n    /*\r\n   * Return true if the value of this Decimal is less than or equal to `y`, otherwise return false.\r\n   *\r\n   */ P.lessThanOrEqualTo = P.lte = function(y) {\n        return this.cmp(y) < 1;\n    };\n    /*\r\n   * Return the logarithm of the value of this Decimal to the specified base, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * If no base is specified, return log[10](arg).\r\n   *\r\n   * log[base](arg) = ln(arg) / ln(base)\r\n   *\r\n   * The result will always be correctly rounded if the base of the log is 10, and 'almost always'\r\n   * otherwise:\r\n   *\r\n   * Depending on the rounding mode, the result may be incorrectly rounded if the first fifteen\r\n   * rounding digits are [49]99999999999999 or [50]00000000000000. In that case, the maximum error\r\n   * between the result and the correctly rounded result will be one ulp (unit in the last place).\r\n   *\r\n   * log[-b](a)       = NaN\r\n   * log[0](a)        = NaN\r\n   * log[1](a)        = NaN\r\n   * log[NaN](a)      = NaN\r\n   * log[Infinity](a) = NaN\r\n   * log[b](0)        = -Infinity\r\n   * log[b](-0)       = -Infinity\r\n   * log[b](-a)       = NaN\r\n   * log[b](1)        = 0\r\n   * log[b](Infinity) = Infinity\r\n   * log[b](NaN)      = NaN\r\n   *\r\n   * [base] {number|string|bigint|Decimal} The base of the logarithm.\r\n   *\r\n   */ P.logarithm = P.log = function(base) {\n        var isBase10, d, denominator, k, inf, num, sd, r, arg = this, Ctor = arg.constructor, pr = Ctor.precision, rm = Ctor.rounding, guard = 5;\n        // Default base is 10.\n        if (base == null) {\n            base = new Ctor(10);\n            isBase10 = true;\n        } else {\n            base = new Ctor(base);\n            d = base.d;\n            // Return NaN if base is negative, or non-finite, or is 0 or 1.\n            if (base.s < 0 || !d || !d[0] || base.eq(1)) return new Ctor(NaN);\n            isBase10 = base.eq(10);\n        }\n        d = arg.d;\n        // Is arg negative, non-finite, 0 or 1?\n        if (arg.s < 0 || !d || !d[0] || arg.eq(1)) {\n            return new Ctor(d && !d[0] ? -1 / 0 : arg.s != 1 ? NaN : d ? 0 : 1 / 0);\n        }\n        // The result will have a non-terminating decimal expansion if base is 10 and arg is not an\n        // integer power of 10.\n        if (isBase10) {\n            if (d.length > 1) {\n                inf = true;\n            } else {\n                for(k = d[0]; k % 10 === 0;)k /= 10;\n                inf = k !== 1;\n            }\n        }\n        external = false;\n        sd = pr + guard;\n        num = naturalLogarithm(arg, sd);\n        denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n        // The result will have 5 rounding digits.\n        r = divide(num, denominator, sd, 1);\n        // If at a rounding boundary, i.e. the result's rounding digits are [49]9999 or [50]0000,\n        // calculate 10 further digits.\n        //\n        // If the result is known to have an infinite decimal expansion, repeat this until it is clear\n        // that the result is above or below the boundary. Otherwise, if after calculating the 10\n        // further digits, the last 14 are nines, round up and assume the result is exact.\n        // Also assume the result is exact if the last 14 are zero.\n        //\n        // Example of a result that will be incorrectly rounded:\n        // log[1048576](4503599627370502) = 2.60000000000000009610279511444746...\n        // The above result correctly rounded using ROUND_CEIL to 1 decimal place should be 2.7, but it\n        // will be given as 2.6 as there are 15 zeros immediately after the requested decimal place, so\n        // the exact result would be assumed to be 2.6, which rounded using ROUND_CEIL to 1 decimal\n        // place is still 2.6.\n        if (checkRoundingDigits(r.d, k = pr, rm)) {\n            do {\n                sd += 10;\n                num = naturalLogarithm(arg, sd);\n                denominator = isBase10 ? getLn10(Ctor, sd + 10) : naturalLogarithm(base, sd);\n                r = divide(num, denominator, sd, 1);\n                if (!inf) {\n                    // Check for 14 nines from the 2nd rounding digit, as the first may be 4.\n                    if (+digitsToString(r.d).slice(k + 1, k + 15) + 1 == 1e14) {\n                        r = finalise(r, pr + 1, 0);\n                    }\n                    break;\n                }\n            }while (checkRoundingDigits(r.d, k += 10, rm));\n        }\n        external = true;\n        return finalise(r, pr, rm);\n    };\n    /*\r\n   * Return a new Decimal whose value is the maximum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|bigint|Decimal}\r\n   *\r\n  P.max = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, -1);\r\n  };\r\n   */ /*\r\n   * Return a new Decimal whose value is the minimum of the arguments and the value of this Decimal.\r\n   *\r\n   * arguments {number|string|bigint|Decimal}\r\n   *\r\n  P.min = function () {\r\n    Array.prototype.push.call(arguments, this);\r\n    return maxOrMin(this.constructor, arguments, 1);\r\n  };\r\n   */ /*\r\n   *  n - 0 = n\r\n   *  n - N = N\r\n   *  n - I = -I\r\n   *  0 - n = -n\r\n   *  0 - 0 = 0\r\n   *  0 - N = N\r\n   *  0 - I = -I\r\n   *  N - n = N\r\n   *  N - 0 = N\r\n   *  N - N = N\r\n   *  N - I = N\r\n   *  I - n = I\r\n   *  I - 0 = I\r\n   *  I - N = N\r\n   *  I - I = N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal minus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */ P.minus = P.sub = function(y) {\n        var d, e, i, j, k, len, pr, rm, xd, xe, xLTy, yd, x = this, Ctor = x.constructor;\n        y = new Ctor(y);\n        // If either is not finite...\n        if (!x.d || !y.d) {\n            // Return NaN if either is NaN.\n            if (!x.s || !y.s) y = new Ctor(NaN);\n            else if (x.d) y.s = -y.s;\n            else y = new Ctor(y.d || x.s !== y.s ? x : NaN);\n            return y;\n        }\n        // If signs differ...\n        if (x.s != y.s) {\n            y.s = -y.s;\n            return x.plus(y);\n        }\n        xd = x.d;\n        yd = y.d;\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        // If either is zero...\n        if (!xd[0] || !yd[0]) {\n            // Return y negated if x is zero and y is non-zero.\n            if (yd[0]) y.s = -y.s;\n            else if (xd[0]) y = new Ctor(x);\n            else return new Ctor(rm === 3 ? -0 : 0);\n            return external ? finalise(y, pr, rm) : y;\n        }\n        // x and y are finite, non-zero numbers with the same sign.\n        // Calculate base 1e7 exponents.\n        e = mathfloor(y.e / LOG_BASE);\n        xe = mathfloor(x.e / LOG_BASE);\n        xd = xd.slice();\n        k = xe - e;\n        // If base 1e7 exponents differ...\n        if (k) {\n            xLTy = k < 0;\n            if (xLTy) {\n                d = xd;\n                k = -k;\n                len = yd.length;\n            } else {\n                d = yd;\n                e = xe;\n                len = xd.length;\n            }\n            // Numbers with massively different exponents would result in a very high number of\n            // zeros needing to be prepended, but this can be avoided while still ensuring correct\n            // rounding by limiting the number of zeros to `Math.ceil(pr / LOG_BASE) + 2`.\n            i = Math.max(Math.ceil(pr / LOG_BASE), len) + 2;\n            if (k > i) {\n                k = i;\n                d.length = 1;\n            }\n            // Prepend zeros to equalise exponents.\n            d.reverse();\n            for(i = k; i--;)d.push(0);\n            d.reverse();\n        // Base 1e7 exponents equal.\n        } else {\n            // Check digits to determine which is the bigger number.\n            i = xd.length;\n            len = yd.length;\n            xLTy = i < len;\n            if (xLTy) len = i;\n            for(i = 0; i < len; i++){\n                if (xd[i] != yd[i]) {\n                    xLTy = xd[i] < yd[i];\n                    break;\n                }\n            }\n            k = 0;\n        }\n        if (xLTy) {\n            d = xd;\n            xd = yd;\n            yd = d;\n            y.s = -y.s;\n        }\n        len = xd.length;\n        // Append zeros to `xd` if shorter.\n        // Don't add zeros to `yd` if shorter as subtraction only needs to start at `yd` length.\n        for(i = yd.length - len; i > 0; --i)xd[len++] = 0;\n        // Subtract yd from xd.\n        for(i = yd.length; i > k;){\n            if (xd[--i] < yd[i]) {\n                for(j = i; j && xd[--j] === 0;)xd[j] = BASE - 1;\n                --xd[j];\n                xd[i] += BASE;\n            }\n            xd[i] -= yd[i];\n        }\n        // Remove trailing zeros.\n        for(; xd[--len] === 0;)xd.pop();\n        // Remove leading zeros and adjust exponent accordingly.\n        for(; xd[0] === 0; xd.shift())--e;\n        // Zero?\n        if (!xd[0]) return new Ctor(rm === 3 ? -0 : 0);\n        y.d = xd;\n        y.e = getBase10Exponent(xd, e);\n        return external ? finalise(y, pr, rm) : y;\n    };\n    /*\r\n   *   n % 0 =  N\r\n   *   n % N =  N\r\n   *   n % I =  n\r\n   *   0 % n =  0\r\n   *  -0 % n = -0\r\n   *   0 % 0 =  N\r\n   *   0 % N =  N\r\n   *   0 % I =  0\r\n   *   N % n =  N\r\n   *   N % 0 =  N\r\n   *   N % N =  N\r\n   *   N % I =  N\r\n   *   I % n =  N\r\n   *   I % 0 =  N\r\n   *   I % N =  N\r\n   *   I % I =  N\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal modulo `y`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * The result depends on the modulo mode.\r\n   *\r\n   */ P.modulo = P.mod = function(y) {\n        var q, x = this, Ctor = x.constructor;\n        y = new Ctor(y);\n        // Return NaN if x is ±Infinity or NaN, or y is NaN or ±0.\n        if (!x.d || !y.s || y.d && !y.d[0]) return new Ctor(NaN);\n        // Return x if y is ±Infinity or x is ±0.\n        if (!y.d || x.d && !x.d[0]) {\n            return finalise(new Ctor(x), Ctor.precision, Ctor.rounding);\n        }\n        // Prevent rounding of intermediate calculations.\n        external = false;\n        if (Ctor.modulo == 9) {\n            // Euclidian division: q = sign(y) * floor(x / abs(y))\n            // result = x - q * y    where  0 <= result < abs(y)\n            q = divide(x, y.abs(), 0, 3, 1);\n            q.s *= y.s;\n        } else {\n            q = divide(x, y, 0, Ctor.modulo, 1);\n        }\n        q = q.times(y);\n        external = true;\n        return x.minus(q);\n    };\n    /*\r\n   * Return a new Decimal whose value is the natural exponential of the value of this Decimal,\r\n   * i.e. the base e raised to the power the value of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */ P.naturalExponential = P.exp = function() {\n        return naturalExponential(this);\n    };\n    /*\r\n   * Return a new Decimal whose value is the natural logarithm of the value of this Decimal,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   */ P.naturalLogarithm = P.ln = function() {\n        return naturalLogarithm(this);\n    };\n    /*\r\n   * Return a new Decimal whose value is the value of this Decimal negated, i.e. as if multiplied by\r\n   * -1.\r\n   *\r\n   */ P.negated = P.neg = function() {\n        var x = new this.constructor(this);\n        x.s = -x.s;\n        return finalise(x);\n    };\n    /*\r\n   *  n + 0 = n\r\n   *  n + N = N\r\n   *  n + I = I\r\n   *  0 + n = n\r\n   *  0 + 0 = 0\r\n   *  0 + N = N\r\n   *  0 + I = I\r\n   *  N + n = N\r\n   *  N + 0 = N\r\n   *  N + N = N\r\n   *  N + I = N\r\n   *  I + n = I\r\n   *  I + 0 = I\r\n   *  I + N = N\r\n   *  I + I = I\r\n   *\r\n   * Return a new Decimal whose value is the value of this Decimal plus `y`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   */ P.plus = P.add = function(y) {\n        var carry, d, e, i, k, len, pr, rm, xd, yd, x = this, Ctor = x.constructor;\n        y = new Ctor(y);\n        // If either is not finite...\n        if (!x.d || !y.d) {\n            // Return NaN if either is NaN.\n            if (!x.s || !y.s) y = new Ctor(NaN);\n            else if (!x.d) y = new Ctor(y.d || x.s === y.s ? x : NaN);\n            return y;\n        }\n        // If signs differ...\n        if (x.s != y.s) {\n            y.s = -y.s;\n            return x.minus(y);\n        }\n        xd = x.d;\n        yd = y.d;\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        // If either is zero...\n        if (!xd[0] || !yd[0]) {\n            // Return x if y is zero.\n            // Return y if y is non-zero.\n            if (!yd[0]) y = new Ctor(x);\n            return external ? finalise(y, pr, rm) : y;\n        }\n        // x and y are finite, non-zero numbers with the same sign.\n        // Calculate base 1e7 exponents.\n        k = mathfloor(x.e / LOG_BASE);\n        e = mathfloor(y.e / LOG_BASE);\n        xd = xd.slice();\n        i = k - e;\n        // If base 1e7 exponents differ...\n        if (i) {\n            if (i < 0) {\n                d = xd;\n                i = -i;\n                len = yd.length;\n            } else {\n                d = yd;\n                e = k;\n                len = xd.length;\n            }\n            // Limit number of zeros prepended to max(ceil(pr / LOG_BASE), len) + 1.\n            k = Math.ceil(pr / LOG_BASE);\n            len = k > len ? k + 1 : len + 1;\n            if (i > len) {\n                i = len;\n                d.length = 1;\n            }\n            // Prepend zeros to equalise exponents. Note: Faster to use reverse then do unshifts.\n            d.reverse();\n            for(; i--;)d.push(0);\n            d.reverse();\n        }\n        len = xd.length;\n        i = yd.length;\n        // If yd is longer than xd, swap xd and yd so xd points to the longer array.\n        if (len - i < 0) {\n            i = len;\n            d = yd;\n            yd = xd;\n            xd = d;\n        }\n        // Only start adding at yd.length - 1 as the further digits of xd can be left as they are.\n        for(carry = 0; i;){\n            carry = (xd[--i] = xd[i] + yd[i] + carry) / BASE | 0;\n            xd[i] %= BASE;\n        }\n        if (carry) {\n            xd.unshift(carry);\n            ++e;\n        }\n        // Remove trailing zeros.\n        // No need to check for zero, as +x + +y != 0 && -x + -y != 0\n        for(len = xd.length; xd[--len] == 0;)xd.pop();\n        y.d = xd;\n        y.e = getBase10Exponent(xd, e);\n        return external ? finalise(y, pr, rm) : y;\n    };\n    /*\r\n   * Return the number of significant digits of the value of this Decimal.\r\n   *\r\n   * [z] {boolean|number} Whether to count integer-part trailing zeros: true, false, 1 or 0.\r\n   *\r\n   */ P.precision = P.sd = function(z) {\n        var k, x = this;\n        if (z !== void 0 && z !== !!z && z !== 1 && z !== 0) throw Error(invalidArgument + z);\n        if (x.d) {\n            k = getPrecision(x.d);\n            if (z && x.e + 1 > k) k = x.e + 1;\n        } else {\n            k = NaN;\n        }\n        return k;\n    };\n    /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a whole number using\r\n   * rounding mode `rounding`.\r\n   *\r\n   */ P.round = function() {\n        var x = this, Ctor = x.constructor;\n        return finalise(new Ctor(x), x.e + 1, Ctor.rounding);\n    };\n    /*\r\n   * Return a new Decimal whose value is the sine of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-1, 1]\r\n   *\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   *\r\n   * sin(0)         = 0\r\n   * sin(-0)        = -0\r\n   * sin(Infinity)  = NaN\r\n   * sin(-Infinity) = NaN\r\n   * sin(NaN)       = NaN\r\n   *\r\n   */ P.sine = P.sin = function() {\n        var pr, rm, x = this, Ctor = x.constructor;\n        if (!x.isFinite()) return new Ctor(NaN);\n        if (x.isZero()) return new Ctor(x);\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        Ctor.precision = pr + Math.max(x.e, x.sd()) + LOG_BASE;\n        Ctor.rounding = 1;\n        x = sine(Ctor, toLessThanHalfPi(Ctor, x));\n        Ctor.precision = pr;\n        Ctor.rounding = rm;\n        return finalise(quadrant > 2 ? x.neg() : x, pr, rm, true);\n    };\n    /*\r\n   * Return a new Decimal whose value is the square root of this Decimal, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   *  sqrt(-n) =  N\r\n   *  sqrt(N)  =  N\r\n   *  sqrt(-I) =  N\r\n   *  sqrt(I)  =  I\r\n   *  sqrt(0)  =  0\r\n   *  sqrt(-0) = -0\r\n   *\r\n   */ P.squareRoot = P.sqrt = function() {\n        var m, n, sd, r, rep, t, x = this, d = x.d, e = x.e, s = x.s, Ctor = x.constructor;\n        // Negative/NaN/Infinity/zero?\n        if (s !== 1 || !d || !d[0]) {\n            return new Ctor(!s || s < 0 && (!d || d[0]) ? NaN : d ? x : 1 / 0);\n        }\n        external = false;\n        // Initial estimate.\n        s = Math.sqrt(+x);\n        // Math.sqrt underflow/overflow?\n        // Pass x to Math.sqrt as integer, then adjust the exponent of the result.\n        if (s == 0 || s == 1 / 0) {\n            n = digitsToString(d);\n            if ((n.length + e) % 2 == 0) n += \"0\";\n            s = Math.sqrt(n);\n            e = mathfloor((e + 1) / 2) - (e < 0 || e % 2);\n            if (s == 1 / 0) {\n                n = \"5e\" + e;\n            } else {\n                n = s.toExponential();\n                n = n.slice(0, n.indexOf(\"e\") + 1) + e;\n            }\n            r = new Ctor(n);\n        } else {\n            r = new Ctor(s.toString());\n        }\n        sd = (e = Ctor.precision) + 3;\n        // Newton-Raphson iteration.\n        for(;;){\n            t = r;\n            r = t.plus(divide(x, t, sd + 2, 1)).times(0.5);\n            // TODO? Replace with for-loop and checkRoundingDigits.\n            if (digitsToString(t.d).slice(0, sd) === (n = digitsToString(r.d)).slice(0, sd)) {\n                n = n.slice(sd - 3, sd + 1);\n                // The 4th rounding digit may be in error by -1 so if the 4 rounding digits are 9999 or\n                // 4999, i.e. approaching a rounding boundary, continue the iteration.\n                if (n == \"9999\" || !rep && n == \"4999\") {\n                    // On the first iteration only, check to see if rounding up gives the exact result as the\n                    // nines may infinitely repeat.\n                    if (!rep) {\n                        finalise(t, e + 1, 0);\n                        if (t.times(t).eq(x)) {\n                            r = t;\n                            break;\n                        }\n                    }\n                    sd += 4;\n                    rep = 1;\n                } else {\n                    // If the rounding digits are null, 0{0,4} or 50{0,3}, check for an exact result.\n                    // If not, then there are further digits and m will be truthy.\n                    if (!+n || !+n.slice(1) && n.charAt(0) == \"5\") {\n                        // Truncate to the first rounding digit.\n                        finalise(r, e + 1, 1);\n                        m = !r.times(r).eq(x);\n                    }\n                    break;\n                }\n            }\n        }\n        external = true;\n        return finalise(r, e, Ctor.rounding, m);\n    };\n    /*\r\n   * Return a new Decimal whose value is the tangent of the value in radians of this Decimal.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-Infinity, Infinity]\r\n   *\r\n   * tan(0)         = 0\r\n   * tan(-0)        = -0\r\n   * tan(Infinity)  = NaN\r\n   * tan(-Infinity) = NaN\r\n   * tan(NaN)       = NaN\r\n   *\r\n   */ P.tangent = P.tan = function() {\n        var pr, rm, x = this, Ctor = x.constructor;\n        if (!x.isFinite()) return new Ctor(NaN);\n        if (x.isZero()) return new Ctor(x);\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        Ctor.precision = pr + 10;\n        Ctor.rounding = 1;\n        x = x.sin();\n        x.s = 1;\n        x = divide(x, new Ctor(1).minus(x.times(x)).sqrt(), pr + 10, 0);\n        Ctor.precision = pr;\n        Ctor.rounding = rm;\n        return finalise(quadrant == 2 || quadrant == 4 ? x.neg() : x, pr, rm, true);\n    };\n    /*\r\n   *  n * 0 = 0\r\n   *  n * N = N\r\n   *  n * I = I\r\n   *  0 * n = 0\r\n   *  0 * 0 = 0\r\n   *  0 * N = N\r\n   *  0 * I = N\r\n   *  N * n = N\r\n   *  N * 0 = N\r\n   *  N * N = N\r\n   *  N * I = N\r\n   *  I * n = I\r\n   *  I * 0 = N\r\n   *  I * N = N\r\n   *  I * I = I\r\n   *\r\n   * Return a new Decimal whose value is this Decimal times `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   */ P.times = P.mul = function(y) {\n        var carry, e, i, k, r, rL, t, xdL, ydL, x = this, Ctor = x.constructor, xd = x.d, yd = (y = new Ctor(y)).d;\n        y.s *= x.s;\n        // If either is NaN, ±Infinity or ±0...\n        if (!xd || !xd[0] || !yd || !yd[0]) {\n            return new Ctor(!y.s || xd && !xd[0] && !yd || yd && !yd[0] && !xd ? NaN : !xd || !yd ? y.s / 0 : y.s * 0);\n        }\n        e = mathfloor(x.e / LOG_BASE) + mathfloor(y.e / LOG_BASE);\n        xdL = xd.length;\n        ydL = yd.length;\n        // Ensure xd points to the longer array.\n        if (xdL < ydL) {\n            r = xd;\n            xd = yd;\n            yd = r;\n            rL = xdL;\n            xdL = ydL;\n            ydL = rL;\n        }\n        // Initialise the result array with zeros.\n        r = [];\n        rL = xdL + ydL;\n        for(i = rL; i--;)r.push(0);\n        // Multiply!\n        for(i = ydL; --i >= 0;){\n            carry = 0;\n            for(k = xdL + i; k > i;){\n                t = r[k] + yd[i] * xd[k - i - 1] + carry;\n                r[k--] = t % BASE | 0;\n                carry = t / BASE | 0;\n            }\n            r[k] = (r[k] + carry) % BASE | 0;\n        }\n        // Remove trailing zeros.\n        for(; !r[--rL];)r.pop();\n        if (carry) ++e;\n        else r.shift();\n        y.d = r;\n        y.e = getBase10Exponent(r, e);\n        return external ? finalise(y, Ctor.precision, Ctor.rounding) : y;\n    };\n    /*\r\n   * Return a string representing the value of this Decimal in base 2, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */ P.toBinary = function(sd, rm) {\n        return toStringBinary(this, 2, sd, rm);\n    };\n    /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `dp`\r\n   * decimal places using rounding mode `rm` or `rounding` if `rm` is omitted.\r\n   *\r\n   * If `dp` is omitted, return a new Decimal whose value is the value of this Decimal.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */ P.toDecimalPlaces = P.toDP = function(dp, rm) {\n        var x = this, Ctor = x.constructor;\n        x = new Ctor(x);\n        if (dp === void 0) return x;\n        checkInt32(dp, 0, MAX_DIGITS);\n        if (rm === void 0) rm = Ctor.rounding;\n        else checkInt32(rm, 0, 8);\n        return finalise(x, dp + x.e + 1, rm);\n    };\n    /*\r\n   * Return a string representing the value of this Decimal in exponential notation rounded to\r\n   * `dp` fixed decimal places using rounding mode `rounding`.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */ P.toExponential = function(dp, rm) {\n        var str, x = this, Ctor = x.constructor;\n        if (dp === void 0) {\n            str = finiteToString(x, true);\n        } else {\n            checkInt32(dp, 0, MAX_DIGITS);\n            if (rm === void 0) rm = Ctor.rounding;\n            else checkInt32(rm, 0, 8);\n            x = finalise(new Ctor(x), dp + 1, rm);\n            str = finiteToString(x, true, dp + 1);\n        }\n        return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n    };\n    /*\r\n   * Return a string representing the value of this Decimal in normal (fixed-point) notation to\r\n   * `dp` fixed decimal places and rounded using rounding mode `rm` or `rounding` if `rm` is\r\n   * omitted.\r\n   *\r\n   * As with JavaScript numbers, (-0).toFixed(0) is '0', but e.g. (-0.00001).toFixed(0) is '-0'.\r\n   *\r\n   * [dp] {number} Decimal places. Integer, 0 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * (-0).toFixed(0) is '0', but (-0.1).toFixed(0) is '-0'.\r\n   * (-0).toFixed(1) is '0.0', but (-0.01).toFixed(1) is '-0.0'.\r\n   * (-0).toFixed(3) is '0.000'.\r\n   * (-0.5).toFixed(0) is '-0'.\r\n   *\r\n   */ P.toFixed = function(dp, rm) {\n        var str, y, x = this, Ctor = x.constructor;\n        if (dp === void 0) {\n            str = finiteToString(x);\n        } else {\n            checkInt32(dp, 0, MAX_DIGITS);\n            if (rm === void 0) rm = Ctor.rounding;\n            else checkInt32(rm, 0, 8);\n            y = finalise(new Ctor(x), dp + x.e + 1, rm);\n            str = finiteToString(y, false, dp + y.e + 1);\n        }\n        // To determine whether to add the minus sign look at the value before it was rounded,\n        // i.e. look at `x` rather than `y`.\n        return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n    };\n    /*\r\n   * Return an array representing the value of this Decimal as a simple fraction with an integer\r\n   * numerator and an integer denominator.\r\n   *\r\n   * The denominator will be a positive non-zero value less than or equal to the specified maximum\r\n   * denominator. If a maximum denominator is not specified, the denominator will be the lowest\r\n   * value necessary to represent the number exactly.\r\n   *\r\n   * [maxD] {number|string|bigint|Decimal} Maximum denominator. Integer >= 1 and < Infinity.\r\n   *\r\n   */ P.toFraction = function(maxD) {\n        var d, d0, d1, d2, e, k, n, n0, n1, pr, q, r, x = this, xd = x.d, Ctor = x.constructor;\n        if (!xd) return new Ctor(x);\n        n1 = d0 = new Ctor(1);\n        d1 = n0 = new Ctor(0);\n        d = new Ctor(d1);\n        e = d.e = getPrecision(xd) - x.e - 1;\n        k = e % LOG_BASE;\n        d.d[0] = mathpow(10, k < 0 ? LOG_BASE + k : k);\n        if (maxD == null) {\n            // d is 10**e, the minimum max-denominator needed.\n            maxD = e > 0 ? d : n1;\n        } else {\n            n = new Ctor(maxD);\n            if (!n.isInt() || n.lt(n1)) throw Error(invalidArgument + n);\n            maxD = n.gt(d) ? e > 0 ? d : n1 : n;\n        }\n        external = false;\n        n = new Ctor(digitsToString(xd));\n        pr = Ctor.precision;\n        Ctor.precision = e = xd.length * LOG_BASE * 2;\n        for(;;){\n            q = divide(n, d, 0, 1, 1);\n            d2 = d0.plus(q.times(d1));\n            if (d2.cmp(maxD) == 1) break;\n            d0 = d1;\n            d1 = d2;\n            d2 = n1;\n            n1 = n0.plus(q.times(d2));\n            n0 = d2;\n            d2 = d;\n            d = n.minus(q.times(d2));\n            n = d2;\n        }\n        d2 = divide(maxD.minus(d0), d1, 0, 1, 1);\n        n0 = n0.plus(d2.times(n1));\n        d0 = d0.plus(d2.times(d1));\n        n0.s = n1.s = x.s;\n        // Determine which fraction is closer to x, n0/d0 or n1/d1?\n        r = divide(n1, d1, e, 1).minus(x).abs().cmp(divide(n0, d0, e, 1).minus(x).abs()) < 1 ? [\n            n1,\n            d1\n        ] : [\n            n0,\n            d0\n        ];\n        Ctor.precision = pr;\n        external = true;\n        return r;\n    };\n    /*\r\n   * Return a string representing the value of this Decimal in base 16, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */ P.toHexadecimal = P.toHex = function(sd, rm) {\n        return toStringBinary(this, 16, sd, rm);\n    };\n    /*\r\n   * Returns a new Decimal whose value is the nearest multiple of `y` in the direction of rounding\r\n   * mode `rm`, or `Decimal.rounding` if `rm` is omitted, to the value of this Decimal.\r\n   *\r\n   * The return value will always have the same sign as this Decimal, unless either this Decimal\r\n   * or `y` is NaN, in which case the return value will be also be NaN.\r\n   *\r\n   * The return value is not affected by the value of `precision`.\r\n   *\r\n   * y {number|string|bigint|Decimal} The magnitude to round to a multiple of.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toNearest() rounding mode not an integer: {rm}'\r\n   * 'toNearest() rounding mode out of range: {rm}'\r\n   *\r\n   */ P.toNearest = function(y, rm) {\n        var x = this, Ctor = x.constructor;\n        x = new Ctor(x);\n        if (y == null) {\n            // If x is not finite, return x.\n            if (!x.d) return x;\n            y = new Ctor(1);\n            rm = Ctor.rounding;\n        } else {\n            y = new Ctor(y);\n            if (rm === void 0) {\n                rm = Ctor.rounding;\n            } else {\n                checkInt32(rm, 0, 8);\n            }\n            // If x is not finite, return x if y is not NaN, else NaN.\n            if (!x.d) return y.s ? x : y;\n            // If y is not finite, return Infinity with the sign of x if y is Infinity, else NaN.\n            if (!y.d) {\n                if (y.s) y.s = x.s;\n                return y;\n            }\n        }\n        // If y is not zero, calculate the nearest multiple of y to x.\n        if (y.d[0]) {\n            external = false;\n            x = divide(x, y, 0, rm, 1).times(y);\n            external = true;\n            finalise(x);\n        // If y is zero, return zero with the sign of x.\n        } else {\n            y.s = x.s;\n            x = y;\n        }\n        return x;\n    };\n    /*\r\n   * Return the value of this Decimal converted to a number primitive.\r\n   * Zero keeps its sign.\r\n   *\r\n   */ P.toNumber = function() {\n        return +this;\n    };\n    /*\r\n   * Return a string representing the value of this Decimal in base 8, round to `sd` significant\r\n   * digits using rounding mode `rm`.\r\n   *\r\n   * If the optional `sd` argument is present then return binary exponential notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */ P.toOctal = function(sd, rm) {\n        return toStringBinary(this, 8, sd, rm);\n    };\n    /*\r\n   * Return a new Decimal whose value is the value of this Decimal raised to the power `y`, rounded\r\n   * to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * ECMAScript compliant.\r\n   *\r\n   *   pow(x, NaN)                           = NaN\r\n   *   pow(x, ±0)                            = 1\r\n\r\n   *   pow(NaN, non-zero)                    = NaN\r\n   *   pow(abs(x) > 1, +Infinity)            = +Infinity\r\n   *   pow(abs(x) > 1, -Infinity)            = +0\r\n   *   pow(abs(x) == 1, ±Infinity)           = NaN\r\n   *   pow(abs(x) < 1, +Infinity)            = +0\r\n   *   pow(abs(x) < 1, -Infinity)            = +Infinity\r\n   *   pow(+Infinity, y > 0)                 = +Infinity\r\n   *   pow(+Infinity, y < 0)                 = +0\r\n   *   pow(-Infinity, odd integer > 0)       = -Infinity\r\n   *   pow(-Infinity, even integer > 0)      = +Infinity\r\n   *   pow(-Infinity, odd integer < 0)       = -0\r\n   *   pow(-Infinity, even integer < 0)      = +0\r\n   *   pow(+0, y > 0)                        = +0\r\n   *   pow(+0, y < 0)                        = +Infinity\r\n   *   pow(-0, odd integer > 0)              = -0\r\n   *   pow(-0, even integer > 0)             = +0\r\n   *   pow(-0, odd integer < 0)              = -Infinity\r\n   *   pow(-0, even integer < 0)             = +Infinity\r\n   *   pow(finite x < 0, finite non-integer) = NaN\r\n   *\r\n   * For non-integer or very large exponents pow(x, y) is calculated using\r\n   *\r\n   *   x^y = exp(y*ln(x))\r\n   *\r\n   * Assuming the first 15 rounding digits are each equally likely to be any digit 0-9, the\r\n   * probability of an incorrectly rounded result\r\n   * P([49]9{14} | [50]0{14}) = 2 * 0.2 * 10^-14 = 4e-15 = 1/2.5e+14\r\n   * i.e. 1 in 250,000,000,000,000\r\n   *\r\n   * If a result is incorrectly rounded the maximum error will be 1 ulp (unit in last place).\r\n   *\r\n   * y {number|string|bigint|Decimal} The power to which to raise this Decimal.\r\n   *\r\n   */ P.toPower = P.pow = function(y) {\n        var e, k, pr, r, rm, s, x = this, Ctor = x.constructor, yn = +(y = new Ctor(y));\n        // Either ±Infinity, NaN or ±0?\n        if (!x.d || !y.d || !x.d[0] || !y.d[0]) return new Ctor(mathpow(+x, yn));\n        x = new Ctor(x);\n        if (x.eq(1)) return x;\n        pr = Ctor.precision;\n        rm = Ctor.rounding;\n        if (y.eq(1)) return finalise(x, pr, rm);\n        // y exponent\n        e = mathfloor(y.e / LOG_BASE);\n        // If y is a small integer use the 'exponentiation by squaring' algorithm.\n        if (e >= y.d.length - 1 && (k = yn < 0 ? -yn : yn) <= MAX_SAFE_INTEGER) {\n            r = intPow(Ctor, x, k, pr);\n            return y.s < 0 ? new Ctor(1).div(r) : finalise(r, pr, rm);\n        }\n        s = x.s;\n        // if x is negative\n        if (s < 0) {\n            // if y is not an integer\n            if (e < y.d.length - 1) return new Ctor(NaN);\n            // Result is positive if x is negative and the last digit of integer y is even.\n            if ((y.d[e] & 1) == 0) s = 1;\n            // if x.eq(-1)\n            if (x.e == 0 && x.d[0] == 1 && x.d.length == 1) {\n                x.s = s;\n                return x;\n            }\n        }\n        // Estimate result exponent.\n        // x^y = 10^e,  where e = y * log10(x)\n        // log10(x) = log10(x_significand) + x_exponent\n        // log10(x_significand) = ln(x_significand) / ln(10)\n        k = mathpow(+x, yn);\n        e = k == 0 || !isFinite(k) ? mathfloor(yn * (Math.log(\"0.\" + digitsToString(x.d)) / Math.LN10 + x.e + 1)) : new Ctor(k + \"\").e;\n        // Exponent estimate may be incorrect e.g. x: 0.999999999999999999, y: 2.29, e: 0, r.e: -1.\n        // Overflow/underflow?\n        if (e > Ctor.maxE + 1 || e < Ctor.minE - 1) return new Ctor(e > 0 ? s / 0 : 0);\n        external = false;\n        Ctor.rounding = x.s = 1;\n        // Estimate the extra guard digits needed to ensure five correct rounding digits from\n        // naturalLogarithm(x). Example of failure without these extra digits (precision: 10):\n        // new Decimal(2.32456).pow('2087987436534566.46411')\n        // should be 1.162377823e+764914905173815, but is 1.162355823e+764914905173815\n        k = Math.min(12, (e + \"\").length);\n        // r = x^y = exp(y*ln(x))\n        r = naturalExponential(y.times(naturalLogarithm(x, pr + k)), pr);\n        // r may be Infinity, e.g. (0.9999999999999999).pow(-1e+40)\n        if (r.d) {\n            // Truncate to the required precision plus five rounding digits.\n            r = finalise(r, pr + 5, 1);\n            // If the rounding digits are [49]9999 or [50]0000 increase the precision by 10 and recalculate\n            // the result.\n            if (checkRoundingDigits(r.d, pr, rm)) {\n                e = pr + 10;\n                // Truncate to the increased precision plus five rounding digits.\n                r = finalise(naturalExponential(y.times(naturalLogarithm(x, e + k)), e), e + 5, 1);\n                // Check for 14 nines from the 2nd rounding digit (the first rounding digit may be 4 or 9).\n                if (+digitsToString(r.d).slice(pr + 1, pr + 15) + 1 == 1e14) {\n                    r = finalise(r, pr + 1, 0);\n                }\n            }\n        }\n        r.s = s;\n        external = true;\n        Ctor.rounding = rm;\n        return finalise(r, pr, rm);\n    };\n    /*\r\n   * Return a string representing the value of this Decimal rounded to `sd` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * Return exponential notation if `sd` is less than the number of digits necessary to represent\r\n   * the integer part of the value in normal notation.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   */ P.toPrecision = function(sd, rm) {\n        var str, x = this, Ctor = x.constructor;\n        if (sd === void 0) {\n            str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n        } else {\n            checkInt32(sd, 1, MAX_DIGITS);\n            if (rm === void 0) rm = Ctor.rounding;\n            else checkInt32(rm, 0, 8);\n            x = finalise(new Ctor(x), sd, rm);\n            str = finiteToString(x, sd <= x.e || x.e <= Ctor.toExpNeg, sd);\n        }\n        return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n    };\n    /*\r\n   * Return a new Decimal whose value is the value of this Decimal rounded to a maximum of `sd`\r\n   * significant digits using rounding mode `rm`, or to `precision` and `rounding` respectively if\r\n   * omitted.\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 1 to MAX_DIGITS inclusive.\r\n   * [rm] {number} Rounding mode. Integer, 0 to 8 inclusive.\r\n   *\r\n   * 'toSD() digits out of range: {sd}'\r\n   * 'toSD() digits not an integer: {sd}'\r\n   * 'toSD() rounding mode not an integer: {rm}'\r\n   * 'toSD() rounding mode out of range: {rm}'\r\n   *\r\n   */ P.toSignificantDigits = P.toSD = function(sd, rm) {\n        var x = this, Ctor = x.constructor;\n        if (sd === void 0) {\n            sd = Ctor.precision;\n            rm = Ctor.rounding;\n        } else {\n            checkInt32(sd, 1, MAX_DIGITS);\n            if (rm === void 0) rm = Ctor.rounding;\n            else checkInt32(rm, 0, 8);\n        }\n        return finalise(new Ctor(x), sd, rm);\n    };\n    /*\r\n   * Return a string representing the value of this Decimal.\r\n   *\r\n   * Return exponential notation if this Decimal has a positive exponent equal to or greater than\r\n   * `toExpPos`, or a negative exponent equal to or less than `toExpNeg`.\r\n   *\r\n   */ P.toString = function() {\n        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n        return x.isNeg() && !x.isZero() ? \"-\" + str : str;\n    };\n    /*\r\n   * Return a new Decimal whose value is the value of this Decimal truncated to a whole number.\r\n   *\r\n   */ P.truncated = P.trunc = function() {\n        return finalise(new this.constructor(this), this.e + 1, 1);\n    };\n    /*\r\n   * Return a string representing the value of this Decimal.\r\n   * Unlike `toString`, negative zero will include the minus sign.\r\n   *\r\n   */ P.valueOf = P.toJSON = function() {\n        var x = this, Ctor = x.constructor, str = finiteToString(x, x.e <= Ctor.toExpNeg || x.e >= Ctor.toExpPos);\n        return x.isNeg() ? \"-\" + str : str;\n    };\n    // Helper functions for Decimal.prototype (P) and/or Decimal methods, and their callers.\n    /*\r\n   *  digitsToString           P.cubeRoot, P.logarithm, P.squareRoot, P.toFraction, P.toPower,\r\n   *                           finiteToString, naturalExponential, naturalLogarithm\r\n   *  checkInt32               P.toDecimalPlaces, P.toExponential, P.toFixed, P.toNearest,\r\n   *                           P.toPrecision, P.toSignificantDigits, toStringBinary, random\r\n   *  checkRoundingDigits      P.logarithm, P.toPower, naturalExponential, naturalLogarithm\r\n   *  convertBase              toStringBinary, parseOther\r\n   *  cos                      P.cos\r\n   *  divide                   P.atanh, P.cubeRoot, P.dividedBy, P.dividedToIntegerBy,\r\n   *                           P.logarithm, P.modulo, P.squareRoot, P.tan, P.tanh, P.toFraction,\r\n   *                           P.toNearest, toStringBinary, naturalExponential, naturalLogarithm,\r\n   *                           taylorSeries, atan2, parseOther\r\n   *  finalise                 P.absoluteValue, P.atan, P.atanh, P.ceil, P.cos, P.cosh,\r\n   *                           P.cubeRoot, P.dividedToIntegerBy, P.floor, P.logarithm, P.minus,\r\n   *                           P.modulo, P.negated, P.plus, P.round, P.sin, P.sinh, P.squareRoot,\r\n   *                           P.tan, P.times, P.toDecimalPlaces, P.toExponential, P.toFixed,\r\n   *                           P.toNearest, P.toPower, P.toPrecision, P.toSignificantDigits,\r\n   *                           P.truncated, divide, getLn10, getPi, naturalExponential,\r\n   *                           naturalLogarithm, ceil, floor, round, trunc\r\n   *  finiteToString           P.toExponential, P.toFixed, P.toPrecision, P.toString, P.valueOf,\r\n   *                           toStringBinary\r\n   *  getBase10Exponent        P.minus, P.plus, P.times, parseOther\r\n   *  getLn10                  P.logarithm, naturalLogarithm\r\n   *  getPi                    P.acos, P.asin, P.atan, toLessThanHalfPi, atan2\r\n   *  getPrecision             P.precision, P.toFraction\r\n   *  getZeroString            digitsToString, finiteToString\r\n   *  intPow                   P.toPower, parseOther\r\n   *  isOdd                    toLessThanHalfPi\r\n   *  maxOrMin                 max, min\r\n   *  naturalExponential       P.naturalExponential, P.toPower\r\n   *  naturalLogarithm         P.acosh, P.asinh, P.atanh, P.logarithm, P.naturalLogarithm,\r\n   *                           P.toPower, naturalExponential\r\n   *  nonFiniteToString        finiteToString, toStringBinary\r\n   *  parseDecimal             Decimal\r\n   *  parseOther               Decimal\r\n   *  sin                      P.sin\r\n   *  taylorSeries             P.cosh, P.sinh, cos, sin\r\n   *  toLessThanHalfPi         P.cos, P.sin\r\n   *  toStringBinary           P.toBinary, P.toHexadecimal, P.toOctal\r\n   *  truncate                 intPow\r\n   *\r\n   *  Throws:                  P.logarithm, P.precision, P.toFraction, checkInt32, getLn10, getPi,\r\n   *                           naturalLogarithm, config, parseOther, random, Decimal\r\n   */ function digitsToString(d) {\n        var i, k, ws, indexOfLastWord = d.length - 1, str = \"\", w = d[0];\n        if (indexOfLastWord > 0) {\n            str += w;\n            for(i = 1; i < indexOfLastWord; i++){\n                ws = d[i] + \"\";\n                k = LOG_BASE - ws.length;\n                if (k) str += getZeroString(k);\n                str += ws;\n            }\n            w = d[i];\n            ws = w + \"\";\n            k = LOG_BASE - ws.length;\n            if (k) str += getZeroString(k);\n        } else if (w === 0) {\n            return \"0\";\n        }\n        // Remove trailing zeros of last w.\n        for(; w % 10 === 0;)w /= 10;\n        return str + w;\n    }\n    function checkInt32(i, min, max) {\n        if (i !== ~~i || i < min || i > max) {\n            throw Error(invalidArgument + i);\n        }\n    }\n    /*\r\n   * Check 5 rounding digits if `repeating` is null, 4 otherwise.\r\n   * `repeating == null` if caller is `log` or `pow`,\r\n   * `repeating != null` if caller is `naturalLogarithm` or `naturalExponential`.\r\n   */ function checkRoundingDigits(d, i, rm, repeating) {\n        var di, k, r, rd;\n        // Get the length of the first word of the array d.\n        for(k = d[0]; k >= 10; k /= 10)--i;\n        // Is the rounding digit in the first word of d?\n        if (--i < 0) {\n            i += LOG_BASE;\n            di = 0;\n        } else {\n            di = Math.ceil((i + 1) / LOG_BASE);\n            i %= LOG_BASE;\n        }\n        // i is the index (0 - 6) of the rounding digit.\n        // E.g. if within the word 3487563 the first rounding digit is 5,\n        // then i = 4, k = 1000, rd = 3487563 % 1000 = 563\n        k = mathpow(10, LOG_BASE - i);\n        rd = d[di] % k | 0;\n        if (repeating == null) {\n            if (i < 3) {\n                if (i == 0) rd = rd / 100 | 0;\n                else if (i == 1) rd = rd / 10 | 0;\n                r = rm < 4 && rd == 99999 || rm > 3 && rd == 49999 || rd == 50000 || rd == 0;\n            } else {\n                r = (rm < 4 && rd + 1 == k || rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 100 | 0) == mathpow(10, i - 2) - 1 || (rd == k / 2 || rd == 0) && (d[di + 1] / k / 100 | 0) == 0;\n            }\n        } else {\n            if (i < 4) {\n                if (i == 0) rd = rd / 1000 | 0;\n                else if (i == 1) rd = rd / 100 | 0;\n                else if (i == 2) rd = rd / 10 | 0;\n                r = (repeating || rm < 4) && rd == 9999 || !repeating && rm > 3 && rd == 4999;\n            } else {\n                r = ((repeating || rm < 4) && rd + 1 == k || !repeating && rm > 3 && rd + 1 == k / 2) && (d[di + 1] / k / 1000 | 0) == mathpow(10, i - 3) - 1;\n            }\n        }\n        return r;\n    }\n    // Convert string of `baseIn` to an array of numbers of `baseOut`.\n    // Eg. convertBase('255', 10, 16) returns [15, 15].\n    // Eg. convertBase('ff', 16, 10) returns [2, 5, 5].\n    function convertBase(str, baseIn, baseOut) {\n        var j, arr = [\n            0\n        ], arrL, i = 0, strL = str.length;\n        for(; i < strL;){\n            for(arrL = arr.length; arrL--;)arr[arrL] *= baseIn;\n            arr[0] += NUMERALS.indexOf(str.charAt(i++));\n            for(j = 0; j < arr.length; j++){\n                if (arr[j] > baseOut - 1) {\n                    if (arr[j + 1] === void 0) arr[j + 1] = 0;\n                    arr[j + 1] += arr[j] / baseOut | 0;\n                    arr[j] %= baseOut;\n                }\n            }\n        }\n        return arr.reverse();\n    }\n    /*\r\n   * cos(x) = 1 - x^2/2! + x^4/4! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */ function cosine(Ctor, x) {\n        var k, len, y;\n        if (x.isZero()) return x;\n        // Argument reduction: cos(4x) = 8*(cos^4(x) - cos^2(x)) + 1\n        // i.e. cos(x) = 8*(cos^4(x/4) - cos^2(x/4)) + 1\n        // Estimate the optimum number of times to use the argument reduction.\n        len = x.d.length;\n        if (len < 32) {\n            k = Math.ceil(len / 3);\n            y = (1 / tinyPow(4, k)).toString();\n        } else {\n            k = 16;\n            y = \"2.3283064365386962890625e-10\";\n        }\n        Ctor.precision += k;\n        x = taylorSeries(Ctor, 1, x.times(y), new Ctor(1));\n        // Reverse argument reduction\n        for(var i = k; i--;){\n            var cos2x = x.times(x);\n            x = cos2x.times(cos2x).minus(cos2x).times(8).plus(1);\n        }\n        Ctor.precision -= k;\n        return x;\n    }\n    /*\r\n   * Perform division in the specified base.\r\n   */ var divide = function() {\n        // Assumes non-zero x and k, and hence non-zero result.\n        function multiplyInteger(x, k, base) {\n            var temp, carry = 0, i = x.length;\n            for(x = x.slice(); i--;){\n                temp = x[i] * k + carry;\n                x[i] = temp % base | 0;\n                carry = temp / base | 0;\n            }\n            if (carry) x.unshift(carry);\n            return x;\n        }\n        function compare(a, b, aL, bL) {\n            var i, r;\n            if (aL != bL) {\n                r = aL > bL ? 1 : -1;\n            } else {\n                for(i = r = 0; i < aL; i++){\n                    if (a[i] != b[i]) {\n                        r = a[i] > b[i] ? 1 : -1;\n                        break;\n                    }\n                }\n            }\n            return r;\n        }\n        function subtract(a, b, aL, base) {\n            var i = 0;\n            // Subtract b from a.\n            for(; aL--;){\n                a[aL] -= i;\n                i = a[aL] < b[aL] ? 1 : 0;\n                a[aL] = i * base + a[aL] - b[aL];\n            }\n            // Remove leading zeros.\n            for(; !a[0] && a.length > 1;)a.shift();\n        }\n        return function(x, y, pr, rm, dp, base) {\n            var cmp, e, i, k, logBase, more, prod, prodL, q, qd, rem, remL, rem0, sd, t, xi, xL, yd0, yL, yz, Ctor = x.constructor, sign = x.s == y.s ? 1 : -1, xd = x.d, yd = y.d;\n            // Either NaN, Infinity or 0?\n            if (!xd || !xd[0] || !yd || !yd[0]) {\n                return new Ctor(!x.s || !y.s || (xd ? yd && xd[0] == yd[0] : !yd) ? NaN : // Return ±0 if x is 0 or y is ±Infinity, or return ±Infinity as y is 0.\n                xd && xd[0] == 0 || !yd ? sign * 0 : sign / 0);\n            }\n            if (base) {\n                logBase = 1;\n                e = x.e - y.e;\n            } else {\n                base = BASE;\n                logBase = LOG_BASE;\n                e = mathfloor(x.e / logBase) - mathfloor(y.e / logBase);\n            }\n            yL = yd.length;\n            xL = xd.length;\n            q = new Ctor(sign);\n            qd = q.d = [];\n            // Result exponent may be one less than e.\n            // The digit array of a Decimal from toStringBinary may have trailing zeros.\n            for(i = 0; yd[i] == (xd[i] || 0); i++);\n            if (yd[i] > (xd[i] || 0)) e--;\n            if (pr == null) {\n                sd = pr = Ctor.precision;\n                rm = Ctor.rounding;\n            } else if (dp) {\n                sd = pr + (x.e - y.e) + 1;\n            } else {\n                sd = pr;\n            }\n            if (sd < 0) {\n                qd.push(1);\n                more = true;\n            } else {\n                // Convert precision in number of base 10 digits to base 1e7 digits.\n                sd = sd / logBase + 2 | 0;\n                i = 0;\n                // divisor < 1e7\n                if (yL == 1) {\n                    k = 0;\n                    yd = yd[0];\n                    sd++;\n                    // k is the carry.\n                    for(; (i < xL || k) && sd--; i++){\n                        t = k * base + (xd[i] || 0);\n                        qd[i] = t / yd | 0;\n                        k = t % yd | 0;\n                    }\n                    more = k || i < xL;\n                // divisor >= 1e7\n                } else {\n                    // Normalise xd and yd so highest order digit of yd is >= base/2\n                    k = base / (yd[0] + 1) | 0;\n                    if (k > 1) {\n                        yd = multiplyInteger(yd, k, base);\n                        xd = multiplyInteger(xd, k, base);\n                        yL = yd.length;\n                        xL = xd.length;\n                    }\n                    xi = yL;\n                    rem = xd.slice(0, yL);\n                    remL = rem.length;\n                    // Add zeros to make remainder as long as divisor.\n                    for(; remL < yL;)rem[remL++] = 0;\n                    yz = yd.slice();\n                    yz.unshift(0);\n                    yd0 = yd[0];\n                    if (yd[1] >= base / 2) ++yd0;\n                    do {\n                        k = 0;\n                        // Compare divisor and remainder.\n                        cmp = compare(yd, rem, yL, remL);\n                        // If divisor < remainder.\n                        if (cmp < 0) {\n                            // Calculate trial digit, k.\n                            rem0 = rem[0];\n                            if (yL != remL) rem0 = rem0 * base + (rem[1] || 0);\n                            // k will be how many times the divisor goes into the current remainder.\n                            k = rem0 / yd0 | 0;\n                            //  Algorithm:\n                            //  1. product = divisor * trial digit (k)\n                            //  2. if product > remainder: product -= divisor, k--\n                            //  3. remainder -= product\n                            //  4. if product was < remainder at 2:\n                            //    5. compare new remainder and divisor\n                            //    6. If remainder > divisor: remainder -= divisor, k++\n                            if (k > 1) {\n                                if (k >= base) k = base - 1;\n                                // product = divisor * trial digit.\n                                prod = multiplyInteger(yd, k, base);\n                                prodL = prod.length;\n                                remL = rem.length;\n                                // Compare product and remainder.\n                                cmp = compare(prod, rem, prodL, remL);\n                                // product > remainder.\n                                if (cmp == 1) {\n                                    k--;\n                                    // Subtract divisor from product.\n                                    subtract(prod, yL < prodL ? yz : yd, prodL, base);\n                                }\n                            } else {\n                                // cmp is -1.\n                                // If k is 0, there is no need to compare yd and rem again below, so change cmp to 1\n                                // to avoid it. If k is 1 there is a need to compare yd and rem again below.\n                                if (k == 0) cmp = k = 1;\n                                prod = yd.slice();\n                            }\n                            prodL = prod.length;\n                            if (prodL < remL) prod.unshift(0);\n                            // Subtract product from remainder.\n                            subtract(rem, prod, remL, base);\n                            // If product was < previous remainder.\n                            if (cmp == -1) {\n                                remL = rem.length;\n                                // Compare divisor and new remainder.\n                                cmp = compare(yd, rem, yL, remL);\n                                // If divisor < new remainder, subtract divisor from remainder.\n                                if (cmp < 1) {\n                                    k++;\n                                    // Subtract divisor from remainder.\n                                    subtract(rem, yL < remL ? yz : yd, remL, base);\n                                }\n                            }\n                            remL = rem.length;\n                        } else if (cmp === 0) {\n                            k++;\n                            rem = [\n                                0\n                            ];\n                        } // if cmp === 1, k will be 0\n                        // Add the next digit, k, to the result array.\n                        qd[i++] = k;\n                        // Update the remainder.\n                        if (cmp && rem[0]) {\n                            rem[remL++] = xd[xi] || 0;\n                        } else {\n                            rem = [\n                                xd[xi]\n                            ];\n                            remL = 1;\n                        }\n                    }while ((xi++ < xL || rem[0] !== void 0) && sd--);\n                    more = rem[0] !== void 0;\n                }\n                // Leading zero?\n                if (!qd[0]) qd.shift();\n            }\n            // logBase is 1 when divide is being used for base conversion.\n            if (logBase == 1) {\n                q.e = e;\n                inexact = more;\n            } else {\n                // To calculate q.e, first get the number of digits of qd[0].\n                for(i = 1, k = qd[0]; k >= 10; k /= 10)i++;\n                q.e = i + e * logBase - 1;\n                finalise(q, dp ? pr + q.e + 1 : pr, rm, more);\n            }\n            return q;\n        };\n    }();\n    /*\r\n   * Round `x` to `sd` significant digits using rounding mode `rm`.\r\n   * Check for over/under-flow.\r\n   */ function finalise(x, sd, rm, isTruncated) {\n        var digits, i, j, k, rd, roundUp, w, xd, xdi, Ctor = x.constructor;\n        // Don't round if sd is null or undefined.\n        out: if (sd != null) {\n            xd = x.d;\n            // Infinity/NaN.\n            if (!xd) return x;\n            // rd: the rounding digit, i.e. the digit after the digit that may be rounded up.\n            // w: the word of xd containing rd, a base 1e7 number.\n            // xdi: the index of w within xd.\n            // digits: the number of digits of w.\n            // i: what would be the index of rd within w if all the numbers were 7 digits long (i.e. if\n            // they had leading zeros)\n            // j: if > 0, the actual index of rd within w (if < 0, rd is a leading zero).\n            // Get the length of the first word of the digits array xd.\n            for(digits = 1, k = xd[0]; k >= 10; k /= 10)digits++;\n            i = sd - digits;\n            // Is the rounding digit in the first word of xd?\n            if (i < 0) {\n                i += LOG_BASE;\n                j = sd;\n                w = xd[xdi = 0];\n                // Get the rounding digit at index j of w.\n                rd = w / mathpow(10, digits - j - 1) % 10 | 0;\n            } else {\n                xdi = Math.ceil((i + 1) / LOG_BASE);\n                k = xd.length;\n                if (xdi >= k) {\n                    if (isTruncated) {\n                        // Needed by `naturalExponential`, `naturalLogarithm` and `squareRoot`.\n                        for(; k++ <= xdi;)xd.push(0);\n                        w = rd = 0;\n                        digits = 1;\n                        i %= LOG_BASE;\n                        j = i - LOG_BASE + 1;\n                    } else {\n                        break out;\n                    }\n                } else {\n                    w = k = xd[xdi];\n                    // Get the number of digits of w.\n                    for(digits = 1; k >= 10; k /= 10)digits++;\n                    // Get the index of rd within w.\n                    i %= LOG_BASE;\n                    // Get the index of rd within w, adjusted for leading zeros.\n                    // The number of leading zeros of w is given by LOG_BASE - digits.\n                    j = i - LOG_BASE + digits;\n                    // Get the rounding digit at index j of w.\n                    rd = j < 0 ? 0 : w / mathpow(10, digits - j - 1) % 10 | 0;\n                }\n            }\n            // Are there any non-zero digits after the rounding digit?\n            isTruncated = isTruncated || sd < 0 || xd[xdi + 1] !== void 0 || (j < 0 ? w : w % mathpow(10, digits - j - 1));\n            // The expression `w % mathpow(10, digits - j - 1)` returns all the digits of w to the right\n            // of the digit at (left-to-right) index j, e.g. if w is 908714 and j is 2, the expression\n            // will give 714.\n            roundUp = rm < 4 ? (rd || isTruncated) && (rm == 0 || rm == (x.s < 0 ? 3 : 2)) : rd > 5 || rd == 5 && (rm == 4 || isTruncated || rm == 6 && (i > 0 ? j > 0 ? w / mathpow(10, digits - j) : 0 : xd[xdi - 1]) % 10 & 1 || rm == (x.s < 0 ? 8 : 7));\n            if (sd < 1 || !xd[0]) {\n                xd.length = 0;\n                if (roundUp) {\n                    // Convert sd to decimal places.\n                    sd -= x.e + 1;\n                    // 1, 0.1, 0.01, 0.001, 0.0001 etc.\n                    xd[0] = mathpow(10, (LOG_BASE - sd % LOG_BASE) % LOG_BASE);\n                    x.e = -sd || 0;\n                } else {\n                    // Zero.\n                    xd[0] = x.e = 0;\n                }\n                return x;\n            }\n            // Remove excess digits.\n            if (i == 0) {\n                xd.length = xdi;\n                k = 1;\n                xdi--;\n            } else {\n                xd.length = xdi + 1;\n                k = mathpow(10, LOG_BASE - i);\n                // E.g. 56700 becomes 56000 if 7 is the rounding digit.\n                // j > 0 means i > number of leading zeros of w.\n                xd[xdi] = j > 0 ? (w / mathpow(10, digits - j) % mathpow(10, j) | 0) * k : 0;\n            }\n            if (roundUp) {\n                for(;;){\n                    // Is the digit to be rounded up in the first word of xd?\n                    if (xdi == 0) {\n                        // i will be the length of xd[0] before k is added.\n                        for(i = 1, j = xd[0]; j >= 10; j /= 10)i++;\n                        j = xd[0] += k;\n                        for(k = 1; j >= 10; j /= 10)k++;\n                        // if i != k the length has increased.\n                        if (i != k) {\n                            x.e++;\n                            if (xd[0] == BASE) xd[0] = 1;\n                        }\n                        break;\n                    } else {\n                        xd[xdi] += k;\n                        if (xd[xdi] != BASE) break;\n                        xd[xdi--] = 0;\n                        k = 1;\n                    }\n                }\n            }\n            // Remove trailing zeros.\n            for(i = xd.length; xd[--i] === 0;)xd.pop();\n        }\n        if (external) {\n            // Overflow?\n            if (x.e > Ctor.maxE) {\n                // Infinity.\n                x.d = null;\n                x.e = NaN;\n            // Underflow?\n            } else if (x.e < Ctor.minE) {\n                // Zero.\n                x.e = 0;\n                x.d = [\n                    0\n                ];\n            // Ctor.underflow = true;\n            } // else Ctor.underflow = false;\n        }\n        return x;\n    }\n    function finiteToString(x, isExp, sd) {\n        if (!x.isFinite()) return nonFiniteToString(x);\n        var k, e = x.e, str = digitsToString(x.d), len = str.length;\n        if (isExp) {\n            if (sd && (k = sd - len) > 0) {\n                str = str.charAt(0) + \".\" + str.slice(1) + getZeroString(k);\n            } else if (len > 1) {\n                str = str.charAt(0) + \".\" + str.slice(1);\n            }\n            str = str + (x.e < 0 ? \"e\" : \"e+\") + x.e;\n        } else if (e < 0) {\n            str = \"0.\" + getZeroString(-e - 1) + str;\n            if (sd && (k = sd - len) > 0) str += getZeroString(k);\n        } else if (e >= len) {\n            str += getZeroString(e + 1 - len);\n            if (sd && (k = sd - e - 1) > 0) str = str + \".\" + getZeroString(k);\n        } else {\n            if ((k = e + 1) < len) str = str.slice(0, k) + \".\" + str.slice(k);\n            if (sd && (k = sd - len) > 0) {\n                if (e + 1 === len) str += \".\";\n                str += getZeroString(k);\n            }\n        }\n        return str;\n    }\n    // Calculate the base 10 exponent from the base 1e7 exponent.\n    function getBase10Exponent(digits, e) {\n        var w = digits[0];\n        // Add the number of digits of the first word of the digits array.\n        for(e *= LOG_BASE; w >= 10; w /= 10)e++;\n        return e;\n    }\n    function getLn10(Ctor, sd, pr) {\n        if (sd > LN10_PRECISION) {\n            // Reset global state in case the exception is caught.\n            external = true;\n            if (pr) Ctor.precision = pr;\n            throw Error(precisionLimitExceeded);\n        }\n        return finalise(new Ctor(LN10), sd, 1, true);\n    }\n    function getPi(Ctor, sd, rm) {\n        if (sd > PI_PRECISION) throw Error(precisionLimitExceeded);\n        return finalise(new Ctor(PI), sd, rm, true);\n    }\n    function getPrecision(digits) {\n        var w = digits.length - 1, len = w * LOG_BASE + 1;\n        w = digits[w];\n        // If non-zero...\n        if (w) {\n            // Subtract the number of trailing zeros of the last word.\n            for(; w % 10 == 0; w /= 10)len--;\n            // Add the number of digits of the first word.\n            for(w = digits[0]; w >= 10; w /= 10)len++;\n        }\n        return len;\n    }\n    function getZeroString(k) {\n        var zs = \"\";\n        for(; k--;)zs += \"0\";\n        return zs;\n    }\n    /*\r\n   * Return a new Decimal whose value is the value of Decimal `x` to the power `n`, where `n` is an\r\n   * integer of type number.\r\n   *\r\n   * Implements 'exponentiation by squaring'. Called by `pow` and `parseOther`.\r\n   *\r\n   */ function intPow(Ctor, x, n, pr) {\n        var isTruncated, r = new Ctor(1), // Max n of 9007199254740991 takes 53 loop iterations.\n        // Maximum digits array length; leaves [28, 34] guard digits.\n        k = Math.ceil(pr / LOG_BASE + 4);\n        external = false;\n        for(;;){\n            if (n % 2) {\n                r = r.times(x);\n                if (truncate(r.d, k)) isTruncated = true;\n            }\n            n = mathfloor(n / 2);\n            if (n === 0) {\n                // To ensure correct rounding when r.d is truncated, increment the last word if it is zero.\n                n = r.d.length - 1;\n                if (isTruncated && r.d[n] === 0) ++r.d[n];\n                break;\n            }\n            x = x.times(x);\n            truncate(x.d, k);\n        }\n        external = true;\n        return r;\n    }\n    function isOdd(n) {\n        return n.d[n.d.length - 1] & 1;\n    }\n    /*\r\n   * Handle `max` (`n` is -1) and `min` (`n` is 1).\r\n   */ function maxOrMin(Ctor, args, n) {\n        var k, y, x = new Ctor(args[0]), i = 0;\n        for(; ++i < args.length;){\n            y = new Ctor(args[i]);\n            // NaN?\n            if (!y.s) {\n                x = y;\n                break;\n            }\n            k = x.cmp(y);\n            if (k === n || k === 0 && x.s === n) {\n                x = y;\n            }\n        }\n        return x;\n    }\n    /*\r\n   * Return a new Decimal whose value is the natural exponential of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   * Taylor/Maclaurin series.\r\n   *\r\n   * exp(x) = x^0/0! + x^1/1! + x^2/2! + x^3/3! + ...\r\n   *\r\n   * Argument reduction:\r\n   *   Repeat x = x / 32, k += 5, until |x| < 0.1\r\n   *   exp(x) = exp(x / 2^k)^(2^k)\r\n   *\r\n   * Previously, the argument was initially reduced by\r\n   * exp(x) = exp(r) * 10^k  where r = x - k * ln10, k = floor(x / ln10)\r\n   * to first put r in the range [0, ln10], before dividing by 32 until |x| < 0.1, but this was\r\n   * found to be slower than just dividing repeatedly by 32 as above.\r\n   *\r\n   * Max integer argument: exp('20723265836946413') = 6.3e+9000000000000000\r\n   * Min integer argument: exp('-20723265836946411') = 1.2e-9000000000000000\r\n   * (Math object integer min/max: Math.exp(709) = 8.2e+307, Math.exp(-745) = 5e-324)\r\n   *\r\n   *  exp(Infinity)  = Infinity\r\n   *  exp(-Infinity) = 0\r\n   *  exp(NaN)       = NaN\r\n   *  exp(±0)        = 1\r\n   *\r\n   *  exp(x) is non-terminating for any finite, non-zero x.\r\n   *\r\n   *  The result will always be correctly rounded.\r\n   *\r\n   */ function naturalExponential(x, sd) {\n        var denominator, guard, j, pow, sum, t, wpr, rep = 0, i = 0, k = 0, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n        // 0/NaN/Infinity?\n        if (!x.d || !x.d[0] || x.e > 17) {\n            return new Ctor(x.d ? !x.d[0] ? 1 : x.s < 0 ? 0 : 1 / 0 : x.s ? x.s < 0 ? 0 : x : 0 / 0);\n        }\n        if (sd == null) {\n            external = false;\n            wpr = pr;\n        } else {\n            wpr = sd;\n        }\n        t = new Ctor(0.03125);\n        // while abs(x) >= 0.1\n        while(x.e > -2){\n            // x = x / 2^5\n            x = x.times(t);\n            k += 5;\n        }\n        // Use 2 * log10(2^k) + 5 (empirically derived) to estimate the increase in precision\n        // necessary to ensure the first 4 rounding digits are correct.\n        guard = Math.log(mathpow(2, k)) / Math.LN10 * 2 + 5 | 0;\n        wpr += guard;\n        denominator = pow = sum = new Ctor(1);\n        Ctor.precision = wpr;\n        for(;;){\n            pow = finalise(pow.times(x), wpr, 1);\n            denominator = denominator.times(++i);\n            t = sum.plus(divide(pow, denominator, wpr, 1));\n            if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n                j = k;\n                while(j--)sum = finalise(sum.times(sum), wpr, 1);\n                // Check to see if the first 4 rounding digits are [49]999.\n                // If so, repeat the summation with a higher precision, otherwise\n                // e.g. with precision: 18, rounding: 1\n                // exp(18.404272462595034083567793919843761) = 98372560.1229999999 (should be 98372560.123)\n                // `wpr - guard` is the index of first rounding digit.\n                if (sd == null) {\n                    if (rep < 3 && checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n                        Ctor.precision = wpr += 10;\n                        denominator = pow = t = new Ctor(1);\n                        i = 0;\n                        rep++;\n                    } else {\n                        return finalise(sum, Ctor.precision = pr, rm, external = true);\n                    }\n                } else {\n                    Ctor.precision = pr;\n                    return sum;\n                }\n            }\n            sum = t;\n        }\n    }\n    /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x` rounded to `sd` significant\r\n   * digits.\r\n   *\r\n   *  ln(-n)        = NaN\r\n   *  ln(0)         = -Infinity\r\n   *  ln(-0)        = -Infinity\r\n   *  ln(1)         = 0\r\n   *  ln(Infinity)  = Infinity\r\n   *  ln(-Infinity) = NaN\r\n   *  ln(NaN)       = NaN\r\n   *\r\n   *  ln(n) (n != 1) is non-terminating.\r\n   *\r\n   */ function naturalLogarithm(y, sd) {\n        var c, c0, denominator, e, numerator, rep, sum, t, wpr, x1, x2, n = 1, guard = 10, x = y, xd = x.d, Ctor = x.constructor, rm = Ctor.rounding, pr = Ctor.precision;\n        // Is x negative or Infinity, NaN, 0 or 1?\n        if (x.s < 0 || !xd || !xd[0] || !x.e && xd[0] == 1 && xd.length == 1) {\n            return new Ctor(xd && !xd[0] ? -1 / 0 : x.s != 1 ? NaN : xd ? 0 : x);\n        }\n        if (sd == null) {\n            external = false;\n            wpr = pr;\n        } else {\n            wpr = sd;\n        }\n        Ctor.precision = wpr += guard;\n        c = digitsToString(xd);\n        c0 = c.charAt(0);\n        if (Math.abs(e = x.e) < 1.5e15) {\n            // Argument reduction.\n            // The series converges faster the closer the argument is to 1, so using\n            // ln(a^b) = b * ln(a),   ln(a) = ln(a^b) / b\n            // multiply the argument by itself until the leading digits of the significand are 7, 8, 9,\n            // 10, 11, 12 or 13, recording the number of multiplications so the sum of the series can\n            // later be divided by this number, then separate out the power of 10 using\n            // ln(a*10^b) = ln(a) + b*ln(10).\n            // max n is 21 (gives 0.9, 1.0 or 1.1) (9e15 / 21 = 4.2e14).\n            //while (c0 < 9 && c0 != 1 || c0 == 1 && c.charAt(1) > 1) {\n            // max n is 6 (gives 0.7 - 1.3)\n            while(c0 < 7 && c0 != 1 || c0 == 1 && c.charAt(1) > 3){\n                x = x.times(y);\n                c = digitsToString(x.d);\n                c0 = c.charAt(0);\n                n++;\n            }\n            e = x.e;\n            if (c0 > 1) {\n                x = new Ctor(\"0.\" + c);\n                e++;\n            } else {\n                x = new Ctor(c0 + \".\" + c.slice(1));\n            }\n        } else {\n            // The argument reduction method above may result in overflow if the argument y is a massive\n            // number with exponent >= 1500000000000000 (9e15 / 6 = 1.5e15), so instead recall this\n            // function using ln(x*10^e) = ln(x) + e*ln(10).\n            t = getLn10(Ctor, wpr + 2, pr).times(e + \"\");\n            x = naturalLogarithm(new Ctor(c0 + \".\" + c.slice(1)), wpr - guard).plus(t);\n            Ctor.precision = pr;\n            return sd == null ? finalise(x, pr, rm, external = true) : x;\n        }\n        // x1 is x reduced to a value near 1.\n        x1 = x;\n        // Taylor series.\n        // ln(y) = ln((1 + x)/(1 - x)) = 2(x + x^3/3 + x^5/5 + x^7/7 + ...)\n        // where x = (y - 1)/(y + 1)    (|x| < 1)\n        sum = numerator = x = divide(x.minus(1), x.plus(1), wpr, 1);\n        x2 = finalise(x.times(x), wpr, 1);\n        denominator = 3;\n        for(;;){\n            numerator = finalise(numerator.times(x2), wpr, 1);\n            t = sum.plus(divide(numerator, new Ctor(denominator), wpr, 1));\n            if (digitsToString(t.d).slice(0, wpr) === digitsToString(sum.d).slice(0, wpr)) {\n                sum = sum.times(2);\n                // Reverse the argument reduction. Check that e is not 0 because, besides preventing an\n                // unnecessary calculation, -0 + 0 = +0 and to ensure correct rounding -0 needs to stay -0.\n                if (e !== 0) sum = sum.plus(getLn10(Ctor, wpr + 2, pr).times(e + \"\"));\n                sum = divide(sum, new Ctor(n), wpr, 1);\n                // Is rm > 3 and the first 4 rounding digits 4999, or rm < 4 (or the summation has\n                // been repeated previously) and the first 4 rounding digits 9999?\n                // If so, restart the summation with a higher precision, otherwise\n                // e.g. with precision: 12, rounding: 1\n                // ln(135520028.6126091714265381533) = 18.7246299999 when it should be 18.72463.\n                // `wpr - guard` is the index of first rounding digit.\n                if (sd == null) {\n                    if (checkRoundingDigits(sum.d, wpr - guard, rm, rep)) {\n                        Ctor.precision = wpr += guard;\n                        t = numerator = x = divide(x1.minus(1), x1.plus(1), wpr, 1);\n                        x2 = finalise(x.times(x), wpr, 1);\n                        denominator = rep = 1;\n                    } else {\n                        return finalise(sum, Ctor.precision = pr, rm, external = true);\n                    }\n                } else {\n                    Ctor.precision = pr;\n                    return sum;\n                }\n            }\n            sum = t;\n            denominator += 2;\n        }\n    }\n    // ±Infinity, NaN.\n    function nonFiniteToString(x) {\n        // Unsigned.\n        return String(x.s * x.s / 0);\n    }\n    /*\r\n   * Parse the value of a new Decimal `x` from string `str`.\r\n   */ function parseDecimal(x, str) {\n        var e, i, len;\n        // TODO BigInt str: no need to check for decimal point, exponential form or leading zeros.\n        // Decimal point?\n        if ((e = str.indexOf(\".\")) > -1) str = str.replace(\".\", \"\");\n        // Exponential form?\n        if ((i = str.search(/e/i)) > 0) {\n            // Determine exponent.\n            if (e < 0) e = i;\n            e += +str.slice(i + 1);\n            str = str.substring(0, i);\n        } else if (e < 0) {\n            // Integer.\n            e = str.length;\n        }\n        // Determine leading zeros.\n        for(i = 0; str.charCodeAt(i) === 48; i++);\n        // Determine trailing zeros.\n        for(len = str.length; str.charCodeAt(len - 1) === 48; --len);\n        str = str.slice(i, len);\n        if (str) {\n            len -= i;\n            x.e = e = e - i - 1;\n            x.d = [];\n            // Transform base\n            // e is the base 10 exponent.\n            // i is where to slice str to get the first word of the digits array.\n            i = (e + 1) % LOG_BASE;\n            if (e < 0) i += LOG_BASE;\n            if (i < len) {\n                if (i) x.d.push(+str.slice(0, i));\n                for(len -= LOG_BASE; i < len;)x.d.push(+str.slice(i, i += LOG_BASE));\n                str = str.slice(i);\n                i = LOG_BASE - str.length;\n            } else {\n                i -= len;\n            }\n            for(; i--;)str += \"0\";\n            x.d.push(+str);\n            if (external) {\n                // Overflow?\n                if (x.e > x.constructor.maxE) {\n                    // Infinity.\n                    x.d = null;\n                    x.e = NaN;\n                // Underflow?\n                } else if (x.e < x.constructor.minE) {\n                    // Zero.\n                    x.e = 0;\n                    x.d = [\n                        0\n                    ];\n                // x.constructor.underflow = true;\n                } // else x.constructor.underflow = false;\n            }\n        } else {\n            // Zero.\n            x.e = 0;\n            x.d = [\n                0\n            ];\n        }\n        return x;\n    }\n    /*\r\n   * Parse the value of a new Decimal `x` from a string `str`, which is not a decimal value.\r\n   */ function parseOther(x, str) {\n        var base, Ctor, divisor, i, isFloat, len, p, xd, xe;\n        if (str.indexOf(\"_\") > -1) {\n            str = str.replace(/(\\d)_(?=\\d)/g, \"$1\");\n            if (isDecimal.test(str)) return parseDecimal(x, str);\n        } else if (str === \"Infinity\" || str === \"NaN\") {\n            if (!+str) x.s = NaN;\n            x.e = NaN;\n            x.d = null;\n            return x;\n        }\n        if (isHex.test(str)) {\n            base = 16;\n            str = str.toLowerCase();\n        } else if (isBinary.test(str)) {\n            base = 2;\n        } else if (isOctal.test(str)) {\n            base = 8;\n        } else {\n            throw Error(invalidArgument + str);\n        }\n        // Is there a binary exponent part?\n        i = str.search(/p/i);\n        if (i > 0) {\n            p = +str.slice(i + 1);\n            str = str.substring(2, i);\n        } else {\n            str = str.slice(2);\n        }\n        // Convert `str` as an integer then divide the result by `base` raised to a power such that the\n        // fraction part will be restored.\n        i = str.indexOf(\".\");\n        isFloat = i >= 0;\n        Ctor = x.constructor;\n        if (isFloat) {\n            str = str.replace(\".\", \"\");\n            len = str.length;\n            i = len - i;\n            // log[10](16) = 1.2041... , log[10](88) = 1.9444....\n            divisor = intPow(Ctor, new Ctor(base), i, i * 2);\n        }\n        xd = convertBase(str, base, BASE);\n        xe = xd.length - 1;\n        // Remove trailing zeros.\n        for(i = xe; xd[i] === 0; --i)xd.pop();\n        if (i < 0) return new Ctor(x.s * 0);\n        x.e = getBase10Exponent(xd, xe);\n        x.d = xd;\n        external = false;\n        // At what precision to perform the division to ensure exact conversion?\n        // maxDecimalIntegerPartDigitCount = ceil(log[10](b) * otherBaseIntegerPartDigitCount)\n        // log[10](2) = 0.30103, log[10](8) = 0.90309, log[10](16) = 1.20412\n        // E.g. ceil(1.2 * 3) = 4, so up to 4 decimal digits are needed to represent 3 hex int digits.\n        // maxDecimalFractionPartDigitCount = {Hex:4|Oct:3|Bin:1} * otherBaseFractionPartDigitCount\n        // Therefore using 4 * the number of digits of str will always be enough.\n        if (isFloat) x = divide(x, divisor, len * 4);\n        // Multiply by the binary exponent part if present.\n        if (p) x = x.times(Math.abs(p) < 54 ? mathpow(2, p) : Decimal.pow(2, p));\n        external = true;\n        return x;\n    }\n    /*\r\n   * sin(x) = x - x^3/3! + x^5/5! - ...\r\n   * |x| < pi/2\r\n   *\r\n   */ function sine(Ctor, x) {\n        var k, len = x.d.length;\n        if (len < 3) {\n            return x.isZero() ? x : taylorSeries(Ctor, 2, x, x);\n        }\n        // Argument reduction: sin(5x) = 16*sin^5(x) - 20*sin^3(x) + 5*sin(x)\n        // i.e. sin(x) = 16*sin^5(x/5) - 20*sin^3(x/5) + 5*sin(x/5)\n        // and  sin(x) = sin(x/5)(5 + sin^2(x/5)(16sin^2(x/5) - 20))\n        // Estimate the optimum number of times to use the argument reduction.\n        k = 1.4 * Math.sqrt(len);\n        k = k > 16 ? 16 : k | 0;\n        x = x.times(1 / tinyPow(5, k));\n        x = taylorSeries(Ctor, 2, x, x);\n        // Reverse argument reduction\n        var sin2_x, d5 = new Ctor(5), d16 = new Ctor(16), d20 = new Ctor(20);\n        for(; k--;){\n            sin2_x = x.times(x);\n            x = x.times(d5.plus(sin2_x.times(d16.times(sin2_x).minus(d20))));\n        }\n        return x;\n    }\n    // Calculate Taylor series for `cos`, `cosh`, `sin` and `sinh`.\n    function taylorSeries(Ctor, n, x, y, isHyperbolic) {\n        var j, t, u, x2, i = 1, pr = Ctor.precision, k = Math.ceil(pr / LOG_BASE);\n        external = false;\n        x2 = x.times(x);\n        u = new Ctor(y);\n        for(;;){\n            t = divide(u.times(x2), new Ctor(n++ * n++), pr, 1);\n            u = isHyperbolic ? y.plus(t) : y.minus(t);\n            y = divide(t.times(x2), new Ctor(n++ * n++), pr, 1);\n            t = u.plus(y);\n            if (t.d[k] !== void 0) {\n                for(j = k; t.d[j] === u.d[j] && j--;);\n                if (j == -1) break;\n            }\n            j = u;\n            u = y;\n            y = t;\n            t = j;\n            i++;\n        }\n        external = true;\n        t.d.length = k + 1;\n        return t;\n    }\n    // Exponent e must be positive and non-zero.\n    function tinyPow(b, e) {\n        var n = b;\n        while(--e)n *= b;\n        return n;\n    }\n    // Return the absolute value of `x` reduced to less than or equal to half pi.\n    function toLessThanHalfPi(Ctor, x) {\n        var t, isNeg = x.s < 0, pi = getPi(Ctor, Ctor.precision, 1), halfPi = pi.times(0.5);\n        x = x.abs();\n        if (x.lte(halfPi)) {\n            quadrant = isNeg ? 4 : 1;\n            return x;\n        }\n        t = x.divToInt(pi);\n        if (t.isZero()) {\n            quadrant = isNeg ? 3 : 2;\n        } else {\n            x = x.minus(t.times(pi));\n            // 0 <= x < pi\n            if (x.lte(halfPi)) {\n                quadrant = isOdd(t) ? isNeg ? 2 : 3 : isNeg ? 4 : 1;\n                return x;\n            }\n            quadrant = isOdd(t) ? isNeg ? 1 : 4 : isNeg ? 3 : 2;\n        }\n        return x.minus(pi).abs();\n    }\n    /*\r\n   * Return the value of Decimal `x` as a string in base `baseOut`.\r\n   *\r\n   * If the optional `sd` argument is present include a binary exponent suffix.\r\n   */ function toStringBinary(x, baseOut, sd, rm) {\n        var base, e, i, k, len, roundUp, str, xd, y, Ctor = x.constructor, isExp = sd !== void 0;\n        if (isExp) {\n            checkInt32(sd, 1, MAX_DIGITS);\n            if (rm === void 0) rm = Ctor.rounding;\n            else checkInt32(rm, 0, 8);\n        } else {\n            sd = Ctor.precision;\n            rm = Ctor.rounding;\n        }\n        if (!x.isFinite()) {\n            str = nonFiniteToString(x);\n        } else {\n            str = finiteToString(x);\n            i = str.indexOf(\".\");\n            // Use exponential notation according to `toExpPos` and `toExpNeg`? No, but if required:\n            // maxBinaryExponent = floor((decimalExponent + 1) * log[2](10))\n            // minBinaryExponent = floor(decimalExponent * log[2](10))\n            // log[2](10) = 3.321928094887362347870319429489390175864\n            if (isExp) {\n                base = 2;\n                if (baseOut == 16) {\n                    sd = sd * 4 - 3;\n                } else if (baseOut == 8) {\n                    sd = sd * 3 - 2;\n                }\n            } else {\n                base = baseOut;\n            }\n            // Convert the number as an integer then divide the result by its base raised to a power such\n            // that the fraction part will be restored.\n            // Non-integer.\n            if (i >= 0) {\n                str = str.replace(\".\", \"\");\n                y = new Ctor(1);\n                y.e = str.length - i;\n                y.d = convertBase(finiteToString(y), 10, base);\n                y.e = y.d.length;\n            }\n            xd = convertBase(str, 10, base);\n            e = len = xd.length;\n            // Remove trailing zeros.\n            for(; xd[--len] == 0;)xd.pop();\n            if (!xd[0]) {\n                str = isExp ? \"0p+0\" : \"0\";\n            } else {\n                if (i < 0) {\n                    e--;\n                } else {\n                    x = new Ctor(x);\n                    x.d = xd;\n                    x.e = e;\n                    x = divide(x, y, sd, rm, 0, base);\n                    xd = x.d;\n                    e = x.e;\n                    roundUp = inexact;\n                }\n                // The rounding digit, i.e. the digit after the digit that may be rounded up.\n                i = xd[sd];\n                k = base / 2;\n                roundUp = roundUp || xd[sd + 1] !== void 0;\n                roundUp = rm < 4 ? (i !== void 0 || roundUp) && (rm === 0 || rm === (x.s < 0 ? 3 : 2)) : i > k || i === k && (rm === 4 || roundUp || rm === 6 && xd[sd - 1] & 1 || rm === (x.s < 0 ? 8 : 7));\n                xd.length = sd;\n                if (roundUp) {\n                    // Rounding up may mean the previous digit has to be rounded up and so on.\n                    for(; ++xd[--sd] > base - 1;){\n                        xd[sd] = 0;\n                        if (!sd) {\n                            ++e;\n                            xd.unshift(1);\n                        }\n                    }\n                }\n                // Determine trailing zeros.\n                for(len = xd.length; !xd[len - 1]; --len);\n                // E.g. [4, 11, 15] becomes 4bf.\n                for(i = 0, str = \"\"; i < len; i++)str += NUMERALS.charAt(xd[i]);\n                // Add binary exponent suffix?\n                if (isExp) {\n                    if (len > 1) {\n                        if (baseOut == 16 || baseOut == 8) {\n                            i = baseOut == 16 ? 4 : 3;\n                            for(--len; len % i; len++)str += \"0\";\n                            xd = convertBase(str, base, baseOut);\n                            for(len = xd.length; !xd[len - 1]; --len);\n                            // xd[0] will always be be 1\n                            for(i = 1, str = \"1.\"; i < len; i++)str += NUMERALS.charAt(xd[i]);\n                        } else {\n                            str = str.charAt(0) + \".\" + str.slice(1);\n                        }\n                    }\n                    str = str + (e < 0 ? \"p\" : \"p+\") + e;\n                } else if (e < 0) {\n                    for(; ++e;)str = \"0\" + str;\n                    str = \"0.\" + str;\n                } else {\n                    if (++e > len) for(e -= len; e--;)str += \"0\";\n                    else if (e < len) str = str.slice(0, e) + \".\" + str.slice(e);\n                }\n            }\n            str = (baseOut == 16 ? \"0x\" : baseOut == 2 ? \"0b\" : baseOut == 8 ? \"0o\" : \"\") + str;\n        }\n        return x.s < 0 ? \"-\" + str : str;\n    }\n    // Does not strip trailing zeros.\n    function truncate(arr, len) {\n        if (arr.length > len) {\n            arr.length = len;\n            return true;\n        }\n    }\n    // Decimal methods\n    /*\r\n   *  abs\r\n   *  acos\r\n   *  acosh\r\n   *  add\r\n   *  asin\r\n   *  asinh\r\n   *  atan\r\n   *  atanh\r\n   *  atan2\r\n   *  cbrt\r\n   *  ceil\r\n   *  clamp\r\n   *  clone\r\n   *  config\r\n   *  cos\r\n   *  cosh\r\n   *  div\r\n   *  exp\r\n   *  floor\r\n   *  hypot\r\n   *  ln\r\n   *  log\r\n   *  log2\r\n   *  log10\r\n   *  max\r\n   *  min\r\n   *  mod\r\n   *  mul\r\n   *  pow\r\n   *  random\r\n   *  round\r\n   *  set\r\n   *  sign\r\n   *  sin\r\n   *  sinh\r\n   *  sqrt\r\n   *  sub\r\n   *  sum\r\n   *  tan\r\n   *  tanh\r\n   *  trunc\r\n   */ /*\r\n   * Return a new Decimal whose value is the absolute value of `x`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function abs(x) {\n        return new this(x).abs();\n    }\n    /*\r\n   * Return a new Decimal whose value is the arccosine in radians of `x`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function acos(x) {\n        return new this(x).acos();\n    }\n    /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic cosine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal} A value in radians.\r\n   *\r\n   */ function acosh(x) {\n        return new this(x).acosh();\n    }\n    /*\r\n   * Return a new Decimal whose value is the sum of `x` and `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   * y {number|string|bigint|Decimal}\r\n   *\r\n   */ function add(x, y) {\n        return new this(x).plus(y);\n    }\n    /*\r\n   * Return a new Decimal whose value is the arcsine in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function asin(x) {\n        return new this(x).asin();\n    }\n    /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic sine of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal} A value in radians.\r\n   *\r\n   */ function asinh(x) {\n        return new this(x).asinh();\n    }\n    /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function atan(x) {\n        return new this(x).atan();\n    }\n    /*\r\n   * Return a new Decimal whose value is the inverse of the hyperbolic tangent of `x`, rounded to\r\n   * `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal} A value in radians.\r\n   *\r\n   */ function atanh(x) {\n        return new this(x).atanh();\n    }\n    /*\r\n   * Return a new Decimal whose value is the arctangent in radians of `y/x` in the range -pi to pi\r\n   * (inclusive), rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * Domain: [-Infinity, Infinity]\r\n   * Range: [-pi, pi]\r\n   *\r\n   * y {number|string|bigint|Decimal} The y-coordinate.\r\n   * x {number|string|bigint|Decimal} The x-coordinate.\r\n   *\r\n   * atan2(±0, -0)               = ±pi\r\n   * atan2(±0, +0)               = ±0\r\n   * atan2(±0, -x)               = ±pi for x > 0\r\n   * atan2(±0, x)                = ±0 for x > 0\r\n   * atan2(-y, ±0)               = -pi/2 for y > 0\r\n   * atan2(y, ±0)                = pi/2 for y > 0\r\n   * atan2(±y, -Infinity)        = ±pi for finite y > 0\r\n   * atan2(±y, +Infinity)        = ±0 for finite y > 0\r\n   * atan2(±Infinity, x)         = ±pi/2 for finite x\r\n   * atan2(±Infinity, -Infinity) = ±3*pi/4\r\n   * atan2(±Infinity, +Infinity) = ±pi/4\r\n   * atan2(NaN, x) = NaN\r\n   * atan2(y, NaN) = NaN\r\n   *\r\n   */ function atan2(y, x) {\n        y = new this(y);\n        x = new this(x);\n        var r, pr = this.precision, rm = this.rounding, wpr = pr + 4;\n        // Either NaN\n        if (!y.s || !x.s) {\n            r = new this(NaN);\n        // Both ±Infinity\n        } else if (!y.d && !x.d) {\n            r = getPi(this, wpr, 1).times(x.s > 0 ? 0.25 : 0.75);\n            r.s = y.s;\n        // x is ±Infinity or y is ±0\n        } else if (!x.d || y.isZero()) {\n            r = x.s < 0 ? getPi(this, pr, rm) : new this(0);\n            r.s = y.s;\n        // y is ±Infinity or x is ±0\n        } else if (!y.d || x.isZero()) {\n            r = getPi(this, wpr, 1).times(0.5);\n            r.s = y.s;\n        // Both non-zero and finite\n        } else if (x.s < 0) {\n            this.precision = wpr;\n            this.rounding = 1;\n            r = this.atan(divide(y, x, wpr, 1));\n            x = getPi(this, wpr, 1);\n            this.precision = pr;\n            this.rounding = rm;\n            r = y.s < 0 ? r.minus(x) : r.plus(x);\n        } else {\n            r = this.atan(divide(y, x, wpr, 1));\n        }\n        return r;\n    }\n    /*\r\n   * Return a new Decimal whose value is the cube root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function cbrt(x) {\n        return new this(x).cbrt();\n    }\n    /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using `ROUND_CEIL`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function ceil(x) {\n        return finalise(x = new this(x), x.e + 1, 2);\n    }\n    /*\r\n   * Return a new Decimal whose value is `x` clamped to the range delineated by `min` and `max`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   * min {number|string|bigint|Decimal}\r\n   * max {number|string|bigint|Decimal}\r\n   *\r\n   */ function clamp(x, min, max) {\n        return new this(x).clamp(min, max);\n    }\n    /*\r\n   * Configure global settings for a Decimal constructor.\r\n   *\r\n   * `obj` is an object with one or more of the following properties,\r\n   *\r\n   *   precision  {number}\r\n   *   rounding   {number}\r\n   *   toExpNeg   {number}\r\n   *   toExpPos   {number}\r\n   *   maxE       {number}\r\n   *   minE       {number}\r\n   *   modulo     {number}\r\n   *   crypto     {boolean|number}\r\n   *   defaults   {true}\r\n   *\r\n   * E.g. Decimal.config({ precision: 20, rounding: 4 })\r\n   *\r\n   */ function config(obj) {\n        if (!obj || typeof obj !== \"object\") throw Error(decimalError + \"Object expected\");\n        var i, p, v, useDefaults = obj.defaults === true, ps = [\n            \"precision\",\n            1,\n            MAX_DIGITS,\n            \"rounding\",\n            0,\n            8,\n            \"toExpNeg\",\n            -EXP_LIMIT,\n            0,\n            \"toExpPos\",\n            0,\n            EXP_LIMIT,\n            \"maxE\",\n            0,\n            EXP_LIMIT,\n            \"minE\",\n            -EXP_LIMIT,\n            0,\n            \"modulo\",\n            0,\n            9\n        ];\n        for(i = 0; i < ps.length; i += 3){\n            if (p = ps[i], useDefaults) this[p] = DEFAULTS[p];\n            if ((v = obj[p]) !== void 0) {\n                if (mathfloor(v) === v && v >= ps[i + 1] && v <= ps[i + 2]) this[p] = v;\n                else throw Error(invalidArgument + p + \": \" + v);\n            }\n        }\n        if (p = \"crypto\", useDefaults) this[p] = DEFAULTS[p];\n        if ((v = obj[p]) !== void 0) {\n            if (v === true || v === false || v === 0 || v === 1) {\n                if (v) {\n                    if (typeof crypto != \"undefined\" && crypto && (crypto.getRandomValues || crypto.randomBytes)) {\n                        this[p] = true;\n                    } else {\n                        throw Error(cryptoUnavailable);\n                    }\n                } else {\n                    this[p] = false;\n                }\n            } else {\n                throw Error(invalidArgument + p + \": \" + v);\n            }\n        }\n        return this;\n    }\n    /*\r\n   * Return a new Decimal whose value is the cosine of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal} A value in radians.\r\n   *\r\n   */ function cos(x) {\n        return new this(x).cos();\n    }\n    /*\r\n   * Return a new Decimal whose value is the hyperbolic cosine of `x`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal} A value in radians.\r\n   *\r\n   */ function cosh(x) {\n        return new this(x).cosh();\n    }\n    /*\r\n   * Create and return a Decimal constructor with the same configuration properties as this Decimal\r\n   * constructor.\r\n   *\r\n   */ function clone(obj) {\n        var i, p, ps;\n        /*\r\n     * The Decimal constructor and exported function.\r\n     * Return a new Decimal instance.\r\n     *\r\n     * v {number|string|bigint|Decimal} A numeric value.\r\n     *\r\n     */ function Decimal(v) {\n            var e, i, t, x = this;\n            // Decimal called without new.\n            if (!(x instanceof Decimal)) return new Decimal(v);\n            // Retain a reference to this Decimal constructor, and shadow Decimal.prototype.constructor\n            // which points to Object.\n            x.constructor = Decimal;\n            if (isDecimalInstance(v)) {\n                x.s = v.s;\n                if (external) {\n                    if (!v.d || v.e > Decimal.maxE) {\n                        // Infinity.\n                        x.e = NaN;\n                        x.d = null;\n                    } else if (v.e < Decimal.minE) {\n                        // Zero.\n                        x.e = 0;\n                        x.d = [\n                            0\n                        ];\n                    } else {\n                        x.e = v.e;\n                        x.d = v.d.slice();\n                    }\n                } else {\n                    x.e = v.e;\n                    x.d = v.d ? v.d.slice() : v.d;\n                }\n                return;\n            }\n            t = typeof v;\n            if (t === \"number\") {\n                if (v === 0) {\n                    x.s = 1 / v < 0 ? -1 : 1;\n                    x.e = 0;\n                    x.d = [\n                        0\n                    ];\n                    return;\n                }\n                if (v < 0) {\n                    v = -v;\n                    x.s = -1;\n                } else {\n                    x.s = 1;\n                }\n                // Fast path for small integers.\n                if (v === ~~v && v < 1e7) {\n                    for(e = 0, i = v; i >= 10; i /= 10)e++;\n                    if (external) {\n                        if (e > Decimal.maxE) {\n                            x.e = NaN;\n                            x.d = null;\n                        } else if (e < Decimal.minE) {\n                            x.e = 0;\n                            x.d = [\n                                0\n                            ];\n                        } else {\n                            x.e = e;\n                            x.d = [\n                                v\n                            ];\n                        }\n                    } else {\n                        x.e = e;\n                        x.d = [\n                            v\n                        ];\n                    }\n                    return;\n                }\n                // Infinity or NaN?\n                if (v * 0 !== 0) {\n                    if (!v) x.s = NaN;\n                    x.e = NaN;\n                    x.d = null;\n                    return;\n                }\n                return parseDecimal(x, v.toString());\n            }\n            if (t === \"string\") {\n                if ((i = v.charCodeAt(0)) === 45) {\n                    v = v.slice(1);\n                    x.s = -1;\n                } else {\n                    if (i === 43) v = v.slice(1); // plus sign\n                    x.s = 1;\n                }\n                return isDecimal.test(v) ? parseDecimal(x, v) : parseOther(x, v);\n            }\n            if (t === \"bigint\") {\n                if (v < 0) {\n                    v = -v;\n                    x.s = -1;\n                } else {\n                    x.s = 1;\n                }\n                return parseDecimal(x, v.toString());\n            }\n            throw Error(invalidArgument + v);\n        }\n        Decimal.prototype = P;\n        Decimal.ROUND_UP = 0;\n        Decimal.ROUND_DOWN = 1;\n        Decimal.ROUND_CEIL = 2;\n        Decimal.ROUND_FLOOR = 3;\n        Decimal.ROUND_HALF_UP = 4;\n        Decimal.ROUND_HALF_DOWN = 5;\n        Decimal.ROUND_HALF_EVEN = 6;\n        Decimal.ROUND_HALF_CEIL = 7;\n        Decimal.ROUND_HALF_FLOOR = 8;\n        Decimal.EUCLID = 9;\n        Decimal.config = Decimal.set = config;\n        Decimal.clone = clone;\n        Decimal.isDecimal = isDecimalInstance;\n        Decimal.abs = abs;\n        Decimal.acos = acos;\n        Decimal.acosh = acosh; // ES6\n        Decimal.add = add;\n        Decimal.asin = asin;\n        Decimal.asinh = asinh; // ES6\n        Decimal.atan = atan;\n        Decimal.atanh = atanh; // ES6\n        Decimal.atan2 = atan2;\n        Decimal.cbrt = cbrt; // ES6\n        Decimal.ceil = ceil;\n        Decimal.clamp = clamp;\n        Decimal.cos = cos;\n        Decimal.cosh = cosh; // ES6\n        Decimal.div = div;\n        Decimal.exp = exp;\n        Decimal.floor = floor;\n        Decimal.hypot = hypot; // ES6\n        Decimal.ln = ln;\n        Decimal.log = log;\n        Decimal.log10 = log10; // ES6\n        Decimal.log2 = log2; // ES6\n        Decimal.max = max;\n        Decimal.min = min;\n        Decimal.mod = mod;\n        Decimal.mul = mul;\n        Decimal.pow = pow;\n        Decimal.random = random;\n        Decimal.round = round;\n        Decimal.sign = sign; // ES6\n        Decimal.sin = sin;\n        Decimal.sinh = sinh; // ES6\n        Decimal.sqrt = sqrt;\n        Decimal.sub = sub;\n        Decimal.sum = sum;\n        Decimal.tan = tan;\n        Decimal.tanh = tanh; // ES6\n        Decimal.trunc = trunc; // ES6\n        if (obj === void 0) obj = {};\n        if (obj) {\n            if (obj.defaults !== true) {\n                ps = [\n                    \"precision\",\n                    \"rounding\",\n                    \"toExpNeg\",\n                    \"toExpPos\",\n                    \"maxE\",\n                    \"minE\",\n                    \"modulo\",\n                    \"crypto\"\n                ];\n                for(i = 0; i < ps.length;)if (!obj.hasOwnProperty(p = ps[i++])) obj[p] = this[p];\n            }\n        }\n        Decimal.config(obj);\n        return Decimal;\n    }\n    /*\r\n   * Return a new Decimal whose value is `x` divided by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   * y {number|string|bigint|Decimal}\r\n   *\r\n   */ function div(x, y) {\n        return new this(x).div(y);\n    }\n    /*\r\n   * Return a new Decimal whose value is the natural exponential of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal} The power to which to raise the base of the natural log.\r\n   *\r\n   */ function exp(x) {\n        return new this(x).exp();\n    }\n    /*\r\n   * Return a new Decimal whose value is `x` round to an integer using `ROUND_FLOOR`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function floor(x) {\n        return finalise(x = new this(x), x.e + 1, 3);\n    }\n    /*\r\n   * Return a new Decimal whose value is the square root of the sum of the squares of the arguments,\r\n   * rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * hypot(a, b, ...) = sqrt(a^2 + b^2 + ...)\r\n   *\r\n   * arguments {number|string|bigint|Decimal}\r\n   *\r\n   */ function hypot() {\n        var i, n, t = new this(0);\n        external = false;\n        for(i = 0; i < arguments.length;){\n            n = new this(arguments[i++]);\n            if (!n.d) {\n                if (n.s) {\n                    external = true;\n                    return new this(1 / 0);\n                }\n                t = n;\n            } else if (t.d) {\n                t = t.plus(n.times(n));\n            }\n        }\n        external = true;\n        return t.sqrt();\n    }\n    /*\r\n   * Return true if object is a Decimal instance (where Decimal is any Decimal constructor),\r\n   * otherwise return false.\r\n   *\r\n   */ function isDecimalInstance(obj) {\n        return obj instanceof Decimal || obj && obj.toStringTag === tag || false;\n    }\n    /*\r\n   * Return a new Decimal whose value is the natural logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function ln(x) {\n        return new this(x).ln();\n    }\n    /*\r\n   * Return a new Decimal whose value is the log of `x` to the base `y`, or to base 10 if no base\r\n   * is specified, rounded to `precision` significant digits using rounding mode `rounding`.\r\n   *\r\n   * log[y](x)\r\n   *\r\n   * x {number|string|bigint|Decimal} The argument of the logarithm.\r\n   * y {number|string|bigint|Decimal} The base of the logarithm.\r\n   *\r\n   */ function log(x, y) {\n        return new this(x).log(y);\n    }\n    /*\r\n   * Return a new Decimal whose value is the base 2 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function log2(x) {\n        return new this(x).log(2);\n    }\n    /*\r\n   * Return a new Decimal whose value is the base 10 logarithm of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function log10(x) {\n        return new this(x).log(10);\n    }\n    /*\r\n   * Return a new Decimal whose value is the maximum of the arguments.\r\n   *\r\n   * arguments {number|string|bigint|Decimal}\r\n   *\r\n   */ function max() {\n        return maxOrMin(this, arguments, -1);\n    }\n    /*\r\n   * Return a new Decimal whose value is the minimum of the arguments.\r\n   *\r\n   * arguments {number|string|bigint|Decimal}\r\n   *\r\n   */ function min() {\n        return maxOrMin(this, arguments, 1);\n    }\n    /*\r\n   * Return a new Decimal whose value is `x` modulo `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   * y {number|string|bigint|Decimal}\r\n   *\r\n   */ function mod(x, y) {\n        return new this(x).mod(y);\n    }\n    /*\r\n   * Return a new Decimal whose value is `x` multiplied by `y`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   * y {number|string|bigint|Decimal}\r\n   *\r\n   */ function mul(x, y) {\n        return new this(x).mul(y);\n    }\n    /*\r\n   * Return a new Decimal whose value is `x` raised to the power `y`, rounded to precision\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal} The base.\r\n   * y {number|string|bigint|Decimal} The exponent.\r\n   *\r\n   */ function pow(x, y) {\n        return new this(x).pow(y);\n    }\n    /*\r\n   * Returns a new Decimal with a random value equal to or greater than 0 and less than 1, and with\r\n   * `sd`, or `Decimal.precision` if `sd` is omitted, significant digits (or less if trailing zeros\r\n   * are produced).\r\n   *\r\n   * [sd] {number} Significant digits. Integer, 0 to MAX_DIGITS inclusive.\r\n   *\r\n   */ function random(sd) {\n        var d, e, k, n, i = 0, r = new this(1), rd = [];\n        if (sd === void 0) sd = this.precision;\n        else checkInt32(sd, 1, MAX_DIGITS);\n        k = Math.ceil(sd / LOG_BASE);\n        if (!this.crypto) {\n            for(; i < k;)rd[i++] = Math.random() * 1e7 | 0;\n        // Browsers supporting crypto.getRandomValues.\n        } else if (crypto.getRandomValues) {\n            d = crypto.getRandomValues(new Uint32Array(k));\n            for(; i < k;){\n                n = d[i];\n                // 0 <= n < 4294967296\n                // Probability n >= 4.29e9, is 4967296 / 4294967296 = 0.00116 (1 in 865).\n                if (n >= 4.29e9) {\n                    d[i] = crypto.getRandomValues(new Uint32Array(1))[0];\n                } else {\n                    // 0 <= n <= 4289999999\n                    // 0 <= (n % 1e7) <= 9999999\n                    rd[i++] = n % 1e7;\n                }\n            }\n        // Node.js supporting crypto.randomBytes.\n        } else if (crypto.randomBytes) {\n            // buffer\n            d = crypto.randomBytes(k *= 4);\n            for(; i < k;){\n                // 0 <= n < 2147483648\n                n = d[i] + (d[i + 1] << 8) + (d[i + 2] << 16) + ((d[i + 3] & 0x7f) << 24);\n                // Probability n >= 2.14e9, is 7483648 / 2147483648 = 0.0035 (1 in 286).\n                if (n >= 2.14e9) {\n                    crypto.randomBytes(4).copy(d, i);\n                } else {\n                    // 0 <= n <= 2139999999\n                    // 0 <= (n % 1e7) <= 9999999\n                    rd.push(n % 1e7);\n                    i += 4;\n                }\n            }\n            i = k / 4;\n        } else {\n            throw Error(cryptoUnavailable);\n        }\n        k = rd[--i];\n        sd %= LOG_BASE;\n        // Convert trailing digits to zeros according to sd.\n        if (k && sd) {\n            n = mathpow(10, LOG_BASE - sd);\n            rd[i] = (k / n | 0) * n;\n        }\n        // Remove trailing words which are zero.\n        for(; rd[i] === 0; i--)rd.pop();\n        // Zero?\n        if (i < 0) {\n            e = 0;\n            rd = [\n                0\n            ];\n        } else {\n            e = -1;\n            // Remove leading words which are zero and adjust exponent accordingly.\n            for(; rd[0] === 0; e -= LOG_BASE)rd.shift();\n            // Count the digits of the first word of rd to determine leading zeros.\n            for(k = 1, n = rd[0]; n >= 10; n /= 10)k++;\n            // Adjust the exponent for leading zeros of the first word of rd.\n            if (k < LOG_BASE) e -= LOG_BASE - k;\n        }\n        r.e = e;\n        r.d = rd;\n        return r;\n    }\n    /*\r\n   * Return a new Decimal whose value is `x` rounded to an integer using rounding mode `rounding`.\r\n   *\r\n   * To emulate `Math.round`, set rounding to 7 (ROUND_HALF_CEIL).\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function round(x) {\n        return finalise(x = new this(x), x.e + 1, this.rounding);\n    }\n    /*\r\n   * Return\r\n   *   1    if x > 0,\r\n   *  -1    if x < 0,\r\n   *   0    if x is 0,\r\n   *  -0    if x is -0,\r\n   *   NaN  otherwise\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function sign(x) {\n        x = new this(x);\n        return x.d ? x.d[0] ? x.s : 0 * x.s : x.s || NaN;\n    }\n    /*\r\n   * Return a new Decimal whose value is the sine of `x`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal} A value in radians.\r\n   *\r\n   */ function sin(x) {\n        return new this(x).sin();\n    }\n    /*\r\n   * Return a new Decimal whose value is the hyperbolic sine of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal} A value in radians.\r\n   *\r\n   */ function sinh(x) {\n        return new this(x).sinh();\n    }\n    /*\r\n   * Return a new Decimal whose value is the square root of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function sqrt(x) {\n        return new this(x).sqrt();\n    }\n    /*\r\n   * Return a new Decimal whose value is `x` minus `y`, rounded to `precision` significant digits\r\n   * using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   * y {number|string|bigint|Decimal}\r\n   *\r\n   */ function sub(x, y) {\n        return new this(x).sub(y);\n    }\n    /*\r\n   * Return a new Decimal whose value is the sum of the arguments, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * Only the result is rounded, not the intermediate calculations.\r\n   *\r\n   * arguments {number|string|bigint|Decimal}\r\n   *\r\n   */ function sum() {\n        var i = 0, args = arguments, x = new this(args[i]);\n        external = false;\n        for(; x.s && ++i < args.length;)x = x.plus(args[i]);\n        external = true;\n        return finalise(x, this.precision, this.rounding);\n    }\n    /*\r\n   * Return a new Decimal whose value is the tangent of `x`, rounded to `precision` significant\r\n   * digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal} A value in radians.\r\n   *\r\n   */ function tan(x) {\n        return new this(x).tan();\n    }\n    /*\r\n   * Return a new Decimal whose value is the hyperbolic tangent of `x`, rounded to `precision`\r\n   * significant digits using rounding mode `rounding`.\r\n   *\r\n   * x {number|string|bigint|Decimal} A value in radians.\r\n   *\r\n   */ function tanh(x) {\n        return new this(x).tanh();\n    }\n    /*\r\n   * Return a new Decimal whose value is `x` truncated to an integer.\r\n   *\r\n   * x {number|string|bigint|Decimal}\r\n   *\r\n   */ function trunc(x) {\n        return finalise(x = new this(x), x.e + 1, 1);\n    }\n    // Create and configure initial Decimal constructor.\n    Decimal = clone(DEFAULTS);\n    Decimal.prototype.constructor = Decimal;\n    Decimal[\"default\"] = Decimal.Decimal = Decimal;\n    // Create the internal constants from their string values.\n    LN10 = new Decimal(LN10);\n    PI = new Decimal(PI);\n    // Export.\n    // AMD.\n    if (true) {\n        !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {\n            return Decimal;\n        }).call(exports, __webpack_require__, exports, module),\n\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n    // Node and other environments that support module.exports.\n    } else {}\n})(this);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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TSxJQUFJQSxFQUFFbUQsSUFBSSxDQUFDaUwsSUFBSSxDQUFDbE4sRUFBRTtRQUNwRDNDLFdBQVc7UUFFWCxPQUFPNEIsU0FBU0gsR0FBRyxJQUFJLENBQUNyQyxTQUFTLEVBQUUsSUFBSSxDQUFDQyxRQUFRO0lBQ2xEO0lBR0E7Ozs7OztHQU1DLEdBQ0QsU0FBU3lMLElBQUlySixDQUFDO1FBQ1osT0FBTyxJQUFJLElBQUksQ0FBQ0EsR0FBR3FKLEdBQUc7SUFDeEI7SUFHQTs7Ozs7O0dBTUMsR0FDRCxTQUFTbEUsS0FBS25GLENBQUM7UUFDYixPQUFPLElBQUksSUFBSSxDQUFDQSxHQUFHbUYsSUFBSTtJQUN6QjtJQUdBOzs7OztHQUtDLEdBQ0QsU0FBU2dHLE1BQU1uTCxDQUFDO1FBQ2QsT0FBT0csU0FBU0gsSUFBSSxJQUFJLElBQUksQ0FBQ0EsSUFBSUEsRUFBRUssQ0FBQyxHQUFHLEdBQUc7SUFDNUM7SUFHQSxvREFBb0Q7SUFDcERsQyxVQUFVZ1MsTUFBTXpTO0lBQ2hCUyxRQUFRa1MsU0FBUyxDQUFDcFEsV0FBVyxHQUFHOUI7SUFDaENBLE9BQU8sQ0FBQyxVQUFVLEdBQUdBLFFBQVFBLE9BQU8sR0FBR0E7SUFFdkMsMERBQTBEO0lBQzFEWCxPQUFPLElBQUlXLFFBQVFYO0lBQ25CQyxLQUFLLElBQUlVLFFBQVFWO0lBR2pCLFVBQVU7SUFHVixPQUFPO0lBQ1AsSUFBSSxJQUF5QyxFQUFFO1FBQzdDZ1UsbUNBQU87WUFDTCxPQUFPdFQ7UUFDVCxDQUFDO0FBQUEsa0dBQUM7SUFFSiwyREFBMkQ7SUFDM0QsT0FBTyxFQXFCTjtBQUNILEdBQUcsSUFBSSIsInNvdXJjZXMiOlsid2VicGFjazovL3BwdHgtZWRpdG9yLy4vbm9kZV9tb2R1bGVzL2RlY2ltYWwuanMvZGVjaW1hbC5qcz9hZWRhIl0sInNvdXJjZXNDb250ZW50IjpbIjsoZnVuY3Rpb24gKGdsb2JhbFNjb3BlKSB7XHJcbiAgJ3VzZSBzdHJpY3QnO1xyXG5cclxuXHJcbiAgLyohXHJcbiAgICogIGRlY2ltYWwuanMgdjEwLjYuMFxyXG4gICAqICBBbiBhcmJpdHJhcnktcHJlY2lzaW9uIERlY2ltYWwgdHlwZSBmb3IgSmF2YVNjcmlwdC5cclxuICAgKiAgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvZGVjaW1hbC5qc1xyXG4gICAqICBDb3B5cmlnaHQgKGMpIDIwMjUgTWljaGFlbCBNY2xhdWdobGluIDxNOGNoODhsQGdtYWlsLmNvbT5cclxuICAgKiAgTUlUIExpY2VuY2VcclxuICAgKi9cclxuXHJcblxyXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICBFRElUQUJMRSBERUZBVUxUUyAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tIC8vXHJcblxyXG5cclxuICAgIC8vIFRoZSBtYXhpbXVtIGV4cG9uZW50IG1hZ25pdHVkZS5cclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgYHRvRXhwTmVnYCwgYHRvRXhwUG9zYCwgYG1pbkVgIGFuZCBgbWF4RWAuXHJcbiAgdmFyIEVYUF9MSU1JVCA9IDllMTUsICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gOWUxNVxyXG5cclxuICAgIC8vIFRoZSBsaW1pdCBvbiB0aGUgdmFsdWUgb2YgYHByZWNpc2lvbmAsIGFuZCBvbiB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGFyZ3VtZW50IHRvXHJcbiAgICAvLyBgdG9EZWNpbWFsUGxhY2VzYCwgYHRvRXhwb25lbnRpYWxgLCBgdG9GaXhlZGAsIGB0b1ByZWNpc2lvbmAgYW5kIGB0b1NpZ25pZmljYW50RGlnaXRzYC5cclxuICAgIE1BWF9ESUdJVFMgPSAxZTksICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byAxZTlcclxuXHJcbiAgICAvLyBCYXNlIGNvbnZlcnNpb24gYWxwaGFiZXQuXHJcbiAgICBOVU1FUkFMUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJyxcclxuXHJcbiAgICAvLyBUaGUgbmF0dXJhbCBsb2dhcml0aG0gb2YgMTAgKDEwMjUgZGlnaXRzKS5cclxuICAgIExOMTAgPSAnMi4zMDI1ODUwOTI5OTQwNDU2ODQwMTc5OTE0NTQ2ODQzNjQyMDc2MDExMDE0ODg2Mjg3NzI5NzYwMzMzMjc5MDA5Njc1NzI2MDk2NzczNTI0ODAyMzU5OTcyMDUwODk1OTgyOTgzNDE5Njc3ODQwNDIyODYyNDg2MzM0MDk1MjU0NjUwODI4MDY3NTY2NjYyODczNjkwOTg3ODE2ODk0ODI5MDcyMDgzMjU1NTQ2ODA4NDM3OTk4OTQ4MjYyMzMxOTg1MjgzOTM1MDUzMDg5NjUzNzc3MzI2Mjg4NDYxNjMzNjYyMjIyODc2OTgyMTk4ODY3NDY1NDM2Njc0NzQ0MDQyNDMyNzQzNjUxNTUwNDg5MzQzMTQ5MzkzOTE0Nzk2MTk0MDQ0MDAyMjIxMDUxMDE3MTQxNzQ4MDAzNjg4MDg0MDEyNjQ3MDgwNjg1NTY3NzQzMjE2MjI4MzU1MjIwMTE0ODA0NjYzNzE1NjU5MTIxMzczNDUwNzQ3ODU2OTQ3NjgzNDYzNjE2NzkyMTAxODA2NDQ1MDcwNjQ4MDAwMjc3NTAyNjg0OTE2NzQ2NTUwNTg2ODU2OTM1NjczNDIwNjcwNTgxMTM2NDI5MjI0NTU0NDA1NzU4OTI1NzI0MjA4MjQxMzE0Njk1Njg5MDE2NzU4OTQwMjU2Nzc2MzExMzU2OTE5MjkyMDMzMzc2NTg3MTQxNjYwMjMwMTA1NzAzMDg5NjM0NTcyMDc1NDQwMzcwODQ3NDY5OTQwMTY4MjY5MjgyODA4NDgxMTg0Mjg5MzE0ODQ4NTI0OTQ4NjQ0ODcxOTI3ODA5Njc2MjcxMjc1Nzc1Mzk3MDI3NjY4NjA1OTUyNDk2NzE2Njc0MTgzNDg1NzA0NDIyNTA3MTk3OTY1MDA0NzE0OTUxMDUwNDkyMjE0Nzc2NTY3NjM2OTM4NjYyOTc2OTc5NTIyMTEwNzE4MjY0NTQ5NzM0NzcyNjYyNDI1NzA5NDI5MzIyNTgyNzk4NTAyNTg1NTA5Nzg1MjY1MzgzMjA3NjA2NzI2MzE3MTY0MzA5NTA1OTk1MDg3ODA3NTIzNzEwMzMzMTAxMTk3ODU3NTQ3MzMxNTQxNDIxODA4NDI3NTQzODYzNTkxNzc4MTE3MDU0MzA5ODI3NDgyMzg1MDQ1NjQ4MDE5MDk1NjEwMjk5MjkxODI0MzE4MjM3NTI1MzU3NzA5NzUwNTM5NTY1MTg3Njk3NTEwMzc0OTcwODg4NjkyMTgwMjA1MTg5MzM5NTA3MjM4NTM5MjA1MTQ0NjM0MTk3MjY1Mjg3Mjg2OTY1MTEwODYyNTcxNDkyMTk4ODQ5OTc4NzQ4ODczNzcxMzQ1Njg2MjA5MTY3MDU4JyxcclxuXHJcbiAgICAvLyBQaSAoMTAyNSBkaWdpdHMpLlxyXG4gICAgUEkgPSAnMy4xNDE1OTI2NTM1ODk3OTMyMzg0NjI2NDMzODMyNzk1MDI4ODQxOTcxNjkzOTkzNzUxMDU4MjA5NzQ5NDQ1OTIzMDc4MTY0MDYyODYyMDg5OTg2MjgwMzQ4MjUzNDIxMTcwNjc5ODIxNDgwODY1MTMyODIzMDY2NDcwOTM4NDQ2MDk1NTA1ODIyMzE3MjUzNTk0MDgxMjg0ODExMTc0NTAyODQxMDI3MDE5Mzg1MjExMDU1NTk2NDQ2MjI5NDg5NTQ5MzAzODE5NjQ0Mjg4MTA5NzU2NjU5MzM0NDYxMjg0NzU2NDgyMzM3ODY3ODMxNjUyNzEyMDE5MDkxNDU2NDg1NjY5MjM0NjAzNDg2MTA0NTQzMjY2NDgyMTMzOTM2MDcyNjAyNDkxNDEyNzM3MjQ1ODcwMDY2MDYzMTU1ODgxNzQ4ODE1MjA5MjA5NjI4MjkyNTQwOTE3MTUzNjQzNjc4OTI1OTAzNjAwMTEzMzA1MzA1NDg4MjA0NjY1MjEzODQxNDY5NTE5NDE1MTE2MDk0MzMwNTcyNzAzNjU3NTk1OTE5NTMwOTIxODYxMTczODE5MzI2MTE3OTMxMDUxMTg1NDgwNzQ0NjIzNzk5NjI3NDk1NjczNTE4ODU3NTI3MjQ4OTEyMjc5MzgxODMwMTE5NDkxMjk4MzM2NzMzNjI0NDA2NTY2NDMwODYwMjEzOTQ5NDYzOTUyMjQ3MzcxOTA3MDIxNzk4NjA5NDM3MDI3NzA1MzkyMTcxNzYyOTMxNzY3NTIzODQ2NzQ4MTg0Njc2Njk0MDUxMzIwMDA1NjgxMjcxNDUyNjM1NjA4Mjc3ODU3NzEzNDI3NTc3ODk2MDkxNzM2MzcxNzg3MjE0Njg0NDA5MDEyMjQ5NTM0MzAxNDY1NDk1ODUzNzEwNTA3OTIyNzk2ODkyNTg5MjM1NDIwMTk5NTYxMTIxMjkwMjE5NjA4NjQwMzQ0MTgxNTk4MTM2Mjk3NzQ3NzEzMDk5NjA1MTg3MDcyMTEzNDk5OTk5OTgzNzI5NzgwNDk5NTEwNTk3MzE3MzI4MTYwOTYzMTg1OTUwMjQ0NTk0NTUzNDY5MDgzMDI2NDI1MjIzMDgyNTMzNDQ2ODUwMzUyNjE5MzExODgxNzEwMTAwMDMxMzc4Mzg3NTI4ODY1ODc1MzMyMDgzODE0MjA2MTcxNzc2NjkxNDczMDM1OTgyNTM0OTA0Mjg3NTU0Njg3MzExNTk1NjI4NjM4ODIzNTM3ODc1OTM3NTE5NTc3ODE4NTc3ODA1MzIxNzEyMjY4MDY2MTMwMDE5Mjc4NzY2MTExOTU5MDkyMTY0MjAxOTg5MzgwOTUyNTcyMDEwNjU0ODU4NjMyNzg5JyxcclxuXHJcblxyXG4gICAgLy8gVGhlIGluaXRpYWwgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIG9mIHRoZSBEZWNpbWFsIGNvbnN0cnVjdG9yLlxyXG4gICAgREVGQVVMVFMgPSB7XHJcblxyXG4gICAgICAvLyBUaGVzZSB2YWx1ZXMgbXVzdCBiZSBpbnRlZ2VycyB3aXRoaW4gdGhlIHN0YXRlZCByYW5nZXMgKGluY2x1c2l2ZSkuXHJcbiAgICAgIC8vIE1vc3Qgb2YgdGhlc2UgdmFsdWVzIGNhbiBiZSBjaGFuZ2VkIGF0IHJ1bi10aW1lIHVzaW5nIHRoZSBgRGVjaW1hbC5jb25maWdgIG1ldGhvZC5cclxuXHJcbiAgICAgIC8vIFRoZSBtYXhpbXVtIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHJlc3VsdCBvZiBhIGNhbGN1bGF0aW9uIG9yIGJhc2UgY29udmVyc2lvbi5cclxuICAgICAgLy8gRS5nLiBgRGVjaW1hbC5jb25maWcoeyBwcmVjaXNpb246IDIwIH0pO2BcclxuICAgICAgcHJlY2lzaW9uOiAyMCwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMSB0byBNQVhfRElHSVRTXHJcblxyXG4gICAgICAvLyBUaGUgcm91bmRpbmcgbW9kZSB1c2VkIHdoZW4gcm91bmRpbmcgdG8gYHByZWNpc2lvbmAuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFJPVU5EX1VQICAgICAgICAgMCBBd2F5IGZyb20gemVyby5cclxuICAgICAgLy8gUk9VTkRfRE9XTiAgICAgICAxIFRvd2FyZHMgemVyby5cclxuICAgICAgLy8gUk9VTkRfQ0VJTCAgICAgICAyIFRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBST1VORF9GTE9PUiAgICAgIDMgVG93YXJkcyAtSW5maW5pdHkuXHJcbiAgICAgIC8vIFJPVU5EX0hBTEZfVVAgICAgNCBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgdXAuXHJcbiAgICAgIC8vIFJPVU5EX0hBTEZfRE9XTiAgNSBUb3dhcmRzIG5lYXJlc3QgbmVpZ2hib3VyLiBJZiBlcXVpZGlzdGFudCwgZG93bi5cclxuICAgICAgLy8gUk9VTkRfSEFMRl9FVkVOICA2IFRvd2FyZHMgbmVhcmVzdCBuZWlnaGJvdXIuIElmIGVxdWlkaXN0YW50LCB0b3dhcmRzIGV2ZW4gbmVpZ2hib3VyLlxyXG4gICAgICAvLyBST1VORF9IQUxGX0NFSUwgIDcgVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgK0luZmluaXR5LlxyXG4gICAgICAvLyBST1VORF9IQUxGX0ZMT09SIDggVG93YXJkcyBuZWFyZXN0IG5laWdoYm91ci4gSWYgZXF1aWRpc3RhbnQsIHRvd2FyZHMgLUluZmluaXR5LlxyXG4gICAgICAvL1xyXG4gICAgICAvLyBFLmcuXHJcbiAgICAgIC8vIGBEZWNpbWFsLnJvdW5kaW5nID0gNDtgXHJcbiAgICAgIC8vIGBEZWNpbWFsLnJvdW5kaW5nID0gRGVjaW1hbC5ST1VORF9IQUxGX1VQO2BcclxuICAgICAgcm91bmRpbmc6IDQsICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA4XHJcblxyXG4gICAgICAvLyBUaGUgbW9kdWxvIG1vZGUgdXNlZCB3aGVuIGNhbGN1bGF0aW5nIHRoZSBtb2R1bHVzOiBhIG1vZCBuLlxyXG4gICAgICAvLyBUaGUgcXVvdGllbnQgKHEgPSBhIC8gbikgaXMgY2FsY3VsYXRlZCBhY2NvcmRpbmcgdG8gdGhlIGNvcnJlc3BvbmRpbmcgcm91bmRpbmcgbW9kZS5cclxuICAgICAgLy8gVGhlIHJlbWFpbmRlciAocikgaXMgY2FsY3VsYXRlZCBhczogciA9IGEgLSBuICogcS5cclxuICAgICAgLy9cclxuICAgICAgLy8gVVAgICAgICAgICAwIFRoZSByZW1haW5kZXIgaXMgcG9zaXRpdmUgaWYgdGhlIGRpdmlkZW5kIGlzIG5lZ2F0aXZlLCBlbHNlIGlzIG5lZ2F0aXZlLlxyXG4gICAgICAvLyBET1dOICAgICAgIDEgVGhlIHJlbWFpbmRlciBoYXMgdGhlIHNhbWUgc2lnbiBhcyB0aGUgZGl2aWRlbmQgKEphdmFTY3JpcHQgJSkuXHJcbiAgICAgIC8vIEZMT09SICAgICAgMyBUaGUgcmVtYWluZGVyIGhhcyB0aGUgc2FtZSBzaWduIGFzIHRoZSBkaXZpc29yIChQeXRob24gJSkuXHJcbiAgICAgIC8vIEhBTEZfRVZFTiAgNiBUaGUgSUVFRSA3NTQgcmVtYWluZGVyIGZ1bmN0aW9uLlxyXG4gICAgICAvLyBFVUNMSUQgICAgIDkgRXVjbGlkaWFuIGRpdmlzaW9uLiBxID0gc2lnbihuKSAqIGZsb29yKGEgLyBhYnMobikpLiBBbHdheXMgcG9zaXRpdmUuXHJcbiAgICAgIC8vXHJcbiAgICAgIC8vIFRydW5jYXRlZCBkaXZpc2lvbiAoMSksIGZsb29yZWQgZGl2aXNpb24gKDMpLCB0aGUgSUVFRSA3NTQgcmVtYWluZGVyICg2KSwgYW5kIEV1Y2xpZGlhblxyXG4gICAgICAvLyBkaXZpc2lvbiAoOSkgYXJlIGNvbW1vbmx5IHVzZWQgZm9yIHRoZSBtb2R1bHVzIG9wZXJhdGlvbi4gVGhlIG90aGVyIHJvdW5kaW5nIG1vZGVzIGNhbiBhbHNvXHJcbiAgICAgIC8vIGJlIHVzZWQsIGJ1dCB0aGV5IG1heSBub3QgZ2l2ZSB1c2VmdWwgcmVzdWx0cy5cclxuICAgICAgbW9kdWxvOiAxLCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byA5XHJcblxyXG4gICAgICAvLyBUaGUgZXhwb25lbnQgdmFsdWUgYXQgYW5kIGJlbmVhdGggd2hpY2ggYHRvU3RyaW5nYCByZXR1cm5zIGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAgICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IC03XHJcbiAgICAgIHRvRXhwTmVnOiAtNywgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIDAgdG8gLUVYUF9MSU1JVFxyXG5cclxuICAgICAgLy8gVGhlIGV4cG9uZW50IHZhbHVlIGF0IGFuZCBhYm92ZSB3aGljaCBgdG9TdHJpbmdgIHJldHVybnMgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICAgIC8vIEphdmFTY3JpcHQgbnVtYmVyczogMjFcclxuICAgICAgdG9FeHBQb3M6ICAyMSwgICAgICAgICAgICAgICAgICAgICAgICAgLy8gMCB0byBFWFBfTElNSVRcclxuXHJcbiAgICAgIC8vIFRoZSBtaW5pbXVtIGV4cG9uZW50IHZhbHVlLCBiZW5lYXRoIHdoaWNoIHVuZGVyZmxvdyB0byB6ZXJvIG9jY3Vycy5cclxuICAgICAgLy8gSmF2YVNjcmlwdCBudW1iZXJzOiAtMzI0ICAoNWUtMzI0KVxyXG4gICAgICBtaW5FOiAtRVhQX0xJTUlULCAgICAgICAgICAgICAgICAgICAgICAvLyAtMSB0byAtRVhQX0xJTUlUXHJcblxyXG4gICAgICAvLyBUaGUgbWF4aW11bSBleHBvbmVudCB2YWx1ZSwgYWJvdmUgd2hpY2ggb3ZlcmZsb3cgdG8gSW5maW5pdHkgb2NjdXJzLlxyXG4gICAgICAvLyBKYXZhU2NyaXB0IG51bWJlcnM6IDMwOCAgKDEuNzk3NjkzMTM0ODYyMzE1N2UrMzA4KVxyXG4gICAgICBtYXhFOiBFWFBfTElNSVQsICAgICAgICAgICAgICAgICAgICAgICAvLyAxIHRvIEVYUF9MSU1JVFxyXG5cclxuICAgICAgLy8gV2hldGhlciB0byB1c2UgY3J5cHRvZ3JhcGhpY2FsbHktc2VjdXJlIHJhbmRvbSBudW1iZXIgZ2VuZXJhdGlvbiwgaWYgYXZhaWxhYmxlLlxyXG4gICAgICBjcnlwdG86IGZhbHNlICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlL2ZhbHNlXHJcbiAgICB9LFxyXG5cclxuXHJcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gRU5EIE9GIEVESVRBQkxFIERFRkFVTFRTIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gLy9cclxuXHJcblxyXG4gICAgRGVjaW1hbCwgaW5leGFjdCwgbm9Db25mbGljdCwgcXVhZHJhbnQsXHJcbiAgICBleHRlcm5hbCA9IHRydWUsXHJcblxyXG4gICAgZGVjaW1hbEVycm9yID0gJ1tEZWNpbWFsRXJyb3JdICcsXHJcbiAgICBpbnZhbGlkQXJndW1lbnQgPSBkZWNpbWFsRXJyb3IgKyAnSW52YWxpZCBhcmd1bWVudDogJyxcclxuICAgIHByZWNpc2lvbkxpbWl0RXhjZWVkZWQgPSBkZWNpbWFsRXJyb3IgKyAnUHJlY2lzaW9uIGxpbWl0IGV4Y2VlZGVkJyxcclxuICAgIGNyeXB0b1VuYXZhaWxhYmxlID0gZGVjaW1hbEVycm9yICsgJ2NyeXB0byB1bmF2YWlsYWJsZScsXHJcbiAgICB0YWcgPSAnW29iamVjdCBEZWNpbWFsXScsXHJcblxyXG4gICAgbWF0aGZsb29yID0gTWF0aC5mbG9vcixcclxuICAgIG1hdGhwb3cgPSBNYXRoLnBvdyxcclxuXHJcbiAgICBpc0JpbmFyeSA9IC9eMGIoWzAxXSsoXFwuWzAxXSopP3xcXC5bMDFdKykocFsrLV0/XFxkKyk/JC9pLFxyXG4gICAgaXNIZXggPSAvXjB4KFswLTlhLWZdKyhcXC5bMC05YS1mXSopP3xcXC5bMC05YS1mXSspKHBbKy1dP1xcZCspPyQvaSxcclxuICAgIGlzT2N0YWwgPSAvXjBvKFswLTddKyhcXC5bMC03XSopP3xcXC5bMC03XSspKHBbKy1dP1xcZCspPyQvaSxcclxuICAgIGlzRGVjaW1hbCA9IC9eKFxcZCsoXFwuXFxkKik/fFxcLlxcZCspKGVbKy1dP1xcZCspPyQvaSxcclxuXHJcbiAgICBCQVNFID0gMWU3LFxyXG4gICAgTE9HX0JBU0UgPSA3LFxyXG4gICAgTUFYX1NBRkVfSU5URUdFUiA9IDkwMDcxOTkyNTQ3NDA5OTEsXHJcblxyXG4gICAgTE4xMF9QUkVDSVNJT04gPSBMTjEwLmxlbmd0aCAtIDEsXHJcbiAgICBQSV9QUkVDSVNJT04gPSBQSS5sZW5ndGggLSAxLFxyXG5cclxuICAgIC8vIERlY2ltYWwucHJvdG90eXBlIG9iamVjdFxyXG4gICAgUCA9IHsgdG9TdHJpbmdUYWc6IHRhZyB9O1xyXG5cclxuXHJcbiAgLy8gRGVjaW1hbCBwcm90b3R5cGUgbWV0aG9kc1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgYWJzb2x1dGVWYWx1ZSAgICAgICAgICAgICBhYnNcclxuICAgKiAgY2VpbFxyXG4gICAqICBjbGFtcGVkVG8gICAgICAgICAgICAgICAgIGNsYW1wXHJcbiAgICogIGNvbXBhcmVkVG8gICAgICAgICAgICAgICAgY21wXHJcbiAgICogIGNvc2luZSAgICAgICAgICAgICAgICAgICAgY29zXHJcbiAgICogIGN1YmVSb290ICAgICAgICAgICAgICAgICAgY2JydFxyXG4gICAqICBkZWNpbWFsUGxhY2VzICAgICAgICAgICAgIGRwXHJcbiAgICogIGRpdmlkZWRCeSAgICAgICAgICAgICAgICAgZGl2XHJcbiAgICogIGRpdmlkZWRUb0ludGVnZXJCeSAgICAgICAgZGl2VG9JbnRcclxuICAgKiAgZXF1YWxzICAgICAgICAgICAgICAgICAgICBlcVxyXG4gICAqICBmbG9vclxyXG4gICAqICBncmVhdGVyVGhhbiAgICAgICAgICAgICAgIGd0XHJcbiAgICogIGdyZWF0ZXJUaGFuT3JFcXVhbFRvICAgICAgZ3RlXHJcbiAgICogIGh5cGVyYm9saWNDb3NpbmUgICAgICAgICAgY29zaFxyXG4gICAqICBoeXBlcmJvbGljU2luZSAgICAgICAgICAgIHNpbmhcclxuICAgKiAgaHlwZXJib2xpY1RhbmdlbnQgICAgICAgICB0YW5oXHJcbiAgICogIGludmVyc2VDb3NpbmUgICAgICAgICAgICAgYWNvc1xyXG4gICAqICBpbnZlcnNlSHlwZXJib2xpY0Nvc2luZSAgIGFjb3NoXHJcbiAgICogIGludmVyc2VIeXBlcmJvbGljU2luZSAgICAgYXNpbmhcclxuICAgKiAgaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50ICBhdGFuaFxyXG4gICAqICBpbnZlcnNlU2luZSAgICAgICAgICAgICAgIGFzaW5cclxuICAgKiAgaW52ZXJzZVRhbmdlbnQgICAgICAgICAgICBhdGFuXHJcbiAgICogIGlzRmluaXRlXHJcbiAgICogIGlzSW50ZWdlciAgICAgICAgICAgICAgICAgaXNJbnRcclxuICAgKiAgaXNOYU5cclxuICAgKiAgaXNOZWdhdGl2ZSAgICAgICAgICAgICAgICBpc05lZ1xyXG4gICAqICBpc1Bvc2l0aXZlICAgICAgICAgICAgICAgIGlzUG9zXHJcbiAgICogIGlzWmVyb1xyXG4gICAqICBsZXNzVGhhbiAgICAgICAgICAgICAgICAgIGx0XHJcbiAgICogIGxlc3NUaGFuT3JFcXVhbFRvICAgICAgICAgbHRlXHJcbiAgICogIGxvZ2FyaXRobSAgICAgICAgICAgICAgICAgbG9nXHJcbiAgICogIFttYXhpbXVtXSAgICAgICAgICAgICAgICAgW21heF1cclxuICAgKiAgW21pbmltdW1dICAgICAgICAgICAgICAgICBbbWluXVxyXG4gICAqICBtaW51cyAgICAgICAgICAgICAgICAgICAgIHN1YlxyXG4gICAqICBtb2R1bG8gICAgICAgICAgICAgICAgICAgIG1vZFxyXG4gICAqICBuYXR1cmFsRXhwb25lbnRpYWwgICAgICAgIGV4cFxyXG4gICAqICBuYXR1cmFsTG9nYXJpdGhtICAgICAgICAgIGxuXHJcbiAgICogIG5lZ2F0ZWQgICAgICAgICAgICAgICAgICAgbmVnXHJcbiAgICogIHBsdXMgICAgICAgICAgICAgICAgICAgICAgYWRkXHJcbiAgICogIHByZWNpc2lvbiAgICAgICAgICAgICAgICAgc2RcclxuICAgKiAgcm91bmRcclxuICAgKiAgc2luZSAgICAgICAgICAgICAgICAgICAgICBzaW5cclxuICAgKiAgc3F1YXJlUm9vdCAgICAgICAgICAgICAgICBzcXJ0XHJcbiAgICogIHRhbmdlbnQgICAgICAgICAgICAgICAgICAgdGFuXHJcbiAgICogIHRpbWVzICAgICAgICAgICAgICAgICAgICAgbXVsXHJcbiAgICogIHRvQmluYXJ5XHJcbiAgICogIHRvRGVjaW1hbFBsYWNlcyAgICAgICAgICAgdG9EUFxyXG4gICAqICB0b0V4cG9uZW50aWFsXHJcbiAgICogIHRvRml4ZWRcclxuICAgKiAgdG9GcmFjdGlvblxyXG4gICAqICB0b0hleGFkZWNpbWFsICAgICAgICAgICAgIHRvSGV4XHJcbiAgICogIHRvTmVhcmVzdFxyXG4gICAqICB0b051bWJlclxyXG4gICAqICB0b09jdGFsXHJcbiAgICogIHRvUG93ZXIgICAgICAgICAgICAgICAgICAgcG93XHJcbiAgICogIHRvUHJlY2lzaW9uXHJcbiAgICogIHRvU2lnbmlmaWNhbnREaWdpdHMgICAgICAgdG9TRFxyXG4gICAqICB0b1N0cmluZ1xyXG4gICAqICB0cnVuY2F0ZWQgICAgICAgICAgICAgICAgIHRydW5jXHJcbiAgICogIHZhbHVlT2YgICAgICAgICAgICAgICAgICAgdG9KU09OXHJcbiAgICovXHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmFic29sdXRlVmFsdWUgPSBQLmFicyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XHJcbiAgICBpZiAoeC5zIDwgMCkgeC5zID0gMTtcclxuICAgIHJldHVybiBmaW5hbGlzZSh4KTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSB3aG9sZSBudW1iZXIgaW4gdGhlXHJcbiAgICogZGlyZWN0aW9uIG9mIHBvc2l0aXZlIEluZmluaXR5LlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5jZWlsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAyKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGNsYW1wZWQgdG8gdGhlIHJhbmdlXHJcbiAgICogZGVsaW5lYXRlZCBieSBgbWluYCBhbmQgYG1heGAuXHJcbiAgICpcclxuICAgKiBtaW4ge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICogbWF4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5jbGFtcGVkVG8gPSBQLmNsYW1wID0gZnVuY3Rpb24gKG1pbiwgbWF4KSB7XHJcbiAgICB2YXIgayxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG4gICAgbWluID0gbmV3IEN0b3IobWluKTtcclxuICAgIG1heCA9IG5ldyBDdG9yKG1heCk7XHJcbiAgICBpZiAoIW1pbi5zIHx8ICFtYXgucykgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcbiAgICBpZiAobWluLmd0KG1heCkpIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIG1heCk7XHJcbiAgICBrID0geC5jbXAobWluKTtcclxuICAgIHJldHVybiBrIDwgMCA/IG1pbiA6IHguY21wKG1heCkgPiAwID8gbWF4IDogbmV3IEN0b3IoeCk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuXHJcbiAgICogICAxICAgIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgZ3JlYXRlciB0aGFuIHRoZSB2YWx1ZSBvZiBgeWAsXHJcbiAgICogIC0xICAgIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgbGVzcyB0aGFuIHRoZSB2YWx1ZSBvZiBgeWAsXHJcbiAgICogICAwICAgIGlmIHRoZXkgaGF2ZSB0aGUgc2FtZSB2YWx1ZSxcclxuICAgKiAgIE5hTiAgaWYgdGhlIHZhbHVlIG9mIGVpdGhlciBEZWNpbWFsIGlzIE5hTi5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuY29tcGFyZWRUbyA9IFAuY21wID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHZhciBpLCBqLCB4ZEwsIHlkTCxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIHhkID0geC5kLFxyXG4gICAgICB5ZCA9ICh5ID0gbmV3IHguY29uc3RydWN0b3IoeSkpLmQsXHJcbiAgICAgIHhzID0geC5zLFxyXG4gICAgICB5cyA9IHkucztcclxuXHJcbiAgICAvLyBFaXRoZXIgTmFOIG9yIMKxSW5maW5pdHk/XHJcbiAgICBpZiAoIXhkIHx8ICF5ZCkge1xyXG4gICAgICByZXR1cm4gIXhzIHx8ICF5cyA/IE5hTiA6IHhzICE9PSB5cyA/IHhzIDogeGQgPT09IHlkID8gMCA6ICF4ZCBeIHhzIDwgMCA/IDEgOiAtMTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFaXRoZXIgemVybz9cclxuICAgIGlmICgheGRbMF0gfHwgIXlkWzBdKSByZXR1cm4geGRbMF0gPyB4cyA6IHlkWzBdID8gLXlzIDogMDtcclxuXHJcbiAgICAvLyBTaWducyBkaWZmZXI/XHJcbiAgICBpZiAoeHMgIT09IHlzKSByZXR1cm4geHM7XHJcblxyXG4gICAgLy8gQ29tcGFyZSBleHBvbmVudHMuXHJcbiAgICBpZiAoeC5lICE9PSB5LmUpIHJldHVybiB4LmUgPiB5LmUgXiB4cyA8IDAgPyAxIDogLTE7XHJcblxyXG4gICAgeGRMID0geGQubGVuZ3RoO1xyXG4gICAgeWRMID0geWQubGVuZ3RoO1xyXG5cclxuICAgIC8vIENvbXBhcmUgZGlnaXQgYnkgZGlnaXQuXHJcbiAgICBmb3IgKGkgPSAwLCBqID0geGRMIDwgeWRMID8geGRMIDogeWRMOyBpIDwgajsgKytpKSB7XHJcbiAgICAgIGlmICh4ZFtpXSAhPT0geWRbaV0pIHJldHVybiB4ZFtpXSA+IHlkW2ldIF4geHMgPCAwID8gMSA6IC0xO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENvbXBhcmUgbGVuZ3Rocy5cclxuICAgIHJldHVybiB4ZEwgPT09IHlkTCA/IDAgOiB4ZEwgPiB5ZEwgXiB4cyA8IDAgPyAxIDogLTE7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGNvc2luZSBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqIFJhbmdlOiBbLTEsIDFdXHJcbiAgICpcclxuICAgKiBjb3MoMCkgICAgICAgICA9IDFcclxuICAgKiBjb3MoLTApICAgICAgICA9IDFcclxuICAgKiBjb3MoSW5maW5pdHkpICA9IE5hTlxyXG4gICAqIGNvcygtSW5maW5pdHkpID0gTmFOXHJcbiAgICogY29zKE5hTikgICAgICAgPSBOYU5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuY29zaW5lID0gUC5jb3MgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHIsIHJtLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKCF4LmQpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAgIC8vIGNvcygwKSA9IGNvcygtMCkgPSAxXHJcbiAgICBpZiAoIXguZFswXSkgcmV0dXJuIG5ldyBDdG9yKDEpO1xyXG5cclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoeC5lLCB4LnNkKCkpICsgTE9HX0JBU0U7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgICB4ID0gY29zaW5lKEN0b3IsIHRvTGVzc1RoYW5IYWxmUGkoQ3RvciwgeCkpO1xyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHI7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gcm07XHJcblxyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHF1YWRyYW50ID09IDIgfHwgcXVhZHJhbnQgPT0gMyA/IHgubmVnKCkgOiB4LCBwciwgcm0sIHRydWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGN1YmUgcm9vdCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLCByb3VuZGVkIHRvXHJcbiAgICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqICBjYnJ0KDApICA9ICAwXHJcbiAgICogIGNicnQoLTApID0gLTBcclxuICAgKiAgY2JydCgxKSAgPSAgMVxyXG4gICAqICBjYnJ0KC0xKSA9IC0xXHJcbiAgICogIGNicnQoTikgID0gIE5cclxuICAgKiAgY2JydCgtSSkgPSAtSVxyXG4gICAqICBjYnJ0KEkpICA9ICBJXHJcbiAgICpcclxuICAgKiBNYXRoLmNicnQoeCkgPSAoeCA8IDAgPyAtTWF0aC5wb3coLXgsIDEvMykgOiBNYXRoLnBvdyh4LCAxLzMpKVxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5jdWJlUm9vdCA9IFAuY2JydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBlLCBtLCBuLCByLCByZXAsIHMsIHNkLCB0LCB0MywgdDNwbHVzeCxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gICAgLy8gSW5pdGlhbCBlc3RpbWF0ZS5cclxuICAgIHMgPSB4LnMgKiBtYXRocG93KHgucyAqIHgsIDEgLyAzKTtcclxuXHJcbiAgICAgLy8gTWF0aC5jYnJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgICAvLyBQYXNzIHggdG8gTWF0aC5wb3cgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICBpZiAoIXMgfHwgTWF0aC5hYnMocykgPT0gMSAvIDApIHtcclxuICAgICAgbiA9IGRpZ2l0c1RvU3RyaW5nKHguZCk7XHJcbiAgICAgIGUgPSB4LmU7XHJcblxyXG4gICAgICAvLyBBZGp1c3QgbiBleHBvbmVudCBzbyBpdCBpcyBhIG11bHRpcGxlIG9mIDMgYXdheSBmcm9tIHggZXhwb25lbnQuXHJcbiAgICAgIGlmIChzID0gKGUgLSBuLmxlbmd0aCArIDEpICUgMykgbiArPSAocyA9PSAxIHx8IHMgPT0gLTIgPyAnMCcgOiAnMDAnKTtcclxuICAgICAgcyA9IG1hdGhwb3cobiwgMSAvIDMpO1xyXG5cclxuICAgICAgLy8gUmFyZWx5LCBlIG1heSBiZSBvbmUgbGVzcyB0aGFuIHRoZSByZXN1bHQgZXhwb25lbnQgdmFsdWUuXHJcbiAgICAgIGUgPSBtYXRoZmxvb3IoKGUgKyAxKSAvIDMpIC0gKGUgJSAzID09IChlIDwgMCA/IC0xIDogMikpO1xyXG5cclxuICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByID0gbmV3IEN0b3Iobik7XHJcbiAgICAgIHIucyA9IHgucztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHIgPSBuZXcgQ3RvcihzLnRvU3RyaW5nKCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHNkID0gKGUgPSBDdG9yLnByZWNpc2lvbikgKyAzO1xyXG5cclxuICAgIC8vIEhhbGxleSdzIG1ldGhvZC5cclxuICAgIC8vIFRPRE8/IENvbXBhcmUgTmV3dG9uJ3MgbWV0aG9kLlxyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICB0ID0gcjtcclxuICAgICAgdDMgPSB0LnRpbWVzKHQpLnRpbWVzKHQpO1xyXG4gICAgICB0M3BsdXN4ID0gdDMucGx1cyh4KTtcclxuICAgICAgciA9IGRpdmlkZSh0M3BsdXN4LnBsdXMoeCkudGltZXModCksIHQzcGx1c3gucGx1cyh0MyksIHNkICsgMiwgMSk7XHJcblxyXG4gICAgICAvLyBUT0RPPyBSZXBsYWNlIHdpdGggZm9yLWxvb3AgYW5kIGNoZWNrUm91bmRpbmdEaWdpdHMuXHJcbiAgICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHNkKSA9PT0gKG4gPSBkaWdpdHNUb1N0cmluZyhyLmQpKS5zbGljZSgwLCBzZCkpIHtcclxuICAgICAgICBuID0gbi5zbGljZShzZCAtIDMsIHNkICsgMSk7XHJcblxyXG4gICAgICAgIC8vIFRoZSA0dGggcm91bmRpbmcgZGlnaXQgbWF5IGJlIGluIGVycm9yIGJ5IC0xIHNvIGlmIHRoZSA0IHJvdW5kaW5nIGRpZ2l0cyBhcmUgOTk5OSBvciA0OTk5XHJcbiAgICAgICAgLy8gLCBpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnksIGNvbnRpbnVlIHRoZSBpdGVyYXRpb24uXHJcbiAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGUgZXhhY3QgcmVzdWx0IGFzIHRoZVxyXG4gICAgICAgICAgLy8gbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgZmluYWxpc2UodCwgZSArIDEsIDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHQudGltZXModCkudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHNkICs9IDQ7XHJcbiAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBhbiBleGFjdCByZXN1bHQuXHJcbiAgICAgICAgICAvLyBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcclxuICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UociwgZSwgQ3Rvci5yb3VuZGluZywgbSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRoZSBudW1iZXIgb2YgZGVjaW1hbCBwbGFjZXMgb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuZGVjaW1hbFBsYWNlcyA9IFAuZHAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgdyxcclxuICAgICAgZCA9IHRoaXMuZCxcclxuICAgICAgbiA9IE5hTjtcclxuXHJcbiAgICBpZiAoZCkge1xyXG4gICAgICB3ID0gZC5sZW5ndGggLSAxO1xyXG4gICAgICBuID0gKHcgLSBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpKSAqIExPR19CQVNFO1xyXG5cclxuICAgICAgLy8gU3VidHJhY3QgdGhlIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvcyBvZiB0aGUgbGFzdCB3b3JkLlxyXG4gICAgICB3ID0gZFt3XTtcclxuICAgICAgaWYgKHcpIGZvciAoOyB3ICUgMTAgPT0gMDsgdyAvPSAxMCkgbi0tO1xyXG4gICAgICBpZiAobiA8IDApIG4gPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBuO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuIC8gMCA9IElcclxuICAgKiAgbiAvIE4gPSBOXHJcbiAgICogIG4gLyBJID0gMFxyXG4gICAqICAwIC8gbiA9IDBcclxuICAgKiAgMCAvIDAgPSBOXHJcbiAgICogIDAgLyBOID0gTlxyXG4gICAqICAwIC8gSSA9IDBcclxuICAgKiAgTiAvIG4gPSBOXHJcbiAgICogIE4gLyAwID0gTlxyXG4gICAqICBOIC8gTiA9IE5cclxuICAgKiAgTiAvIEkgPSBOXHJcbiAgICogIEkgLyBuID0gSVxyXG4gICAqICBJIC8gMCA9IElcclxuICAgKiAgSSAvIE4gPSBOXHJcbiAgICogIEkgLyBJID0gTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBkaXZpZGVkIGJ5IGB5YCwgcm91bmRlZCB0b1xyXG4gICAqIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmRpdmlkZWRCeSA9IFAuZGl2ID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHJldHVybiBkaXZpZGUodGhpcywgbmV3IHRoaXMuY29uc3RydWN0b3IoeSkpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnRlZ2VyIHBhcnQgb2YgZGl2aWRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbFxyXG4gICAqIGJ5IHRoZSB2YWx1ZSBvZiBgeWAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuZGl2aWRlZFRvSW50ZWdlckJ5ID0gUC5kaXZUb0ludCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICB2YXIgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKGRpdmlkZSh4LCBuZXcgQ3Rvcih5KSwgMCwgMSwgMSksIEN0b3IucHJlY2lzaW9uLCBDdG9yLnJvdW5kaW5nKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBgeWAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmVxdWFscyA9IFAuZXEgPSBmdW5jdGlvbiAoeSkge1xyXG4gICAgcmV0dXJuIHRoaXMuY21wKHkpID09PSAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBhIHdob2xlIG51bWJlciBpbiB0aGVcclxuICAgKiBkaXJlY3Rpb24gb2YgbmVnYXRpdmUgSW5maW5pdHkuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmZsb29yID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKG5ldyB0aGlzLmNvbnN0cnVjdG9yKHRoaXMpLCB0aGlzLmUgKyAxLCAzKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGdyZWF0ZXIgdGhhbiB0aGUgdmFsdWUgb2YgYHlgLCBvdGhlcndpc2UgcmV0dXJuXHJcbiAgICogZmFsc2UuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmdyZWF0ZXJUaGFuID0gUC5ndCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbXAoeSkgPiAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvIHRoZSB2YWx1ZSBvZiBgeWAsXHJcbiAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuZ3JlYXRlclRoYW5PckVxdWFsVG8gPSBQLmd0ZSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICB2YXIgayA9IHRoaXMuY21wKHkpO1xyXG4gICAgcmV0dXJuIGsgPT0gMSB8fCBrID09PSAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiB0aGUgdmFsdWUgaW4gcmFkaWFucyBvZiB0aGlzXHJcbiAgICogRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAgICogUmFuZ2U6IFsxLCBJbmZpbml0eV1cclxuICAgKlxyXG4gICAqIGNvc2goeCkgPSAxICsgeF4yLzIhICsgeF40LzQhICsgeF42LzYhICsgLi4uXHJcbiAgICpcclxuICAgKiBjb3NoKDApICAgICAgICAgPSAxXHJcbiAgICogY29zaCgtMCkgICAgICAgID0gMVxyXG4gICAqIGNvc2goSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAgICogY29zaCgtSW5maW5pdHkpID0gSW5maW5pdHlcclxuICAgKiBjb3NoKE5hTikgICAgICAgPSBOYU5cclxuICAgKlxyXG4gICAqICB4ICAgICAgICB0aW1lIHRha2VuIChtcykgICByZXN1bHRcclxuICAgKiAxMDAwICAgICAgOSAgICAgICAgICAgICAgICAgOS44NTAzNTU1NzAwODUyMzQ5Njk0ZSs0MzNcclxuICAgKiAxMDAwMCAgICAgMjUgICAgICAgICAgICAgICAgNC40MDM0MDkxMTI4MzE0NjA3OTM2ZSs0MzQyXHJcbiAgICogMTAwMDAwICAgIDE3MSAgICAgICAgICAgICAgIDEuNDAzMzMxNjgwMjEzMDYxNTg5N2UrNDM0MjlcclxuICAgKiAxMDAwMDAwICAgMzgxNyAgICAgICAgICAgICAgMS41MTY2MDc2OTg0MDEwNDM3NzI1ZSs0MzQyOTRcclxuICAgKiAxMDAwMDAwMCAgYWJhbmRvbmVkIGFmdGVyIDIgbWludXRlIHdhaXRcclxuICAgKlxyXG4gICAqIFRPRE8/IENvbXBhcmUgcGVyZm9ybWFuY2Ugb2YgY29zaCh4KSA9IDAuNSAqIChleHAoeCkgKyBleHAoLXgpKVxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5oeXBlcmJvbGljQ29zaW5lID0gUC5jb3NoID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGssIG4sIHByLCBybSwgbGVuLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgIG9uZSA9IG5ldyBDdG9yKDEpO1xyXG5cclxuICAgIGlmICgheC5pc0Zpbml0ZSgpKSByZXR1cm4gbmV3IEN0b3IoeC5zID8gMSAvIDAgOiBOYU4pO1xyXG4gICAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBvbmU7XHJcblxyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyBNYXRoLm1heCh4LmUsIHguc2QoKSkgKyA0O1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcbiAgICBsZW4gPSB4LmQubGVuZ3RoO1xyXG5cclxuICAgIC8vIEFyZ3VtZW50IHJlZHVjdGlvbjogY29zKDR4KSA9IDEgLSA4Y29zXjIoeCkgKyA4Y29zXjQoeCkgKyAxXHJcbiAgICAvLyBpLmUuIGNvcyh4KSA9IDEgLSBjb3NeMih4LzQpKDggLSA4Y29zXjIoeC80KSlcclxuXHJcbiAgICAvLyBFc3RpbWF0ZSB0aGUgb3B0aW11bSBudW1iZXIgb2YgdGltZXMgdG8gdXNlIHRoZSBhcmd1bWVudCByZWR1Y3Rpb24uXHJcbiAgICAvLyBUT0RPPyBFc3RpbWF0aW9uIHJldXNlZCBmcm9tIGNvc2luZSgpIGFuZCBtYXkgbm90IGJlIG9wdGltYWwgaGVyZS5cclxuICAgIGlmIChsZW4gPCAzMikge1xyXG4gICAgICBrID0gTWF0aC5jZWlsKGxlbiAvIDMpO1xyXG4gICAgICBuID0gKDEgLyB0aW55UG93KDQsIGspKS50b1N0cmluZygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgayA9IDE2O1xyXG4gICAgICBuID0gJzIuMzI4MzA2NDM2NTM4Njk2Mjg5MDYyNWUtMTAnO1xyXG4gICAgfVxyXG5cclxuICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMSwgeC50aW1lcyhuKSwgbmV3IEN0b3IoMSksIHRydWUpO1xyXG5cclxuICAgIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgICB2YXIgY29zaDJfeCxcclxuICAgICAgaSA9IGssXHJcbiAgICAgIGQ4ID0gbmV3IEN0b3IoOCk7XHJcbiAgICBmb3IgKDsgaS0tOykge1xyXG4gICAgICBjb3NoMl94ID0geC50aW1lcyh4KTtcclxuICAgICAgeCA9IG9uZS5taW51cyhjb3NoMl94LnRpbWVzKGQ4Lm1pbnVzKGNvc2gyX3gudGltZXMoZDgpKSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZSh4LCBDdG9yLnByZWNpc2lvbiA9IHByLCBDdG9yLnJvdW5kaW5nID0gcm0sIHRydWUpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBoeXBlcmJvbGljIHNpbmUgb2YgdGhlIHZhbHVlIGluIHJhZGlhbnMgb2YgdGhpc1xyXG4gICAqIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqIFJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKlxyXG4gICAqIHNpbmgoeCkgPSB4ICsgeF4zLzMhICsgeF41LzUhICsgeF43LzchICsgLi4uXHJcbiAgICpcclxuICAgKiBzaW5oKDApICAgICAgICAgPSAwXHJcbiAgICogc2luaCgtMCkgICAgICAgID0gLTBcclxuICAgKiBzaW5oKEluZmluaXR5KSAgPSBJbmZpbml0eVxyXG4gICAqIHNpbmgoLUluZmluaXR5KSA9IC1JbmZpbml0eVxyXG4gICAqIHNpbmgoTmFOKSAgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICogeCAgICAgICAgdGltZSB0YWtlbiAobXMpXHJcbiAgICogMTAgICAgICAgMiBtc1xyXG4gICAqIDEwMCAgICAgIDUgbXNcclxuICAgKiAxMDAwICAgICAxNCBtc1xyXG4gICAqIDEwMDAwICAgIDgyIG1zXHJcbiAgICogMTAwMDAwICAgODg2IG1zICAgICAgICAgICAgMS40MDMzMzE2ODAyMTMwNjE1ODk3ZSs0MzQyOVxyXG4gICAqIDIwMDAwMCAgIDI2MTMgbXNcclxuICAgKiAzMDAwMDAgICA1NDA3IG1zXHJcbiAgICogNDAwMDAwICAgODgyNCBtc1xyXG4gICAqIDUwMDAwMCAgIDEzMDI2IG1zICAgICAgICAgIDguNzA4MDY0MzYxMjcxODA4NDEyOWUrMjE3MTQ2XHJcbiAgICogMTAwMDAwMCAgNDg1NDMgbXNcclxuICAgKlxyXG4gICAqIFRPRE8/IENvbXBhcmUgcGVyZm9ybWFuY2Ugb2Ygc2luaCh4KSA9IDAuNSAqIChleHAoeCkgLSBleHAoLXgpKVxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5oeXBlcmJvbGljU2luZSA9IFAuc2luaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBrLCBwciwgcm0sIGxlbixcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmICgheC5pc0Zpbml0ZSgpIHx8IHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KHguZSwgeC5zZCgpKSArIDQ7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuICAgIGxlbiA9IHguZC5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGxlbiA8IDMpIHtcclxuICAgICAgeCA9IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4LCB0cnVlKTtcclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBBbHRlcm5hdGl2ZSBhcmd1bWVudCByZWR1Y3Rpb246IHNpbmgoM3gpID0gc2luaCh4KSgzICsgNHNpbmheMih4KSlcclxuICAgICAgLy8gaS5lLiBzaW5oKHgpID0gc2luaCh4LzMpKDMgKyA0c2luaF4yKHgvMykpXHJcbiAgICAgIC8vIDMgbXVsdGlwbGljYXRpb25zIGFuZCAxIGFkZGl0aW9uXHJcblxyXG4gICAgICAvLyBBcmd1bWVudCByZWR1Y3Rpb246IHNpbmgoNXgpID0gc2luaCh4KSg1ICsgc2luaF4yKHgpKDIwICsgMTZzaW5oXjIoeCkpKVxyXG4gICAgICAvLyBpLmUuIHNpbmgoeCkgPSBzaW5oKHgvNSkoNSArIHNpbmheMih4LzUpKDIwICsgMTZzaW5oXjIoeC81KSkpXHJcbiAgICAgIC8vIDQgbXVsdGlwbGljYXRpb25zIGFuZCAyIGFkZGl0aW9uc1xyXG5cclxuICAgICAgLy8gRXN0aW1hdGUgdGhlIG9wdGltdW0gbnVtYmVyIG9mIHRpbWVzIHRvIHVzZSB0aGUgYXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gICAgICBrID0gMS40ICogTWF0aC5zcXJ0KGxlbik7XHJcbiAgICAgIGsgPSBrID4gMTYgPyAxNiA6IGsgfCAwO1xyXG5cclxuICAgICAgeCA9IHgudGltZXMoMSAvIHRpbnlQb3coNSwgaykpO1xyXG4gICAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgsIHRydWUpO1xyXG5cclxuICAgICAgLy8gUmV2ZXJzZSBhcmd1bWVudCByZWR1Y3Rpb25cclxuICAgICAgdmFyIHNpbmgyX3gsXHJcbiAgICAgICAgZDUgPSBuZXcgQ3Rvcig1KSxcclxuICAgICAgICBkMTYgPSBuZXcgQ3RvcigxNiksXHJcbiAgICAgICAgZDIwID0gbmV3IEN0b3IoMjApO1xyXG4gICAgICBmb3IgKDsgay0tOykge1xyXG4gICAgICAgIHNpbmgyX3ggPSB4LnRpbWVzKHgpO1xyXG4gICAgICAgIHggPSB4LnRpbWVzKGQ1LnBsdXMoc2luaDJfeC50aW1lcyhkMTYudGltZXMoc2luaDJfeCkucGx1cyhkMjApKSkpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtLCB0cnVlKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIHRoZSB2YWx1ZSBpbiByYWRpYW5zIG9mIHRoaXNcclxuICAgKiBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWy0xLCAxXVxyXG4gICAqXHJcbiAgICogdGFuaCh4KSA9IHNpbmgoeCkgLyBjb3NoKHgpXHJcbiAgICpcclxuICAgKiB0YW5oKDApICAgICAgICAgPSAwXHJcbiAgICogdGFuaCgtMCkgICAgICAgID0gLTBcclxuICAgKiB0YW5oKEluZmluaXR5KSAgPSAxXHJcbiAgICogdGFuaCgtSW5maW5pdHkpID0gLTFcclxuICAgKiB0YW5oKE5hTikgICAgICAgPSBOYU5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaHlwZXJib2xpY1RhbmdlbnQgPSBQLnRhbmggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHIsIHJtLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3Rvcih4LnMpO1xyXG4gICAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDc7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgICByZXR1cm4gZGl2aWRlKHguc2luaCgpLCB4LmNvc2goKSwgQ3Rvci5wcmVjaXNpb24gPSBwciwgQ3Rvci5yb3VuZGluZyA9IHJtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjY29zaW5lIChpbnZlcnNlIGNvc2luZSkgaW4gcmFkaWFucyBvZiB0aGUgdmFsdWUgb2ZcclxuICAgKiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstMSwgMV1cclxuICAgKiBSYW5nZTogWzAsIHBpXVxyXG4gICAqXHJcbiAgICogYWNvcyh4KSA9IHBpLzIgLSBhc2luKHgpXHJcbiAgICpcclxuICAgKiBhY29zKDApICAgICAgID0gcGkvMlxyXG4gICAqIGFjb3MoLTApICAgICAgPSBwaS8yXHJcbiAgICogYWNvcygxKSAgICAgICA9IDBcclxuICAgKiBhY29zKC0xKSAgICAgID0gcGlcclxuICAgKiBhY29zKDEvMikgICAgID0gcGkvM1xyXG4gICAqIGFjb3MoLTEvMikgICAgPSAyKnBpLzNcclxuICAgKiBhY29zKHx4fCA+IDEpID0gTmFOXHJcbiAgICogYWNvcyhOYU4pICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pbnZlcnNlQ29zaW5lID0gUC5hY29zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgayA9IHguYWJzKCkuY21wKDEpLFxyXG4gICAgICBwciA9IEN0b3IucHJlY2lzaW9uLFxyXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcblxyXG4gICAgaWYgKGsgIT09IC0xKSB7XHJcbiAgICAgIHJldHVybiBrID09PSAwXHJcbiAgICAgICAgLy8gfHh8IGlzIDFcclxuICAgICAgICA/IHguaXNOZWcoKSA/IGdldFBpKEN0b3IsIHByLCBybSkgOiBuZXcgQ3RvcigwKVxyXG4gICAgICAgIC8vIHx4fCA+IDEgb3IgeCBpcyBOYU5cclxuICAgICAgICA6IG5ldyBDdG9yKE5hTik7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xyXG5cclxuICAgIC8vIFRPRE8/IFNwZWNpYWwgY2FzZSBhY29zKDAuNSkgPSBwaS8zIGFuZCBhY29zKC0wLjUpID0gMipwaS8zXHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIDY7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL01pa2VNY2wvZGVjaW1hbC5qcy9wdWxsLzIxN1xyXG4gICAgeCA9IG5ldyBDdG9yKDEpLm1pbnVzKHgpLmRpdih4LnBsdXMoMSkpLnNxcnQoKS5hdGFuKCk7XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4geC50aW1lcygyKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyBjb3NpbmUgaW4gcmFkaWFucyBvZiB0aGVcclxuICAgKiB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFsxLCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWzAsIEluZmluaXR5XVxyXG4gICAqXHJcbiAgICogYWNvc2goeCkgPSBsbih4ICsgc3FydCh4XjIgLSAxKSlcclxuICAgKlxyXG4gICAqIGFjb3NoKHggPCAxKSAgICAgPSBOYU5cclxuICAgKiBhY29zaChOYU4pICAgICAgID0gTmFOXHJcbiAgICogYWNvc2goSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAgICogYWNvc2goLUluZmluaXR5KSA9IE5hTlxyXG4gICAqIGFjb3NoKDApICAgICAgICAgPSBOYU5cclxuICAgKiBhY29zaCgtMCkgICAgICAgID0gTmFOXHJcbiAgICogYWNvc2goMSkgICAgICAgICA9IDBcclxuICAgKiBhY29zaCgtMSkgICAgICAgID0gTmFOXHJcbiAgICpcclxuICAgKi9cclxuICBQLmludmVyc2VIeXBlcmJvbGljQ29zaW5lID0gUC5hY29zaCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwciwgcm0sXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoeC5sdGUoMSkpIHJldHVybiBuZXcgQ3Rvcih4LmVxKDEpID8gMCA6IE5hTik7XHJcbiAgICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgTWF0aC5tYXgoTWF0aC5hYnMoeC5lKSwgeC5zZCgpKSArIDQ7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gICAgeCA9IHgudGltZXMoeCkubWludXMoMSkuc3FydCgpLnBsdXMoeCk7XHJcblxyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4geC5sbigpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBoeXBlcmJvbGljIHNpbmUgaW4gcmFkaWFucyBvZiB0aGUgdmFsdWVcclxuICAgKiBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqIFJhbmdlOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKlxyXG4gICAqIGFzaW5oKHgpID0gbG4oeCArIHNxcnQoeF4yICsgMSkpXHJcbiAgICpcclxuICAgKiBhc2luaChOYU4pICAgICAgID0gTmFOXHJcbiAgICogYXNpbmgoSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAgICogYXNpbmgoLUluZmluaXR5KSA9IC1JbmZpbml0eVxyXG4gICAqIGFzaW5oKDApICAgICAgICAgPSAwXHJcbiAgICogYXNpbmgoLTApICAgICAgICA9IC0wXHJcbiAgICpcclxuICAgKi9cclxuICBQLmludmVyc2VIeXBlcmJvbGljU2luZSA9IFAuYXNpbmggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHIsIHJtLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKCF4LmlzRmluaXRlKCkgfHwgeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgMiAqIE1hdGgubWF4KE1hdGguYWJzKHguZSksIHguc2QoKSkgKyA2O1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICAgIHggPSB4LnRpbWVzKHgpLnBsdXMoMSkuc3FydCgpLnBsdXMoeCk7XHJcblxyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4geC5sbigpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBoeXBlcmJvbGljIHRhbmdlbnQgaW4gcmFkaWFucyBvZiB0aGVcclxuICAgKiB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstMSwgMV1cclxuICAgKiBSYW5nZTogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAgICpcclxuICAgKiBhdGFuaCh4KSA9IDAuNSAqIGxuKCgxICsgeCkgLyAoMSAtIHgpKVxyXG4gICAqXHJcbiAgICogYXRhbmgofHh8ID4gMSkgICA9IE5hTlxyXG4gICAqIGF0YW5oKE5hTikgICAgICAgPSBOYU5cclxuICAgKiBhdGFuaChJbmZpbml0eSkgID0gTmFOXHJcbiAgICogYXRhbmgoLUluZmluaXR5KSA9IE5hTlxyXG4gICAqIGF0YW5oKDApICAgICAgICAgPSAwXHJcbiAgICogYXRhbmgoLTApICAgICAgICA9IC0wXHJcbiAgICogYXRhbmgoMSkgICAgICAgICA9IEluZmluaXR5XHJcbiAgICogYXRhbmgoLTEpICAgICAgICA9IC1JbmZpbml0eVxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pbnZlcnNlSHlwZXJib2xpY1RhbmdlbnQgPSBQLmF0YW5oID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHByLCBybSwgd3ByLCB4c2QsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcbiAgICBpZiAoeC5lID49IDApIHJldHVybiBuZXcgQ3Rvcih4LmFicygpLmVxKDEpID8geC5zIC8gMCA6IHguaXNaZXJvKCkgPyB4IDogTmFOKTtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgeHNkID0geC5zZCgpO1xyXG5cclxuICAgIGlmIChNYXRoLm1heCh4c2QsIHByKSA8IDIgKiAteC5lIC0gMSkgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBwciwgcm0sIHRydWUpO1xyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uID0gd3ByID0geHNkIC0geC5lO1xyXG5cclxuICAgIHggPSBkaXZpZGUoeC5wbHVzKDEpLCBuZXcgQ3RvcigxKS5taW51cyh4KSwgd3ByICsgcHIsIDEpO1xyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyA0O1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gICAgeCA9IHgubG4oKTtcclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICAgIHJldHVybiB4LnRpbWVzKDAuNSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGFyY3NpbmUgKGludmVyc2Ugc2luZSkgaW4gcmFkaWFucyBvZiB0aGUgdmFsdWUgb2YgdGhpc1xyXG4gICAqIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqIFJhbmdlOiBbLXBpLzIsIHBpLzJdXHJcbiAgICpcclxuICAgKiBhc2luKHgpID0gMiphdGFuKHgvKDEgKyBzcXJ0KDEgLSB4XjIpKSlcclxuICAgKlxyXG4gICAqIGFzaW4oMCkgICAgICAgPSAwXHJcbiAgICogYXNpbigtMCkgICAgICA9IC0wXHJcbiAgICogYXNpbigxLzIpICAgICA9IHBpLzZcclxuICAgKiBhc2luKC0xLzIpICAgID0gLXBpLzZcclxuICAgKiBhc2luKDEpICAgICAgID0gcGkvMlxyXG4gICAqIGFzaW4oLTEpICAgICAgPSAtcGkvMlxyXG4gICAqIGFzaW4ofHh8ID4gMSkgPSBOYU5cclxuICAgKiBhc2luKE5hTikgICAgID0gTmFOXHJcbiAgICpcclxuICAgKiBUT0RPPyBDb21wYXJlIHBlcmZvcm1hbmNlIG9mIFRheWxvciBzZXJpZXMuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmludmVyc2VTaW5lID0gUC5hc2luID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIGhhbGZQaSwgayxcclxuICAgICAgcHIsIHJtLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICBrID0geC5hYnMoKS5jbXAoMSk7XHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICAgIGlmIChrICE9PSAtMSkge1xyXG5cclxuICAgICAgLy8gfHh8IGlzIDFcclxuICAgICAgaWYgKGsgPT09IDApIHtcclxuICAgICAgICBoYWxmUGkgPSBnZXRQaShDdG9yLCBwciArIDQsIHJtKS50aW1lcygwLjUpO1xyXG4gICAgICAgIGhhbGZQaS5zID0geC5zO1xyXG4gICAgICAgIHJldHVybiBoYWxmUGk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIHx4fCA+IDEgb3IgeCBpcyBOYU5cclxuICAgICAgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVE9ETz8gU3BlY2lhbCBjYXNlIGFzaW4oMS8yKSA9IHBpLzYgYW5kIGFzaW4oLTEvMikgPSAtcGkvNlxyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uID0gcHIgKyA2O1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gICAgeCA9IHguZGl2KG5ldyBDdG9yKDEpLm1pbnVzKHgudGltZXMoeCkpLnNxcnQoKS5wbHVzKDEpKS5hdGFuKCk7XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4geC50aW1lcygyKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjdGFuZ2VudCAoaW52ZXJzZSB0YW5nZW50KSBpbiByYWRpYW5zIG9mIHRoZSB2YWx1ZVxyXG4gICAqIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIERvbWFpbjogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAgICogUmFuZ2U6IFstcGkvMiwgcGkvMl1cclxuICAgKlxyXG4gICAqIGF0YW4oeCkgPSB4IC0geF4zLzMgKyB4XjUvNSAtIHheNy83ICsgLi4uXHJcbiAgICpcclxuICAgKiBhdGFuKDApICAgICAgICAgPSAwXHJcbiAgICogYXRhbigtMCkgICAgICAgID0gLTBcclxuICAgKiBhdGFuKDEpICAgICAgICAgPSBwaS80XHJcbiAgICogYXRhbigtMSkgICAgICAgID0gLXBpLzRcclxuICAgKiBhdGFuKEluZmluaXR5KSAgPSBwaS8yXHJcbiAgICogYXRhbigtSW5maW5pdHkpID0gLXBpLzJcclxuICAgKiBhdGFuKE5hTikgICAgICAgPSBOYU5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaW52ZXJzZVRhbmdlbnQgPSBQLmF0YW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgaSwgaiwgaywgbiwgcHgsIHQsIHIsIHdwciwgeDIsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbixcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICAgIGlmICgheC5pc0Zpbml0ZSgpKSB7XHJcbiAgICAgIGlmICgheC5zKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuICAgICAgaWYgKHByICsgNCA8PSBQSV9QUkVDSVNJT04pIHtcclxuICAgICAgICByID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC41KTtcclxuICAgICAgICByLnMgPSB4LnM7XHJcbiAgICAgICAgcmV0dXJuIHI7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSBpZiAoeC5pc1plcm8oKSkge1xyXG4gICAgICByZXR1cm4gbmV3IEN0b3IoeCk7XHJcbiAgICB9IGVsc2UgaWYgKHguYWJzKCkuZXEoMSkgJiYgcHIgKyA0IDw9IFBJX1BSRUNJU0lPTikge1xyXG4gICAgICByID0gZ2V0UGkoQ3RvciwgcHIgKyA0LCBybSkudGltZXMoMC4yNSk7XHJcbiAgICAgIHIucyA9IHgucztcclxuICAgICAgcmV0dXJuIHI7XHJcbiAgICB9XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgPSBwciArIDEwO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gICAgLy8gVE9ETz8gaWYgKHggPj0gMSAmJiBwciA8PSBQSV9QUkVDSVNJT04pIGF0YW4oeCkgPSBoYWxmUGkgKiB4LnMgLSBhdGFuKDEgLyB4KTtcclxuXHJcbiAgICAvLyBBcmd1bWVudCByZWR1Y3Rpb25cclxuICAgIC8vIEVuc3VyZSB8eHwgPCAwLjQyXHJcbiAgICAvLyBhdGFuKHgpID0gMiAqIGF0YW4oeCAvICgxICsgc3FydCgxICsgeF4yKSkpXHJcblxyXG4gICAgayA9IE1hdGgubWluKDI4LCB3cHIgLyBMT0dfQkFTRSArIDIgfCAwKTtcclxuXHJcbiAgICBmb3IgKGkgPSBrOyBpOyAtLWkpIHggPSB4LmRpdih4LnRpbWVzKHgpLnBsdXMoMSkuc3FydCgpLnBsdXMoMSkpO1xyXG5cclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gICAgaiA9IE1hdGguY2VpbCh3cHIgLyBMT0dfQkFTRSk7XHJcbiAgICBuID0gMTtcclxuICAgIHgyID0geC50aW1lcyh4KTtcclxuICAgIHIgPSBuZXcgQ3Rvcih4KTtcclxuICAgIHB4ID0geDtcclxuXHJcbiAgICAvLyBhdGFuKHgpID0geCAtIHheMy8zICsgeF41LzUgLSB4XjcvNyArIC4uLlxyXG4gICAgZm9yICg7IGkgIT09IC0xOykge1xyXG4gICAgICBweCA9IHB4LnRpbWVzKHgyKTtcclxuICAgICAgdCA9IHIubWludXMocHguZGl2KG4gKz0gMikpO1xyXG5cclxuICAgICAgcHggPSBweC50aW1lcyh4Mik7XHJcbiAgICAgIHIgPSB0LnBsdXMocHguZGl2KG4gKz0gMikpO1xyXG5cclxuICAgICAgaWYgKHIuZFtqXSAhPT0gdm9pZCAwKSBmb3IgKGkgPSBqOyByLmRbaV0gPT09IHQuZFtpXSAmJiBpLS07KTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaykgciA9IHIudGltZXMoMiA8PCAoayAtIDEpKTtcclxuXHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHIsIEN0b3IucHJlY2lzaW9uID0gcHIsIEN0b3Iucm91bmRpbmcgPSBybSwgdHJ1ZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBhIGZpbml0ZSBudW1iZXIsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmlzRmluaXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5kO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgYW4gaW50ZWdlciwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaXNJbnRlZ2VyID0gUC5pc0ludCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiAhIXRoaXMuZCAmJiBtYXRoZmxvb3IodGhpcy5lIC8gTE9HX0JBU0UpID4gdGhpcy5kLmxlbmd0aCAtIDI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBOYU4sIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmlzTmFOID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICF0aGlzLnM7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpcyBuZWdhdGl2ZSwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaXNOZWdhdGl2ZSA9IFAuaXNOZWcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5zIDwgMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIHBvc2l0aXZlLCBvdGhlcndpc2UgcmV0dXJuIGZhbHNlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5pc1Bvc2l0aXZlID0gUC5pc1BvcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB0aGlzLnMgPiAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgMCBvciAtMCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAuaXNaZXJvID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5kICYmIHRoaXMuZFswXSA9PT0gMDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdHJ1ZSBpZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGlzIGxlc3MgdGhhbiBgeWAsIG90aGVyd2lzZSByZXR1cm4gZmFsc2UuXHJcbiAgICpcclxuICAgKi9cclxuICBQLmxlc3NUaGFuID0gUC5sdCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbXAoeSkgPCAwO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0cnVlIGlmIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaXMgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIGB5YCwgb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAubGVzc1RoYW5PckVxdWFsVG8gPSBQLmx0ZSA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICByZXR1cm4gdGhpcy5jbXAoeSkgPCAxO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiB0aGUgbG9nYXJpdGhtIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgdG8gdGhlIHNwZWNpZmllZCBiYXNlLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIElmIG5vIGJhc2UgaXMgc3BlY2lmaWVkLCByZXR1cm4gbG9nWzEwXShhcmcpLlxyXG4gICAqXHJcbiAgICogbG9nW2Jhc2VdKGFyZykgPSBsbihhcmcpIC8gbG4oYmFzZSlcclxuICAgKlxyXG4gICAqIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgY29ycmVjdGx5IHJvdW5kZWQgaWYgdGhlIGJhc2Ugb2YgdGhlIGxvZyBpcyAxMCwgYW5kICdhbG1vc3QgYWx3YXlzJ1xyXG4gICAqIG90aGVyd2lzZTpcclxuICAgKlxyXG4gICAqIERlcGVuZGluZyBvbiB0aGUgcm91bmRpbmcgbW9kZSwgdGhlIHJlc3VsdCBtYXkgYmUgaW5jb3JyZWN0bHkgcm91bmRlZCBpZiB0aGUgZmlyc3QgZmlmdGVlblxyXG4gICAqIHJvdW5kaW5nIGRpZ2l0cyBhcmUgWzQ5XTk5OTk5OTk5OTk5OTk5IG9yIFs1MF0wMDAwMDAwMDAwMDAwMC4gSW4gdGhhdCBjYXNlLCB0aGUgbWF4aW11bSBlcnJvclxyXG4gICAqIGJldHdlZW4gdGhlIHJlc3VsdCBhbmQgdGhlIGNvcnJlY3RseSByb3VuZGVkIHJlc3VsdCB3aWxsIGJlIG9uZSB1bHAgKHVuaXQgaW4gdGhlIGxhc3QgcGxhY2UpLlxyXG4gICAqXHJcbiAgICogbG9nWy1iXShhKSAgICAgICA9IE5hTlxyXG4gICAqIGxvZ1swXShhKSAgICAgICAgPSBOYU5cclxuICAgKiBsb2dbMV0oYSkgICAgICAgID0gTmFOXHJcbiAgICogbG9nW05hTl0oYSkgICAgICA9IE5hTlxyXG4gICAqIGxvZ1tJbmZpbml0eV0oYSkgPSBOYU5cclxuICAgKiBsb2dbYl0oMCkgICAgICAgID0gLUluZmluaXR5XHJcbiAgICogbG9nW2JdKC0wKSAgICAgICA9IC1JbmZpbml0eVxyXG4gICAqIGxvZ1tiXSgtYSkgICAgICAgPSBOYU5cclxuICAgKiBsb2dbYl0oMSkgICAgICAgID0gMFxyXG4gICAqIGxvZ1tiXShJbmZpbml0eSkgPSBJbmZpbml0eVxyXG4gICAqIGxvZ1tiXShOYU4pICAgICAgPSBOYU5cclxuICAgKlxyXG4gICAqIFtiYXNlXSB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH0gVGhlIGJhc2Ugb2YgdGhlIGxvZ2FyaXRobS5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAubG9nYXJpdGhtID0gUC5sb2cgPSBmdW5jdGlvbiAoYmFzZSkge1xyXG4gICAgdmFyIGlzQmFzZTEwLCBkLCBkZW5vbWluYXRvciwgaywgaW5mLCBudW0sIHNkLCByLFxyXG4gICAgICBhcmcgPSB0aGlzLFxyXG4gICAgICBDdG9yID0gYXJnLmNvbnN0cnVjdG9yLFxyXG4gICAgICBwciA9IEN0b3IucHJlY2lzaW9uLFxyXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmcsXHJcbiAgICAgIGd1YXJkID0gNTtcclxuXHJcbiAgICAvLyBEZWZhdWx0IGJhc2UgaXMgMTAuXHJcbiAgICBpZiAoYmFzZSA9PSBudWxsKSB7XHJcbiAgICAgIGJhc2UgPSBuZXcgQ3RvcigxMCk7XHJcbiAgICAgIGlzQmFzZTEwID0gdHJ1ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGJhc2UgPSBuZXcgQ3RvcihiYXNlKTtcclxuICAgICAgZCA9IGJhc2UuZDtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgYmFzZSBpcyBuZWdhdGl2ZSwgb3Igbm9uLWZpbml0ZSwgb3IgaXMgMCBvciAxLlxyXG4gICAgICBpZiAoYmFzZS5zIDwgMCB8fCAhZCB8fCAhZFswXSB8fCBiYXNlLmVxKDEpKSByZXR1cm4gbmV3IEN0b3IoTmFOKTtcclxuXHJcbiAgICAgIGlzQmFzZTEwID0gYmFzZS5lcSgxMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZCA9IGFyZy5kO1xyXG5cclxuICAgIC8vIElzIGFyZyBuZWdhdGl2ZSwgbm9uLWZpbml0ZSwgMCBvciAxP1xyXG4gICAgaWYgKGFyZy5zIDwgMCB8fCAhZCB8fCAhZFswXSB8fCBhcmcuZXEoMSkpIHtcclxuICAgICAgcmV0dXJuIG5ldyBDdG9yKGQgJiYgIWRbMF0gPyAtMSAvIDAgOiBhcmcucyAhPSAxID8gTmFOIDogZCA/IDAgOiAxIC8gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVGhlIHJlc3VsdCB3aWxsIGhhdmUgYSBub24tdGVybWluYXRpbmcgZGVjaW1hbCBleHBhbnNpb24gaWYgYmFzZSBpcyAxMCBhbmQgYXJnIGlzIG5vdCBhblxyXG4gICAgLy8gaW50ZWdlciBwb3dlciBvZiAxMC5cclxuICAgIGlmIChpc0Jhc2UxMCkge1xyXG4gICAgICBpZiAoZC5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgaW5mID0gdHJ1ZTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGsgPSBkWzBdOyBrICUgMTAgPT09IDA7KSBrIC89IDEwO1xyXG4gICAgICAgIGluZiA9IGsgIT09IDE7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgc2QgPSBwciArIGd1YXJkO1xyXG4gICAgbnVtID0gbmF0dXJhbExvZ2FyaXRobShhcmcsIHNkKTtcclxuICAgIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XHJcblxyXG4gICAgLy8gVGhlIHJlc3VsdCB3aWxsIGhhdmUgNSByb3VuZGluZyBkaWdpdHMuXHJcbiAgICByID0gZGl2aWRlKG51bSwgZGVub21pbmF0b3IsIHNkLCAxKTtcclxuXHJcbiAgICAvLyBJZiBhdCBhIHJvdW5kaW5nIGJvdW5kYXJ5LCBpLmUuIHRoZSByZXN1bHQncyByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTk5IG9yIFs1MF0wMDAwLFxyXG4gICAgLy8gY2FsY3VsYXRlIDEwIGZ1cnRoZXIgZGlnaXRzLlxyXG4gICAgLy9cclxuICAgIC8vIElmIHRoZSByZXN1bHQgaXMga25vd24gdG8gaGF2ZSBhbiBpbmZpbml0ZSBkZWNpbWFsIGV4cGFuc2lvbiwgcmVwZWF0IHRoaXMgdW50aWwgaXQgaXMgY2xlYXJcclxuICAgIC8vIHRoYXQgdGhlIHJlc3VsdCBpcyBhYm92ZSBvciBiZWxvdyB0aGUgYm91bmRhcnkuIE90aGVyd2lzZSwgaWYgYWZ0ZXIgY2FsY3VsYXRpbmcgdGhlIDEwXHJcbiAgICAvLyBmdXJ0aGVyIGRpZ2l0cywgdGhlIGxhc3QgMTQgYXJlIG5pbmVzLCByb3VuZCB1cCBhbmQgYXNzdW1lIHRoZSByZXN1bHQgaXMgZXhhY3QuXHJcbiAgICAvLyBBbHNvIGFzc3VtZSB0aGUgcmVzdWx0IGlzIGV4YWN0IGlmIHRoZSBsYXN0IDE0IGFyZSB6ZXJvLlxyXG4gICAgLy9cclxuICAgIC8vIEV4YW1wbGUgb2YgYSByZXN1bHQgdGhhdCB3aWxsIGJlIGluY29ycmVjdGx5IHJvdW5kZWQ6XHJcbiAgICAvLyBsb2dbMTA0ODU3Nl0oNDUwMzU5OTYyNzM3MDUwMikgPSAyLjYwMDAwMDAwMDAwMDAwMDA5NjEwMjc5NTExNDQ0NzQ2Li4uXHJcbiAgICAvLyBUaGUgYWJvdmUgcmVzdWx0IGNvcnJlY3RseSByb3VuZGVkIHVzaW5nIFJPVU5EX0NFSUwgdG8gMSBkZWNpbWFsIHBsYWNlIHNob3VsZCBiZSAyLjcsIGJ1dCBpdFxyXG4gICAgLy8gd2lsbCBiZSBnaXZlbiBhcyAyLjYgYXMgdGhlcmUgYXJlIDE1IHplcm9zIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSByZXF1ZXN0ZWQgZGVjaW1hbCBwbGFjZSwgc29cclxuICAgIC8vIHRoZSBleGFjdCByZXN1bHQgd291bGQgYmUgYXNzdW1lZCB0byBiZSAyLjYsIHdoaWNoIHJvdW5kZWQgdXNpbmcgUk9VTkRfQ0VJTCB0byAxIGRlY2ltYWxcclxuICAgIC8vIHBsYWNlIGlzIHN0aWxsIDIuNi5cclxuICAgIGlmIChjaGVja1JvdW5kaW5nRGlnaXRzKHIuZCwgayA9IHByLCBybSkpIHtcclxuXHJcbiAgICAgIGRvIHtcclxuICAgICAgICBzZCArPSAxMDtcclxuICAgICAgICBudW0gPSBuYXR1cmFsTG9nYXJpdGhtKGFyZywgc2QpO1xyXG4gICAgICAgIGRlbm9taW5hdG9yID0gaXNCYXNlMTAgPyBnZXRMbjEwKEN0b3IsIHNkICsgMTApIDogbmF0dXJhbExvZ2FyaXRobShiYXNlLCBzZCk7XHJcbiAgICAgICAgciA9IGRpdmlkZShudW0sIGRlbm9taW5hdG9yLCBzZCwgMSk7XHJcblxyXG4gICAgICAgIGlmICghaW5mKSB7XHJcblxyXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIDE0IG5pbmVzIGZyb20gdGhlIDJuZCByb3VuZGluZyBkaWdpdCwgYXMgdGhlIGZpcnN0IG1heSBiZSA0LlxyXG4gICAgICAgICAgaWYgKCtkaWdpdHNUb1N0cmluZyhyLmQpLnNsaWNlKGsgKyAxLCBrICsgMTUpICsgMSA9PSAxZTE0KSB7XHJcbiAgICAgICAgICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDEsIDApO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfSB3aGlsZSAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhyLmQsIGsgKz0gMTAsIHJtKSk7XHJcbiAgICB9XHJcblxyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZShyLCBwciwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBtYXhpbXVtIG9mIHRoZSBhcmd1bWVudHMgYW5kIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICpcclxuICBQLm1heCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmNhbGwoYXJndW1lbnRzLCB0aGlzKTtcclxuICAgIHJldHVybiBtYXhPck1pbih0aGlzLmNvbnN0cnVjdG9yLCBhcmd1bWVudHMsIC0xKTtcclxuICB9O1xyXG4gICAqL1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbWluaW11bSBvZiB0aGUgYXJndW1lbnRzIGFuZCB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogYXJndW1lbnRzIHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gICAqXHJcbiAgUC5taW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5jYWxsKGFyZ3VtZW50cywgdGhpcyk7XHJcbiAgICByZXR1cm4gbWF4T3JNaW4odGhpcy5jb25zdHJ1Y3RvciwgYXJndW1lbnRzLCAxKTtcclxuICB9O1xyXG4gICAqL1xyXG5cclxuXHJcbiAgLypcclxuICAgKiAgbiAtIDAgPSBuXHJcbiAgICogIG4gLSBOID0gTlxyXG4gICAqICBuIC0gSSA9IC1JXHJcbiAgICogIDAgLSBuID0gLW5cclxuICAgKiAgMCAtIDAgPSAwXHJcbiAgICogIDAgLSBOID0gTlxyXG4gICAqICAwIC0gSSA9IC1JXHJcbiAgICogIE4gLSBuID0gTlxyXG4gICAqICBOIC0gMCA9IE5cclxuICAgKiAgTiAtIE4gPSBOXHJcbiAgICogIE4gLSBJID0gTlxyXG4gICAqICBJIC0gbiA9IElcclxuICAgKiAgSSAtIDAgPSBJXHJcbiAgICogIEkgLSBOID0gTlxyXG4gICAqICBJIC0gSSA9IE5cclxuICAgKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgbWludXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAubWludXMgPSBQLnN1YiA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICB2YXIgZCwgZSwgaSwgaiwgaywgbGVuLCBwciwgcm0sIHhkLCB4ZSwgeExUeSwgeWQsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICB5ID0gbmV3IEN0b3IoeSk7XHJcblxyXG4gICAgLy8gSWYgZWl0aGVyIGlzIG5vdCBmaW5pdGUuLi5cclxuICAgIGlmICgheC5kIHx8ICF5LmQpIHtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTi5cclxuICAgICAgaWYgKCF4LnMgfHwgIXkucykgeSA9IG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geSBuZWdhdGVkIGlmIHggaXMgZmluaXRlIGFuZCB5IGlzIMKxSW5maW5pdHkuXHJcbiAgICAgIGVsc2UgaWYgKHguZCkgeS5zID0gLXkucztcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgZmluaXRlIGFuZCB4IGlzIMKxSW5maW5pdHkuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIGJvdGggYXJlIMKxSW5maW5pdHkgd2l0aCBkaWZmZXJlbnQgc2lnbnMuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgYm90aCBhcmUgwrFJbmZpbml0eSB3aXRoIHRoZSBzYW1lIHNpZ24uXHJcbiAgICAgIGVsc2UgeSA9IG5ldyBDdG9yKHkuZCB8fCB4LnMgIT09IHkucyA/IHggOiBOYU4pO1xyXG5cclxuICAgICAgcmV0dXJuIHk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSWYgc2lnbnMgZGlmZmVyLi4uXHJcbiAgICBpZiAoeC5zICE9IHkucykge1xyXG4gICAgICB5LnMgPSAteS5zO1xyXG4gICAgICByZXR1cm4geC5wbHVzKHkpO1xyXG4gICAgfVxyXG5cclxuICAgIHhkID0geC5kO1xyXG4gICAgeWQgPSB5LmQ7XHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICAgIC8vIElmIGVpdGhlciBpcyB6ZXJvLi4uXHJcbiAgICBpZiAoIXhkWzBdIHx8ICF5ZFswXSkge1xyXG5cclxuICAgICAgLy8gUmV0dXJuIHkgbmVnYXRlZCBpZiB4IGlzIHplcm8gYW5kIHkgaXMgbm9uLXplcm8uXHJcbiAgICAgIGlmICh5ZFswXSkgeS5zID0gLXkucztcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgemVybyBhbmQgeCBpcyBub24temVyby5cclxuICAgICAgZWxzZSBpZiAoeGRbMF0pIHkgPSBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICAgIC8vIFJldHVybiB6ZXJvIGlmIGJvdGggYXJlIHplcm8uXHJcbiAgICAgIC8vIEZyb20gSUVFRSA3NTQgKDIwMDgpIDYuMzogMCAtIDAgPSAtMCAtIC0wID0gLTAgd2hlbiByb3VuZGluZyB0byAtSW5maW5pdHkuXHJcbiAgICAgIGVsc2UgcmV0dXJuIG5ldyBDdG9yKHJtID09PSAzID8gLTAgOiAwKTtcclxuXHJcbiAgICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHggYW5kIHkgYXJlIGZpbml0ZSwgbm9uLXplcm8gbnVtYmVycyB3aXRoIHRoZSBzYW1lIHNpZ24uXHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGJhc2UgMWU3IGV4cG9uZW50cy5cclxuICAgIGUgPSBtYXRoZmxvb3IoeS5lIC8gTE9HX0JBU0UpO1xyXG4gICAgeGUgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpO1xyXG5cclxuICAgIHhkID0geGQuc2xpY2UoKTtcclxuICAgIGsgPSB4ZSAtIGU7XHJcblxyXG4gICAgLy8gSWYgYmFzZSAxZTcgZXhwb25lbnRzIGRpZmZlci4uLlxyXG4gICAgaWYgKGspIHtcclxuICAgICAgeExUeSA9IGsgPCAwO1xyXG5cclxuICAgICAgaWYgKHhMVHkpIHtcclxuICAgICAgICBkID0geGQ7XHJcbiAgICAgICAgayA9IC1rO1xyXG4gICAgICAgIGxlbiA9IHlkLmxlbmd0aDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBkID0geWQ7XHJcbiAgICAgICAgZSA9IHhlO1xyXG4gICAgICAgIGxlbiA9IHhkLmxlbmd0aDtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTnVtYmVycyB3aXRoIG1hc3NpdmVseSBkaWZmZXJlbnQgZXhwb25lbnRzIHdvdWxkIHJlc3VsdCBpbiBhIHZlcnkgaGlnaCBudW1iZXIgb2ZcclxuICAgICAgLy8gemVyb3MgbmVlZGluZyB0byBiZSBwcmVwZW5kZWQsIGJ1dCB0aGlzIGNhbiBiZSBhdm9pZGVkIHdoaWxlIHN0aWxsIGVuc3VyaW5nIGNvcnJlY3RcclxuICAgICAgLy8gcm91bmRpbmcgYnkgbGltaXRpbmcgdGhlIG51bWJlciBvZiB6ZXJvcyB0byBgTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpICsgMmAuXHJcbiAgICAgIGkgPSBNYXRoLm1heChNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSksIGxlbikgKyAyO1xyXG5cclxuICAgICAgaWYgKGsgPiBpKSB7XHJcbiAgICAgICAgayA9IGk7XHJcbiAgICAgICAgZC5sZW5ndGggPSAxO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBQcmVwZW5kIHplcm9zIHRvIGVxdWFsaXNlIGV4cG9uZW50cy5cclxuICAgICAgZC5yZXZlcnNlKCk7XHJcbiAgICAgIGZvciAoaSA9IGs7IGktLTspIGQucHVzaCgwKTtcclxuICAgICAgZC5yZXZlcnNlKCk7XHJcblxyXG4gICAgLy8gQmFzZSAxZTcgZXhwb25lbnRzIGVxdWFsLlxyXG4gICAgfSBlbHNlIHtcclxuXHJcbiAgICAgIC8vIENoZWNrIGRpZ2l0cyB0byBkZXRlcm1pbmUgd2hpY2ggaXMgdGhlIGJpZ2dlciBudW1iZXIuXHJcblxyXG4gICAgICBpID0geGQubGVuZ3RoO1xyXG4gICAgICBsZW4gPSB5ZC5sZW5ndGg7XHJcbiAgICAgIHhMVHkgPSBpIDwgbGVuO1xyXG4gICAgICBpZiAoeExUeSkgbGVuID0gaTtcclxuXHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgIGlmICh4ZFtpXSAhPSB5ZFtpXSkge1xyXG4gICAgICAgICAgeExUeSA9IHhkW2ldIDwgeWRbaV07XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGsgPSAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh4TFR5KSB7XHJcbiAgICAgIGQgPSB4ZDtcclxuICAgICAgeGQgPSB5ZDtcclxuICAgICAgeWQgPSBkO1xyXG4gICAgICB5LnMgPSAteS5zO1xyXG4gICAgfVxyXG5cclxuICAgIGxlbiA9IHhkLmxlbmd0aDtcclxuXHJcbiAgICAvLyBBcHBlbmQgemVyb3MgdG8gYHhkYCBpZiBzaG9ydGVyLlxyXG4gICAgLy8gRG9uJ3QgYWRkIHplcm9zIHRvIGB5ZGAgaWYgc2hvcnRlciBhcyBzdWJ0cmFjdGlvbiBvbmx5IG5lZWRzIHRvIHN0YXJ0IGF0IGB5ZGAgbGVuZ3RoLlxyXG4gICAgZm9yIChpID0geWQubGVuZ3RoIC0gbGVuOyBpID4gMDsgLS1pKSB4ZFtsZW4rK10gPSAwO1xyXG5cclxuICAgIC8vIFN1YnRyYWN0IHlkIGZyb20geGQuXHJcbiAgICBmb3IgKGkgPSB5ZC5sZW5ndGg7IGkgPiBrOykge1xyXG5cclxuICAgICAgaWYgKHhkWy0taV0gPCB5ZFtpXSkge1xyXG4gICAgICAgIGZvciAoaiA9IGk7IGogJiYgeGRbLS1qXSA9PT0gMDspIHhkW2pdID0gQkFTRSAtIDE7XHJcbiAgICAgICAgLS14ZFtqXTtcclxuICAgICAgICB4ZFtpXSArPSBCQVNFO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZFtpXSAtPSB5ZFtpXTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICBmb3IgKDsgeGRbLS1sZW5dID09PSAwOykgeGQucG9wKCk7XHJcblxyXG4gICAgLy8gUmVtb3ZlIGxlYWRpbmcgemVyb3MgYW5kIGFkanVzdCBleHBvbmVudCBhY2NvcmRpbmdseS5cclxuICAgIGZvciAoOyB4ZFswXSA9PT0gMDsgeGQuc2hpZnQoKSkgLS1lO1xyXG5cclxuICAgIC8vIFplcm8/XHJcbiAgICBpZiAoIXhkWzBdKSByZXR1cm4gbmV3IEN0b3Iocm0gPT09IDMgPyAtMCA6IDApO1xyXG5cclxuICAgIHkuZCA9IHhkO1xyXG4gICAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQoeGQsIGUpO1xyXG5cclxuICAgIHJldHVybiBleHRlcm5hbCA/IGZpbmFsaXNlKHksIHByLCBybSkgOiB5O1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICAgbiAlIDAgPSAgTlxyXG4gICAqICAgbiAlIE4gPSAgTlxyXG4gICAqICAgbiAlIEkgPSAgblxyXG4gICAqICAgMCAlIG4gPSAgMFxyXG4gICAqICAtMCAlIG4gPSAtMFxyXG4gICAqICAgMCAlIDAgPSAgTlxyXG4gICAqICAgMCAlIE4gPSAgTlxyXG4gICAqICAgMCAlIEkgPSAgMFxyXG4gICAqICAgTiAlIG4gPSAgTlxyXG4gICAqICAgTiAlIDAgPSAgTlxyXG4gICAqICAgTiAlIE4gPSAgTlxyXG4gICAqICAgTiAlIEkgPSAgTlxyXG4gICAqICAgSSAlIG4gPSAgTlxyXG4gICAqICAgSSAlIDAgPSAgTlxyXG4gICAqICAgSSAlIE4gPSAgTlxyXG4gICAqICAgSSAlIEkgPSAgTlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBtb2R1bG8gYHlgLCByb3VuZGVkIHRvXHJcbiAgICogYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIFRoZSByZXN1bHQgZGVwZW5kcyBvbiB0aGUgbW9kdWxvIG1vZGUuXHJcbiAgICpcclxuICAgKi9cclxuICBQLm1vZHVsbyA9IFAubW9kID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHZhciBxLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgeSA9IG5ldyBDdG9yKHkpO1xyXG5cclxuICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyDCsUluZmluaXR5IG9yIE5hTiwgb3IgeSBpcyBOYU4gb3IgwrEwLlxyXG4gICAgaWYgKCF4LmQgfHwgIXkucyB8fCB5LmQgJiYgIXkuZFswXSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgLy8gUmV0dXJuIHggaWYgeSBpcyDCsUluZmluaXR5IG9yIHggaXMgwrEwLlxyXG4gICAgaWYgKCF5LmQgfHwgeC5kICYmICF4LmRbMF0pIHtcclxuICAgICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBDdG9yLnByZWNpc2lvbiwgQ3Rvci5yb3VuZGluZyk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUHJldmVudCByb3VuZGluZyBvZiBpbnRlcm1lZGlhdGUgY2FsY3VsYXRpb25zLlxyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoQ3Rvci5tb2R1bG8gPT0gOSkge1xyXG5cclxuICAgICAgLy8gRXVjbGlkaWFuIGRpdmlzaW9uOiBxID0gc2lnbih5KSAqIGZsb29yKHggLyBhYnMoeSkpXHJcbiAgICAgIC8vIHJlc3VsdCA9IHggLSBxICogeSAgICB3aGVyZSAgMCA8PSByZXN1bHQgPCBhYnMoeSlcclxuICAgICAgcSA9IGRpdmlkZSh4LCB5LmFicygpLCAwLCAzLCAxKTtcclxuICAgICAgcS5zICo9IHkucztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHEgPSBkaXZpZGUoeCwgeSwgMCwgQ3Rvci5tb2R1bG8sIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHEgPSBxLnRpbWVzKHkpO1xyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4geC5taW51cyhxKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbmF0dXJhbCBleHBvbmVudGlhbCBvZiB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLFxyXG4gICAqIGkuZS4gdGhlIGJhc2UgZSByYWlzZWQgdG8gdGhlIHBvd2VyIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5uYXR1cmFsRXhwb25lbnRpYWwgPSBQLmV4cCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuYXR1cmFsRXhwb25lbnRpYWwodGhpcyk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwsXHJcbiAgICogcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5uYXR1cmFsTG9nYXJpdGhtID0gUC5sbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBuYXR1cmFsTG9nYXJpdGhtKHRoaXMpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgbmVnYXRlZCwgaS5lLiBhcyBpZiBtdWx0aXBsaWVkIGJ5XHJcbiAgICogLTEuXHJcbiAgICpcclxuICAgKi9cclxuICBQLm5lZ2F0ZWQgPSBQLm5lZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciB4ID0gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XHJcbiAgICB4LnMgPSAteC5zO1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHgpO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqICBuICsgMCA9IG5cclxuICAgKiAgbiArIE4gPSBOXHJcbiAgICogIG4gKyBJID0gSVxyXG4gICAqICAwICsgbiA9IG5cclxuICAgKiAgMCArIDAgPSAwXHJcbiAgICogIDAgKyBOID0gTlxyXG4gICAqICAwICsgSSA9IElcclxuICAgKiAgTiArIG4gPSBOXHJcbiAgICogIE4gKyAwID0gTlxyXG4gICAqICBOICsgTiA9IE5cclxuICAgKiAgTiArIEkgPSBOXHJcbiAgICogIEkgKyBuID0gSVxyXG4gICAqICBJICsgMCA9IElcclxuICAgKiAgSSArIE4gPSBOXHJcbiAgICogIEkgKyBJID0gSVxyXG4gICAqXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBwbHVzIGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnBsdXMgPSBQLmFkZCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICB2YXIgY2FycnksIGQsIGUsIGksIGssIGxlbiwgcHIsIHJtLCB4ZCwgeWQsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICB5ID0gbmV3IEN0b3IoeSk7XHJcblxyXG4gICAgLy8gSWYgZWl0aGVyIGlzIG5vdCBmaW5pdGUuLi5cclxuICAgIGlmICgheC5kIHx8ICF5LmQpIHtcclxuXHJcbiAgICAgIC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIGlzIE5hTi5cclxuICAgICAgaWYgKCF4LnMgfHwgIXkucykgeSA9IG5ldyBDdG9yKE5hTik7XHJcblxyXG4gICAgICAvLyBSZXR1cm4geCBpZiB5IGlzIGZpbml0ZSBhbmQgeCBpcyDCsUluZmluaXR5LlxyXG4gICAgICAvLyBSZXR1cm4geCBpZiBib3RoIGFyZSDCsUluZmluaXR5IHdpdGggdGhlIHNhbWUgc2lnbi5cclxuICAgICAgLy8gUmV0dXJuIE5hTiBpZiBib3RoIGFyZSDCsUluZmluaXR5IHdpdGggZGlmZmVyZW50IHNpZ25zLlxyXG4gICAgICAvLyBSZXR1cm4geSBpZiB4IGlzIGZpbml0ZSBhbmQgeSBpcyDCsUluZmluaXR5LlxyXG4gICAgICBlbHNlIGlmICgheC5kKSB5ID0gbmV3IEN0b3IoeS5kIHx8IHgucyA9PT0geS5zID8geCA6IE5hTik7XHJcblxyXG4gICAgICByZXR1cm4geTtcclxuICAgIH1cclxuXHJcbiAgICAgLy8gSWYgc2lnbnMgZGlmZmVyLi4uXHJcbiAgICBpZiAoeC5zICE9IHkucykge1xyXG4gICAgICB5LnMgPSAteS5zO1xyXG4gICAgICByZXR1cm4geC5taW51cyh5KTtcclxuICAgIH1cclxuXHJcbiAgICB4ZCA9IHguZDtcclxuICAgIHlkID0geS5kO1xyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuXHJcbiAgICAvLyBJZiBlaXRoZXIgaXMgemVyby4uLlxyXG4gICAgaWYgKCF4ZFswXSB8fCAheWRbMF0pIHtcclxuXHJcbiAgICAgIC8vIFJldHVybiB4IGlmIHkgaXMgemVyby5cclxuICAgICAgLy8gUmV0dXJuIHkgaWYgeSBpcyBub24temVyby5cclxuICAgICAgaWYgKCF5ZFswXSkgeSA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICAgICAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgcHIsIHJtKSA6IHk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8geCBhbmQgeSBhcmUgZmluaXRlLCBub24temVybyBudW1iZXJzIHdpdGggdGhlIHNhbWUgc2lnbi5cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgYmFzZSAxZTcgZXhwb25lbnRzLlxyXG4gICAgayA9IG1hdGhmbG9vcih4LmUgLyBMT0dfQkFTRSk7XHJcbiAgICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuXHJcbiAgICB4ZCA9IHhkLnNsaWNlKCk7XHJcbiAgICBpID0gayAtIGU7XHJcblxyXG4gICAgLy8gSWYgYmFzZSAxZTcgZXhwb25lbnRzIGRpZmZlci4uLlxyXG4gICAgaWYgKGkpIHtcclxuXHJcbiAgICAgIGlmIChpIDwgMCkge1xyXG4gICAgICAgIGQgPSB4ZDtcclxuICAgICAgICBpID0gLWk7XHJcbiAgICAgICAgbGVuID0geWQubGVuZ3RoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGQgPSB5ZDtcclxuICAgICAgICBlID0gaztcclxuICAgICAgICBsZW4gPSB4ZC5sZW5ndGg7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIExpbWl0IG51bWJlciBvZiB6ZXJvcyBwcmVwZW5kZWQgdG8gbWF4KGNlaWwocHIgLyBMT0dfQkFTRSksIGxlbikgKyAxLlxyXG4gICAgICBrID0gTWF0aC5jZWlsKHByIC8gTE9HX0JBU0UpO1xyXG4gICAgICBsZW4gPSBrID4gbGVuID8gayArIDEgOiBsZW4gKyAxO1xyXG5cclxuICAgICAgaWYgKGkgPiBsZW4pIHtcclxuICAgICAgICBpID0gbGVuO1xyXG4gICAgICAgIGQubGVuZ3RoID0gMTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUHJlcGVuZCB6ZXJvcyB0byBlcXVhbGlzZSBleHBvbmVudHMuIE5vdGU6IEZhc3RlciB0byB1c2UgcmV2ZXJzZSB0aGVuIGRvIHVuc2hpZnRzLlxyXG4gICAgICBkLnJldmVyc2UoKTtcclxuICAgICAgZm9yICg7IGktLTspIGQucHVzaCgwKTtcclxuICAgICAgZC5yZXZlcnNlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgbGVuID0geGQubGVuZ3RoO1xyXG4gICAgaSA9IHlkLmxlbmd0aDtcclxuXHJcbiAgICAvLyBJZiB5ZCBpcyBsb25nZXIgdGhhbiB4ZCwgc3dhcCB4ZCBhbmQgeWQgc28geGQgcG9pbnRzIHRvIHRoZSBsb25nZXIgYXJyYXkuXHJcbiAgICBpZiAobGVuIC0gaSA8IDApIHtcclxuICAgICAgaSA9IGxlbjtcclxuICAgICAgZCA9IHlkO1xyXG4gICAgICB5ZCA9IHhkO1xyXG4gICAgICB4ZCA9IGQ7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gT25seSBzdGFydCBhZGRpbmcgYXQgeWQubGVuZ3RoIC0gMSBhcyB0aGUgZnVydGhlciBkaWdpdHMgb2YgeGQgY2FuIGJlIGxlZnQgYXMgdGhleSBhcmUuXHJcbiAgICBmb3IgKGNhcnJ5ID0gMDsgaTspIHtcclxuICAgICAgY2FycnkgPSAoeGRbLS1pXSA9IHhkW2ldICsgeWRbaV0gKyBjYXJyeSkgLyBCQVNFIHwgMDtcclxuICAgICAgeGRbaV0gJT0gQkFTRTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY2FycnkpIHtcclxuICAgICAgeGQudW5zaGlmdChjYXJyeSk7XHJcbiAgICAgICsrZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3MuXHJcbiAgICAvLyBObyBuZWVkIHRvIGNoZWNrIGZvciB6ZXJvLCBhcyAreCArICt5ICE9IDAgJiYgLXggKyAteSAhPSAwXHJcbiAgICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgeGRbLS1sZW5dID09IDA7KSB4ZC5wb3AoKTtcclxuXHJcbiAgICB5LmQgPSB4ZDtcclxuICAgIHkuZSA9IGdldEJhc2UxMEV4cG9uZW50KHhkLCBlKTtcclxuXHJcbiAgICByZXR1cm4gZXh0ZXJuYWwgPyBmaW5hbGlzZSh5LCBwciwgcm0pIDogeTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBkaWdpdHMgb2YgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIFt6XSB7Ym9vbGVhbnxudW1iZXJ9IFdoZXRoZXIgdG8gY291bnQgaW50ZWdlci1wYXJ0IHRyYWlsaW5nIHplcm9zOiB0cnVlLCBmYWxzZSwgMSBvciAwLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5wcmVjaXNpb24gPSBQLnNkID0gZnVuY3Rpb24gKHopIHtcclxuICAgIHZhciBrLFxyXG4gICAgICB4ID0gdGhpcztcclxuXHJcbiAgICBpZiAoeiAhPT0gdm9pZCAwICYmIHogIT09ICEheiAmJiB6ICE9PSAxICYmIHogIT09IDApIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHopO1xyXG5cclxuICAgIGlmICh4LmQpIHtcclxuICAgICAgayA9IGdldFByZWNpc2lvbih4LmQpO1xyXG4gICAgICBpZiAoeiAmJiB4LmUgKyAxID4gaykgayA9IHguZSArIDE7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBrID0gTmFOO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBrO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBhIHdob2xlIG51bWJlciB1c2luZ1xyXG4gICAqIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAucm91bmQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgeC5lICsgMSwgQ3Rvci5yb3VuZGluZyk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNpbmUgb2YgdGhlIHZhbHVlIGluIHJhZGlhbnMgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWy0xLCAxXVxyXG4gICAqXHJcbiAgICogc2luKHgpID0geCAtIHheMy8zISArIHheNS81ISAtIC4uLlxyXG4gICAqXHJcbiAgICogc2luKDApICAgICAgICAgPSAwXHJcbiAgICogc2luKC0wKSAgICAgICAgPSAtMFxyXG4gICAqIHNpbihJbmZpbml0eSkgID0gTmFOXHJcbiAgICogc2luKC1JbmZpbml0eSkgPSBOYU5cclxuICAgKiBzaW4oTmFOKSAgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC5zaW5lID0gUC5zaW4gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgcHIsIHJtLFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKCF4LmlzRmluaXRlKCkpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG4gICAgaWYgKHguaXNaZXJvKCkpIHJldHVybiBuZXcgQ3Rvcih4KTtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwciArIE1hdGgubWF4KHguZSwgeC5zZCgpKSArIExPR19CQVNFO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IDE7XHJcblxyXG4gICAgeCA9IHNpbmUoQ3RvciwgdG9MZXNzVGhhbkhhbGZQaShDdG9yLCB4KSk7XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPiAyID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNxdWFyZSByb290IG9mIHRoaXMgRGVjaW1hbCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiAgc3FydCgtbikgPSAgTlxyXG4gICAqICBzcXJ0KE4pICA9ICBOXHJcbiAgICogIHNxcnQoLUkpID0gIE5cclxuICAgKiAgc3FydChJKSAgPSAgSVxyXG4gICAqICBzcXJ0KDApICA9ICAwXHJcbiAgICogIHNxcnQoLTApID0gLTBcclxuICAgKlxyXG4gICAqL1xyXG4gIFAuc3F1YXJlUm9vdCA9IFAuc3FydCA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBtLCBuLCBzZCwgciwgcmVwLCB0LFxyXG4gICAgICB4ID0gdGhpcyxcclxuICAgICAgZCA9IHguZCxcclxuICAgICAgZSA9IHguZSxcclxuICAgICAgcyA9IHgucyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgLy8gTmVnYXRpdmUvTmFOL0luZmluaXR5L3plcm8/XHJcbiAgICBpZiAocyAhPT0gMSB8fCAhZCB8fCAhZFswXSkge1xyXG4gICAgICByZXR1cm4gbmV3IEN0b3IoIXMgfHwgcyA8IDAgJiYgKCFkIHx8IGRbMF0pID8gTmFOIDogZCA/IHggOiAxIC8gMCk7XHJcbiAgICB9XHJcblxyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBJbml0aWFsIGVzdGltYXRlLlxyXG4gICAgcyA9IE1hdGguc3FydCgreCk7XHJcblxyXG4gICAgLy8gTWF0aC5zcXJ0IHVuZGVyZmxvdy9vdmVyZmxvdz9cclxuICAgIC8vIFBhc3MgeCB0byBNYXRoLnNxcnQgYXMgaW50ZWdlciwgdGhlbiBhZGp1c3QgdGhlIGV4cG9uZW50IG9mIHRoZSByZXN1bHQuXHJcbiAgICBpZiAocyA9PSAwIHx8IHMgPT0gMSAvIDApIHtcclxuICAgICAgbiA9IGRpZ2l0c1RvU3RyaW5nKGQpO1xyXG5cclxuICAgICAgaWYgKChuLmxlbmd0aCArIGUpICUgMiA9PSAwKSBuICs9ICcwJztcclxuICAgICAgcyA9IE1hdGguc3FydChuKTtcclxuICAgICAgZSA9IG1hdGhmbG9vcigoZSArIDEpIC8gMikgLSAoZSA8IDAgfHwgZSAlIDIpO1xyXG5cclxuICAgICAgaWYgKHMgPT0gMSAvIDApIHtcclxuICAgICAgICBuID0gJzVlJyArIGU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgbiA9IHMudG9FeHBvbmVudGlhbCgpO1xyXG4gICAgICAgIG4gPSBuLnNsaWNlKDAsIG4uaW5kZXhPZignZScpICsgMSkgKyBlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByID0gbmV3IEN0b3Iobik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByID0gbmV3IEN0b3Iocy50b1N0cmluZygpKTtcclxuICAgIH1cclxuXHJcbiAgICBzZCA9IChlID0gQ3Rvci5wcmVjaXNpb24pICsgMztcclxuXHJcbiAgICAvLyBOZXd0b24tUmFwaHNvbiBpdGVyYXRpb24uXHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgIHQgPSByO1xyXG4gICAgICByID0gdC5wbHVzKGRpdmlkZSh4LCB0LCBzZCArIDIsIDEpKS50aW1lcygwLjUpO1xyXG5cclxuICAgICAgLy8gVE9ETz8gUmVwbGFjZSB3aXRoIGZvci1sb29wIGFuZCBjaGVja1JvdW5kaW5nRGlnaXRzLlxyXG4gICAgICBpZiAoZGlnaXRzVG9TdHJpbmcodC5kKS5zbGljZSgwLCBzZCkgPT09IChuID0gZGlnaXRzVG9TdHJpbmcoci5kKSkuc2xpY2UoMCwgc2QpKSB7XHJcbiAgICAgICAgbiA9IG4uc2xpY2Uoc2QgLSAzLCBzZCArIDEpO1xyXG5cclxuICAgICAgICAvLyBUaGUgNHRoIHJvdW5kaW5nIGRpZ2l0IG1heSBiZSBpbiBlcnJvciBieSAtMSBzbyBpZiB0aGUgNCByb3VuZGluZyBkaWdpdHMgYXJlIDk5OTkgb3JcclxuICAgICAgICAvLyA0OTk5LCBpLmUuIGFwcHJvYWNoaW5nIGEgcm91bmRpbmcgYm91bmRhcnksIGNvbnRpbnVlIHRoZSBpdGVyYXRpb24uXHJcbiAgICAgICAgaWYgKG4gPT0gJzk5OTknIHx8ICFyZXAgJiYgbiA9PSAnNDk5OScpIHtcclxuXHJcbiAgICAgICAgICAvLyBPbiB0aGUgZmlyc3QgaXRlcmF0aW9uIG9ubHksIGNoZWNrIHRvIHNlZSBpZiByb3VuZGluZyB1cCBnaXZlcyB0aGUgZXhhY3QgcmVzdWx0IGFzIHRoZVxyXG4gICAgICAgICAgLy8gbmluZXMgbWF5IGluZmluaXRlbHkgcmVwZWF0LlxyXG4gICAgICAgICAgaWYgKCFyZXApIHtcclxuICAgICAgICAgICAgZmluYWxpc2UodCwgZSArIDEsIDApO1xyXG5cclxuICAgICAgICAgICAgaWYgKHQudGltZXModCkuZXEoeCkpIHtcclxuICAgICAgICAgICAgICByID0gdDtcclxuICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHNkICs9IDQ7XHJcbiAgICAgICAgICByZXAgPSAxO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhcmUgbnVsbCwgMHswLDR9IG9yIDUwezAsM30sIGNoZWNrIGZvciBhbiBleGFjdCByZXN1bHQuXHJcbiAgICAgICAgICAvLyBJZiBub3QsIHRoZW4gdGhlcmUgYXJlIGZ1cnRoZXIgZGlnaXRzIGFuZCBtIHdpbGwgYmUgdHJ1dGh5LlxyXG4gICAgICAgICAgaWYgKCErbiB8fCAhK24uc2xpY2UoMSkgJiYgbi5jaGFyQXQoMCkgPT0gJzUnKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgICAgIGZpbmFsaXNlKHIsIGUgKyAxLCAxKTtcclxuICAgICAgICAgICAgbSA9ICFyLnRpbWVzKHIpLmVxKHgpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UociwgZSwgQ3Rvci5yb3VuZGluZywgbSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHRhbmdlbnQgb2YgdGhlIHZhbHVlIGluIHJhZGlhbnMgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqXHJcbiAgICogRG9tYWluOiBbLUluZmluaXR5LCBJbmZpbml0eV1cclxuICAgKiBSYW5nZTogWy1JbmZpbml0eSwgSW5maW5pdHldXHJcbiAgICpcclxuICAgKiB0YW4oMCkgICAgICAgICA9IDBcclxuICAgKiB0YW4oLTApICAgICAgICA9IC0wXHJcbiAgICogdGFuKEluZmluaXR5KSAgPSBOYU5cclxuICAgKiB0YW4oLUluZmluaXR5KSA9IE5hTlxyXG4gICAqIHRhbihOYU4pICAgICAgID0gTmFOXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRhbmdlbnQgPSBQLnRhbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHZhciBwciwgcm0sXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5ldyBDdG9yKE5hTik7XHJcbiAgICBpZiAoeC5pc1plcm8oKSkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIHByID0gQ3Rvci5wcmVjaXNpb247XHJcbiAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByICsgMTA7XHJcbiAgICBDdG9yLnJvdW5kaW5nID0gMTtcclxuXHJcbiAgICB4ID0geC5zaW4oKTtcclxuICAgIHgucyA9IDE7XHJcbiAgICB4ID0gZGl2aWRlKHgsIG5ldyBDdG9yKDEpLm1pbnVzKHgudGltZXMoeCkpLnNxcnQoKSwgcHIgKyAxMCwgMCk7XHJcblxyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgIEN0b3Iucm91bmRpbmcgPSBybTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UocXVhZHJhbnQgPT0gMiB8fCBxdWFkcmFudCA9PSA0ID8geC5uZWcoKSA6IHgsIHByLCBybSwgdHJ1ZSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIG4gKiAwID0gMFxyXG4gICAqICBuICogTiA9IE5cclxuICAgKiAgbiAqIEkgPSBJXHJcbiAgICogIDAgKiBuID0gMFxyXG4gICAqICAwICogMCA9IDBcclxuICAgKiAgMCAqIE4gPSBOXHJcbiAgICogIDAgKiBJID0gTlxyXG4gICAqICBOICogbiA9IE5cclxuICAgKiAgTiAqIDAgPSBOXHJcbiAgICogIE4gKiBOID0gTlxyXG4gICAqICBOICogSSA9IE5cclxuICAgKiAgSSAqIG4gPSBJXHJcbiAgICogIEkgKiAwID0gTlxyXG4gICAqICBJICogTiA9IE5cclxuICAgKiAgSSAqIEkgPSBJXHJcbiAgICpcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGlzIERlY2ltYWwgdGltZXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudGltZXMgPSBQLm11bCA9IGZ1bmN0aW9uICh5KSB7XHJcbiAgICB2YXIgY2FycnksIGUsIGksIGssIHIsIHJMLCB0LCB4ZEwsIHlkTCxcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICB4ZCA9IHguZCxcclxuICAgICAgeWQgPSAoeSA9IG5ldyBDdG9yKHkpKS5kO1xyXG5cclxuICAgIHkucyAqPSB4LnM7XHJcblxyXG4gICAgIC8vIElmIGVpdGhlciBpcyBOYU4sIMKxSW5maW5pdHkgb3IgwrEwLi4uXHJcbiAgICBpZiAoIXhkIHx8ICF4ZFswXSB8fCAheWQgfHwgIXlkWzBdKSB7XHJcblxyXG4gICAgICByZXR1cm4gbmV3IEN0b3IoIXkucyB8fCB4ZCAmJiAheGRbMF0gJiYgIXlkIHx8IHlkICYmICF5ZFswXSAmJiAheGRcclxuXHJcbiAgICAgICAgLy8gUmV0dXJuIE5hTiBpZiBlaXRoZXIgaXMgTmFOLlxyXG4gICAgICAgIC8vIFJldHVybiBOYU4gaWYgeCBpcyDCsTAgYW5kIHkgaXMgwrFJbmZpbml0eSwgb3IgeSBpcyDCsTAgYW5kIHggaXMgwrFJbmZpbml0eS5cclxuICAgICAgICA/IE5hTlxyXG5cclxuICAgICAgICAvLyBSZXR1cm4gwrFJbmZpbml0eSBpZiBlaXRoZXIgaXMgwrFJbmZpbml0eS5cclxuICAgICAgICAvLyBSZXR1cm4gwrEwIGlmIGVpdGhlciBpcyDCsTAuXHJcbiAgICAgICAgOiAheGQgfHwgIXlkID8geS5zIC8gMCA6IHkucyAqIDApO1xyXG4gICAgfVxyXG5cclxuICAgIGUgPSBtYXRoZmxvb3IoeC5lIC8gTE9HX0JBU0UpICsgbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuICAgIHhkTCA9IHhkLmxlbmd0aDtcclxuICAgIHlkTCA9IHlkLmxlbmd0aDtcclxuXHJcbiAgICAvLyBFbnN1cmUgeGQgcG9pbnRzIHRvIHRoZSBsb25nZXIgYXJyYXkuXHJcbiAgICBpZiAoeGRMIDwgeWRMKSB7XHJcbiAgICAgIHIgPSB4ZDtcclxuICAgICAgeGQgPSB5ZDtcclxuICAgICAgeWQgPSByO1xyXG4gICAgICByTCA9IHhkTDtcclxuICAgICAgeGRMID0geWRMO1xyXG4gICAgICB5ZEwgPSByTDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsaXNlIHRoZSByZXN1bHQgYXJyYXkgd2l0aCB6ZXJvcy5cclxuICAgIHIgPSBbXTtcclxuICAgIHJMID0geGRMICsgeWRMO1xyXG4gICAgZm9yIChpID0gckw7IGktLTspIHIucHVzaCgwKTtcclxuXHJcbiAgICAvLyBNdWx0aXBseSFcclxuICAgIGZvciAoaSA9IHlkTDsgLS1pID49IDA7KSB7XHJcbiAgICAgIGNhcnJ5ID0gMDtcclxuICAgICAgZm9yIChrID0geGRMICsgaTsgayA+IGk7KSB7XHJcbiAgICAgICAgdCA9IHJba10gKyB5ZFtpXSAqIHhkW2sgLSBpIC0gMV0gKyBjYXJyeTtcclxuICAgICAgICByW2stLV0gPSB0ICUgQkFTRSB8IDA7XHJcbiAgICAgICAgY2FycnkgPSB0IC8gQkFTRSB8IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJba10gPSAocltrXSArIGNhcnJ5KSAlIEJBU0UgfCAwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFJlbW92ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgIGZvciAoOyAhclstLXJMXTspIHIucG9wKCk7XHJcblxyXG4gICAgaWYgKGNhcnJ5KSArK2U7XHJcbiAgICBlbHNlIHIuc2hpZnQoKTtcclxuXHJcbiAgICB5LmQgPSByO1xyXG4gICAgeS5lID0gZ2V0QmFzZTEwRXhwb25lbnQociwgZSk7XHJcblxyXG4gICAgcmV0dXJuIGV4dGVybmFsID8gZmluYWxpc2UoeSwgQ3Rvci5wcmVjaXNpb24sIEN0b3Iucm91bmRpbmcpIDogeTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBzdHJpbmcgcmVwcmVzZW50aW5nIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgaW4gYmFzZSAyLCByb3VuZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICAgKlxyXG4gICAqIElmIHRoZSBvcHRpb25hbCBgc2RgIGFyZ3VtZW50IGlzIHByZXNlbnQgdGhlbiByZXR1cm4gYmluYXJ5IGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqXHJcbiAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b0JpbmFyeSA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAyLCBzZCwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwgcm91bmRlZCB0byBhIG1heGltdW0gb2YgYGRwYFxyXG4gICAqIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYCBvciBgcm91bmRpbmdgIGlmIGBybWAgaXMgb21pdHRlZC5cclxuICAgKlxyXG4gICAqIElmIGBkcGAgaXMgb21pdHRlZCwgcmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b0RlY2ltYWxQbGFjZXMgPSBQLnRvRFAgPSBmdW5jdGlvbiAoZHAsIHJtKSB7XHJcbiAgICB2YXIgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIHggPSBuZXcgQ3Rvcih4KTtcclxuICAgIGlmIChkcCA9PT0gdm9pZCAwKSByZXR1cm4geDtcclxuXHJcbiAgICBjaGVja0ludDMyKGRwLCAwLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuXHJcbiAgICByZXR1cm4gZmluYWxpc2UoeCwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGluIGV4cG9uZW50aWFsIG5vdGF0aW9uIHJvdW5kZWQgdG9cclxuICAgKiBgZHBgIGZpeGVkIGRlY2ltYWwgcGxhY2VzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIFtkcF0ge251bWJlcn0gRGVjaW1hbCBwbGFjZXMuIEludGVnZXIsIDAgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b0V4cG9uZW50aWFsID0gZnVuY3Rpb24gKGRwLCBybSkge1xyXG4gICAgdmFyIHN0cixcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmIChkcCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHRydWUpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgY2hlY2tJbnQzMihkcCwgMCwgTUFYX0RJR0lUUyk7XHJcblxyXG4gICAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG5cclxuICAgICAgeCA9IGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBkcCArIDEsIHJtKTtcclxuICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgdHJ1ZSwgZHAgKyAxKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geC5pc05lZygpICYmICF4LmlzWmVybygpID8gJy0nICsgc3RyIDogc3RyO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBub3JtYWwgKGZpeGVkLXBvaW50KSBub3RhdGlvbiB0b1xyXG4gICAqIGBkcGAgZml4ZWQgZGVjaW1hbCBwbGFjZXMgYW5kIHJvdW5kZWQgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gIG9yIGByb3VuZGluZ2AgaWYgYHJtYCBpc1xyXG4gICAqIG9taXR0ZWQuXHJcbiAgICpcclxuICAgKiBBcyB3aXRoIEphdmFTY3JpcHQgbnVtYmVycywgKC0wKS50b0ZpeGVkKDApIGlzICcwJywgYnV0IGUuZy4gKC0wLjAwMDAxKS50b0ZpeGVkKDApIGlzICctMCcuXHJcbiAgICpcclxuICAgKiBbZHBdIHtudW1iZXJ9IERlY2ltYWwgcGxhY2VzLiBJbnRlZ2VyLCAwIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gICAqIFtybV0ge251bWJlcn0gUm91bmRpbmcgbW9kZS4gSW50ZWdlciwgMCB0byA4IGluY2x1c2l2ZS5cclxuICAgKlxyXG4gICAqICgtMCkudG9GaXhlZCgwKSBpcyAnMCcsIGJ1dCAoLTAuMSkudG9GaXhlZCgwKSBpcyAnLTAnLlxyXG4gICAqICgtMCkudG9GaXhlZCgxKSBpcyAnMC4wJywgYnV0ICgtMC4wMSkudG9GaXhlZCgxKSBpcyAnLTAuMCcuXHJcbiAgICogKC0wKS50b0ZpeGVkKDMpIGlzICcwLjAwMCcuXHJcbiAgICogKC0wLjUpLnRvRml4ZWQoMCkgaXMgJy0wJy5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudG9GaXhlZCA9IGZ1bmN0aW9uIChkcCwgcm0pIHtcclxuICAgIHZhciBzdHIsIHksXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoZHAgPT09IHZvaWQgMCkge1xyXG4gICAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNoZWNrSW50MzIoZHAsIDAsIE1BWF9ESUdJVFMpO1xyXG5cclxuICAgICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIHkgPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgZHAgKyB4LmUgKyAxLCBybSk7XHJcbiAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHksIGZhbHNlLCBkcCArIHkuZSArIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFRvIGRldGVybWluZSB3aGV0aGVyIHRvIGFkZCB0aGUgbWludXMgc2lnbiBsb29rIGF0IHRoZSB2YWx1ZSBiZWZvcmUgaXQgd2FzIHJvdW5kZWQsXHJcbiAgICAvLyBpLmUuIGxvb2sgYXQgYHhgIHJhdGhlciB0aGFuIGB5YC5cclxuICAgIHJldHVybiB4LmlzTmVnKCkgJiYgIXguaXNaZXJvKCkgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGFuIGFycmF5IHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIGFzIGEgc2ltcGxlIGZyYWN0aW9uIHdpdGggYW4gaW50ZWdlclxyXG4gICAqIG51bWVyYXRvciBhbmQgYW4gaW50ZWdlciBkZW5vbWluYXRvci5cclxuICAgKlxyXG4gICAqIFRoZSBkZW5vbWluYXRvciB3aWxsIGJlIGEgcG9zaXRpdmUgbm9uLXplcm8gdmFsdWUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvIHRoZSBzcGVjaWZpZWQgbWF4aW11bVxyXG4gICAqIGRlbm9taW5hdG9yLiBJZiBhIG1heGltdW0gZGVub21pbmF0b3IgaXMgbm90IHNwZWNpZmllZCwgdGhlIGRlbm9taW5hdG9yIHdpbGwgYmUgdGhlIGxvd2VzdFxyXG4gICAqIHZhbHVlIG5lY2Vzc2FyeSB0byByZXByZXNlbnQgdGhlIG51bWJlciBleGFjdGx5LlxyXG4gICAqXHJcbiAgICogW21heERdIHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBNYXhpbXVtIGRlbm9taW5hdG9yLiBJbnRlZ2VyID49IDEgYW5kIDwgSW5maW5pdHkuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRvRnJhY3Rpb24gPSBmdW5jdGlvbiAobWF4RCkge1xyXG4gICAgdmFyIGQsIGQwLCBkMSwgZDIsIGUsIGssIG4sIG4wLCBuMSwgcHIsIHEsIHIsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICB4ZCA9IHguZCxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgaWYgKCF4ZCkgcmV0dXJuIG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIG4xID0gZDAgPSBuZXcgQ3RvcigxKTtcclxuICAgIGQxID0gbjAgPSBuZXcgQ3RvcigwKTtcclxuXHJcbiAgICBkID0gbmV3IEN0b3IoZDEpO1xyXG4gICAgZSA9IGQuZSA9IGdldFByZWNpc2lvbih4ZCkgLSB4LmUgLSAxO1xyXG4gICAgayA9IGUgJSBMT0dfQkFTRTtcclxuICAgIGQuZFswXSA9IG1hdGhwb3coMTAsIGsgPCAwID8gTE9HX0JBU0UgKyBrIDogayk7XHJcblxyXG4gICAgaWYgKG1heEQgPT0gbnVsbCkge1xyXG5cclxuICAgICAgLy8gZCBpcyAxMCoqZSwgdGhlIG1pbmltdW0gbWF4LWRlbm9taW5hdG9yIG5lZWRlZC5cclxuICAgICAgbWF4RCA9IGUgPiAwID8gZCA6IG4xO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbiA9IG5ldyBDdG9yKG1heEQpO1xyXG4gICAgICBpZiAoIW4uaXNJbnQoKSB8fCBuLmx0KG4xKSkgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgbik7XHJcbiAgICAgIG1heEQgPSBuLmd0KGQpID8gKGUgPiAwID8gZCA6IG4xKSA6IG47XHJcbiAgICB9XHJcblxyXG4gICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgIG4gPSBuZXcgQ3RvcihkaWdpdHNUb1N0cmluZyh4ZCkpO1xyXG4gICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgIEN0b3IucHJlY2lzaW9uID0gZSA9IHhkLmxlbmd0aCAqIExPR19CQVNFICogMjtcclxuXHJcbiAgICBmb3IgKDs7KSAge1xyXG4gICAgICBxID0gZGl2aWRlKG4sIGQsIDAsIDEsIDEpO1xyXG4gICAgICBkMiA9IGQwLnBsdXMocS50aW1lcyhkMSkpO1xyXG4gICAgICBpZiAoZDIuY21wKG1heEQpID09IDEpIGJyZWFrO1xyXG4gICAgICBkMCA9IGQxO1xyXG4gICAgICBkMSA9IGQyO1xyXG4gICAgICBkMiA9IG4xO1xyXG4gICAgICBuMSA9IG4wLnBsdXMocS50aW1lcyhkMikpO1xyXG4gICAgICBuMCA9IGQyO1xyXG4gICAgICBkMiA9IGQ7XHJcbiAgICAgIGQgPSBuLm1pbnVzKHEudGltZXMoZDIpKTtcclxuICAgICAgbiA9IGQyO1xyXG4gICAgfVxyXG5cclxuICAgIGQyID0gZGl2aWRlKG1heEQubWludXMoZDApLCBkMSwgMCwgMSwgMSk7XHJcbiAgICBuMCA9IG4wLnBsdXMoZDIudGltZXMobjEpKTtcclxuICAgIGQwID0gZDAucGx1cyhkMi50aW1lcyhkMSkpO1xyXG4gICAgbjAucyA9IG4xLnMgPSB4LnM7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHdoaWNoIGZyYWN0aW9uIGlzIGNsb3NlciB0byB4LCBuMC9kMCBvciBuMS9kMT9cclxuICAgIHIgPSBkaXZpZGUobjEsIGQxLCBlLCAxKS5taW51cyh4KS5hYnMoKS5jbXAoZGl2aWRlKG4wLCBkMCwgZSwgMSkubWludXMoeCkuYWJzKCkpIDwgMVxyXG4gICAgICAgID8gW24xLCBkMV0gOiBbbjAsIGQwXTtcclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHByO1xyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiByO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBiYXNlIDE2LCByb3VuZCB0byBgc2RgIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJtYC5cclxuICAgKlxyXG4gICAqIElmIHRoZSBvcHRpb25hbCBgc2RgIGFyZ3VtZW50IGlzIHByZXNlbnQgdGhlbiByZXR1cm4gYmluYXJ5IGV4cG9uZW50aWFsIG5vdGF0aW9uLlxyXG4gICAqXHJcbiAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b0hleGFkZWNpbWFsID0gUC50b0hleCA9IGZ1bmN0aW9uIChzZCwgcm0pIHtcclxuICAgIHJldHVybiB0b1N0cmluZ0JpbmFyeSh0aGlzLCAxNiwgc2QsIHJtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm5zIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5lYXJlc3QgbXVsdGlwbGUgb2YgYHlgIGluIHRoZSBkaXJlY3Rpb24gb2Ygcm91bmRpbmdcclxuICAgKiBtb2RlIGBybWAsIG9yIGBEZWNpbWFsLnJvdW5kaW5nYCBpZiBgcm1gIGlzIG9taXR0ZWQsIHRvIHRoZSB2YWx1ZSBvZiB0aGlzIERlY2ltYWwuXHJcbiAgICpcclxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIHdpbGwgYWx3YXlzIGhhdmUgdGhlIHNhbWUgc2lnbiBhcyB0aGlzIERlY2ltYWwsIHVubGVzcyBlaXRoZXIgdGhpcyBEZWNpbWFsXHJcbiAgICogb3IgYHlgIGlzIE5hTiwgaW4gd2hpY2ggY2FzZSB0aGUgcmV0dXJuIHZhbHVlIHdpbGwgYmUgYWxzbyBiZSBOYU4uXHJcbiAgICpcclxuICAgKiBUaGUgcmV0dXJuIHZhbHVlIGlzIG5vdCBhZmZlY3RlZCBieSB0aGUgdmFsdWUgb2YgYHByZWNpc2lvbmAuXHJcbiAgICpcclxuICAgKiB5IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBUaGUgbWFnbml0dWRlIHRvIHJvdW5kIHRvIGEgbXVsdGlwbGUgb2YuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ3RvTmVhcmVzdCgpIHJvdW5kaW5nIG1vZGUgbm90IGFuIGludGVnZXI6IHtybX0nXHJcbiAgICogJ3RvTmVhcmVzdCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b05lYXJlc3QgPSBmdW5jdGlvbiAoeSwgcm0pIHtcclxuICAgIHZhciB4ID0gdGhpcyxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3I7XHJcblxyXG4gICAgeCA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIGlmICh5ID09IG51bGwpIHtcclxuXHJcbiAgICAgIC8vIElmIHggaXMgbm90IGZpbml0ZSwgcmV0dXJuIHguXHJcbiAgICAgIGlmICgheC5kKSByZXR1cm4geDtcclxuXHJcbiAgICAgIHkgPSBuZXcgQ3RvcigxKTtcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeSA9IG5ldyBDdG9yKHkpO1xyXG4gICAgICBpZiAocm0gPT09IHZvaWQgMCkge1xyXG4gICAgICAgIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gSWYgeCBpcyBub3QgZmluaXRlLCByZXR1cm4geCBpZiB5IGlzIG5vdCBOYU4sIGVsc2UgTmFOLlxyXG4gICAgICBpZiAoIXguZCkgcmV0dXJuIHkucyA/IHggOiB5O1xyXG5cclxuICAgICAgLy8gSWYgeSBpcyBub3QgZmluaXRlLCByZXR1cm4gSW5maW5pdHkgd2l0aCB0aGUgc2lnbiBvZiB4IGlmIHkgaXMgSW5maW5pdHksIGVsc2UgTmFOLlxyXG4gICAgICBpZiAoIXkuZCkge1xyXG4gICAgICAgIGlmICh5LnMpIHkucyA9IHgucztcclxuICAgICAgICByZXR1cm4geTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHkgaXMgbm90IHplcm8sIGNhbGN1bGF0ZSB0aGUgbmVhcmVzdCBtdWx0aXBsZSBvZiB5IHRvIHguXHJcbiAgICBpZiAoeS5kWzBdKSB7XHJcbiAgICAgIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgICAgIHggPSBkaXZpZGUoeCwgeSwgMCwgcm0sIDEpLnRpbWVzKHkpO1xyXG4gICAgICBleHRlcm5hbCA9IHRydWU7XHJcbiAgICAgIGZpbmFsaXNlKHgpO1xyXG5cclxuICAgIC8vIElmIHkgaXMgemVybywgcmV0dXJuIHplcm8gd2l0aCB0aGUgc2lnbiBvZiB4LlxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgeS5zID0geC5zO1xyXG4gICAgICB4ID0geTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBjb252ZXJ0ZWQgdG8gYSBudW1iZXIgcHJpbWl0aXZlLlxyXG4gICAqIFplcm8ga2VlcHMgaXRzIHNpZ24uXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRvTnVtYmVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgcmV0dXJuICt0aGlzO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCBpbiBiYXNlIDgsIHJvdW5kIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICAgKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIG9wdGlvbmFsIGBzZGAgYXJndW1lbnQgaXMgcHJlc2VudCB0aGVuIHJldHVybiBiaW5hcnkgZXhwb25lbnRpYWwgbm90YXRpb24uXHJcbiAgICpcclxuICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRvT2N0YWwgPSBmdW5jdGlvbiAoc2QsIHJtKSB7XHJcbiAgICByZXR1cm4gdG9TdHJpbmdCaW5hcnkodGhpcywgOCwgc2QsIHJtKTtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJhaXNlZCB0byB0aGUgcG93ZXIgYHlgLCByb3VuZGVkXHJcbiAgICogdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIEVDTUFTY3JpcHQgY29tcGxpYW50LlxyXG4gICAqXHJcbiAgICogICBwb3coeCwgTmFOKSAgICAgICAgICAgICAgICAgICAgICAgICAgID0gTmFOXHJcbiAgICogICBwb3coeCwgwrEwKSAgICAgICAgICAgICAgICAgICAgICAgICAgICA9IDFcclxuXHJcbiAgICogICBwb3coTmFOLCBub24temVybykgICAgICAgICAgICAgICAgICAgID0gTmFOXHJcbiAgICogICBwb3coYWJzKHgpID4gMSwgK0luZmluaXR5KSAgICAgICAgICAgID0gK0luZmluaXR5XHJcbiAgICogICBwb3coYWJzKHgpID4gMSwgLUluZmluaXR5KSAgICAgICAgICAgID0gKzBcclxuICAgKiAgIHBvdyhhYnMoeCkgPT0gMSwgwrFJbmZpbml0eSkgICAgICAgICAgID0gTmFOXHJcbiAgICogICBwb3coYWJzKHgpIDwgMSwgK0luZmluaXR5KSAgICAgICAgICAgID0gKzBcclxuICAgKiAgIHBvdyhhYnMoeCkgPCAxLCAtSW5maW5pdHkpICAgICAgICAgICAgPSArSW5maW5pdHlcclxuICAgKiAgIHBvdygrSW5maW5pdHksIHkgPiAwKSAgICAgICAgICAgICAgICAgPSArSW5maW5pdHlcclxuICAgKiAgIHBvdygrSW5maW5pdHksIHkgPCAwKSAgICAgICAgICAgICAgICAgPSArMFxyXG4gICAqICAgcG93KC1JbmZpbml0eSwgb2RkIGludGVnZXIgPiAwKSAgICAgICA9IC1JbmZpbml0eVxyXG4gICAqICAgcG93KC1JbmZpbml0eSwgZXZlbiBpbnRlZ2VyID4gMCkgICAgICA9ICtJbmZpbml0eVxyXG4gICAqICAgcG93KC1JbmZpbml0eSwgb2RkIGludGVnZXIgPCAwKSAgICAgICA9IC0wXHJcbiAgICogICBwb3coLUluZmluaXR5LCBldmVuIGludGVnZXIgPCAwKSAgICAgID0gKzBcclxuICAgKiAgIHBvdygrMCwgeSA+IDApICAgICAgICAgICAgICAgICAgICAgICAgPSArMFxyXG4gICAqICAgcG93KCswLCB5IDwgMCkgICAgICAgICAgICAgICAgICAgICAgICA9ICtJbmZpbml0eVxyXG4gICAqICAgcG93KC0wLCBvZGQgaW50ZWdlciA+IDApICAgICAgICAgICAgICA9IC0wXHJcbiAgICogICBwb3coLTAsIGV2ZW4gaW50ZWdlciA+IDApICAgICAgICAgICAgID0gKzBcclxuICAgKiAgIHBvdygtMCwgb2RkIGludGVnZXIgPCAwKSAgICAgICAgICAgICAgPSAtSW5maW5pdHlcclxuICAgKiAgIHBvdygtMCwgZXZlbiBpbnRlZ2VyIDwgMCkgICAgICAgICAgICAgPSArSW5maW5pdHlcclxuICAgKiAgIHBvdyhmaW5pdGUgeCA8IDAsIGZpbml0ZSBub24taW50ZWdlcikgPSBOYU5cclxuICAgKlxyXG4gICAqIEZvciBub24taW50ZWdlciBvciB2ZXJ5IGxhcmdlIGV4cG9uZW50cyBwb3coeCwgeSkgaXMgY2FsY3VsYXRlZCB1c2luZ1xyXG4gICAqXHJcbiAgICogICB4XnkgPSBleHAoeSpsbih4KSlcclxuICAgKlxyXG4gICAqIEFzc3VtaW5nIHRoZSBmaXJzdCAxNSByb3VuZGluZyBkaWdpdHMgYXJlIGVhY2ggZXF1YWxseSBsaWtlbHkgdG8gYmUgYW55IGRpZ2l0IDAtOSwgdGhlXHJcbiAgICogcHJvYmFiaWxpdHkgb2YgYW4gaW5jb3JyZWN0bHkgcm91bmRlZCByZXN1bHRcclxuICAgKiBQKFs0OV05ezE0fSB8IFs1MF0wezE0fSkgPSAyICogMC4yICogMTBeLTE0ID0gNGUtMTUgPSAxLzIuNWUrMTRcclxuICAgKiBpLmUuIDEgaW4gMjUwLDAwMCwwMDAsMDAwLDAwMFxyXG4gICAqXHJcbiAgICogSWYgYSByZXN1bHQgaXMgaW5jb3JyZWN0bHkgcm91bmRlZCB0aGUgbWF4aW11bSBlcnJvciB3aWxsIGJlIDEgdWxwICh1bml0IGluIGxhc3QgcGxhY2UpLlxyXG4gICAqXHJcbiAgICogeSB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH0gVGhlIHBvd2VyIHRvIHdoaWNoIHRvIHJhaXNlIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudG9Qb3dlciA9IFAucG93ID0gZnVuY3Rpb24gKHkpIHtcclxuICAgIHZhciBlLCBrLCBwciwgciwgcm0sIHMsXHJcbiAgICAgIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgeW4gPSArKHkgPSBuZXcgQ3Rvcih5KSk7XHJcblxyXG4gICAgLy8gRWl0aGVyIMKxSW5maW5pdHksIE5hTiBvciDCsTA/XHJcbiAgICBpZiAoIXguZCB8fCAheS5kIHx8ICF4LmRbMF0gfHwgIXkuZFswXSkgcmV0dXJuIG5ldyBDdG9yKG1hdGhwb3coK3gsIHluKSk7XHJcblxyXG4gICAgeCA9IG5ldyBDdG9yKHgpO1xyXG5cclxuICAgIGlmICh4LmVxKDEpKSByZXR1cm4geDtcclxuXHJcbiAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG5cclxuICAgIGlmICh5LmVxKDEpKSByZXR1cm4gZmluYWxpc2UoeCwgcHIsIHJtKTtcclxuXHJcbiAgICAvLyB5IGV4cG9uZW50XHJcbiAgICBlID0gbWF0aGZsb29yKHkuZSAvIExPR19CQVNFKTtcclxuXHJcbiAgICAvLyBJZiB5IGlzIGEgc21hbGwgaW50ZWdlciB1c2UgdGhlICdleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZycgYWxnb3JpdGhtLlxyXG4gICAgaWYgKGUgPj0geS5kLmxlbmd0aCAtIDEgJiYgKGsgPSB5biA8IDAgPyAteW4gOiB5bikgPD0gTUFYX1NBRkVfSU5URUdFUikge1xyXG4gICAgICByID0gaW50UG93KEN0b3IsIHgsIGssIHByKTtcclxuICAgICAgcmV0dXJuIHkucyA8IDAgPyBuZXcgQ3RvcigxKS5kaXYocikgOiBmaW5hbGlzZShyLCBwciwgcm0pO1xyXG4gICAgfVxyXG5cclxuICAgIHMgPSB4LnM7XHJcblxyXG4gICAgLy8gaWYgeCBpcyBuZWdhdGl2ZVxyXG4gICAgaWYgKHMgPCAwKSB7XHJcblxyXG4gICAgICAvLyBpZiB5IGlzIG5vdCBhbiBpbnRlZ2VyXHJcbiAgICAgIGlmIChlIDwgeS5kLmxlbmd0aCAtIDEpIHJldHVybiBuZXcgQ3RvcihOYU4pO1xyXG5cclxuICAgICAgLy8gUmVzdWx0IGlzIHBvc2l0aXZlIGlmIHggaXMgbmVnYXRpdmUgYW5kIHRoZSBsYXN0IGRpZ2l0IG9mIGludGVnZXIgeSBpcyBldmVuLlxyXG4gICAgICBpZiAoKHkuZFtlXSAmIDEpID09IDApIHMgPSAxO1xyXG5cclxuICAgICAgLy8gaWYgeC5lcSgtMSlcclxuICAgICAgaWYgKHguZSA9PSAwICYmIHguZFswXSA9PSAxICYmIHguZC5sZW5ndGggPT0gMSkge1xyXG4gICAgICAgIHgucyA9IHM7XHJcbiAgICAgICAgcmV0dXJuIHg7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBFc3RpbWF0ZSByZXN1bHQgZXhwb25lbnQuXHJcbiAgICAvLyB4XnkgPSAxMF5lLCAgd2hlcmUgZSA9IHkgKiBsb2cxMCh4KVxyXG4gICAgLy8gbG9nMTAoeCkgPSBsb2cxMCh4X3NpZ25pZmljYW5kKSArIHhfZXhwb25lbnRcclxuICAgIC8vIGxvZzEwKHhfc2lnbmlmaWNhbmQpID0gbG4oeF9zaWduaWZpY2FuZCkgLyBsbigxMClcclxuICAgIGsgPSBtYXRocG93KCt4LCB5bik7XHJcbiAgICBlID0gayA9PSAwIHx8ICFpc0Zpbml0ZShrKVxyXG4gICAgICA/IG1hdGhmbG9vcih5biAqIChNYXRoLmxvZygnMC4nICsgZGlnaXRzVG9TdHJpbmcoeC5kKSkgLyBNYXRoLkxOMTAgKyB4LmUgKyAxKSlcclxuICAgICAgOiBuZXcgQ3RvcihrICsgJycpLmU7XHJcblxyXG4gICAgLy8gRXhwb25lbnQgZXN0aW1hdGUgbWF5IGJlIGluY29ycmVjdCBlLmcuIHg6IDAuOTk5OTk5OTk5OTk5OTk5OTk5LCB5OiAyLjI5LCBlOiAwLCByLmU6IC0xLlxyXG5cclxuICAgIC8vIE92ZXJmbG93L3VuZGVyZmxvdz9cclxuICAgIGlmIChlID4gQ3Rvci5tYXhFICsgMSB8fCBlIDwgQ3Rvci5taW5FIC0gMSkgcmV0dXJuIG5ldyBDdG9yKGUgPiAwID8gcyAvIDAgOiAwKTtcclxuXHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IHgucyA9IDE7XHJcblxyXG4gICAgLy8gRXN0aW1hdGUgdGhlIGV4dHJhIGd1YXJkIGRpZ2l0cyBuZWVkZWQgdG8gZW5zdXJlIGZpdmUgY29ycmVjdCByb3VuZGluZyBkaWdpdHMgZnJvbVxyXG4gICAgLy8gbmF0dXJhbExvZ2FyaXRobSh4KS4gRXhhbXBsZSBvZiBmYWlsdXJlIHdpdGhvdXQgdGhlc2UgZXh0cmEgZGlnaXRzIChwcmVjaXNpb246IDEwKTpcclxuICAgIC8vIG5ldyBEZWNpbWFsKDIuMzI0NTYpLnBvdygnMjA4Nzk4NzQzNjUzNDU2Ni40NjQxMScpXHJcbiAgICAvLyBzaG91bGQgYmUgMS4xNjIzNzc4MjNlKzc2NDkxNDkwNTE3MzgxNSwgYnV0IGlzIDEuMTYyMzU1ODIzZSs3NjQ5MTQ5MDUxNzM4MTVcclxuICAgIGsgPSBNYXRoLm1pbigxMiwgKGUgKyAnJykubGVuZ3RoKTtcclxuXHJcbiAgICAvLyByID0geF55ID0gZXhwKHkqbG4oeCkpXHJcbiAgICByID0gbmF0dXJhbEV4cG9uZW50aWFsKHkudGltZXMobmF0dXJhbExvZ2FyaXRobSh4LCBwciArIGspKSwgcHIpO1xyXG5cclxuICAgIC8vIHIgbWF5IGJlIEluZmluaXR5LCBlLmcuICgwLjk5OTk5OTk5OTk5OTk5OTkpLnBvdygtMWUrNDApXHJcbiAgICBpZiAoci5kKSB7XHJcblxyXG4gICAgICAvLyBUcnVuY2F0ZSB0byB0aGUgcmVxdWlyZWQgcHJlY2lzaW9uIHBsdXMgZml2ZSByb3VuZGluZyBkaWdpdHMuXHJcbiAgICAgIHIgPSBmaW5hbGlzZShyLCBwciArIDUsIDEpO1xyXG5cclxuICAgICAgLy8gSWYgdGhlIHJvdW5kaW5nIGRpZ2l0cyBhcmUgWzQ5XTk5OTkgb3IgWzUwXTAwMDAgaW5jcmVhc2UgdGhlIHByZWNpc2lvbiBieSAxMCBhbmQgcmVjYWxjdWxhdGVcclxuICAgICAgLy8gdGhlIHJlc3VsdC5cclxuICAgICAgaWYgKGNoZWNrUm91bmRpbmdEaWdpdHMoci5kLCBwciwgcm0pKSB7XHJcbiAgICAgICAgZSA9IHByICsgMTA7XHJcblxyXG4gICAgICAgIC8vIFRydW5jYXRlIHRvIHRoZSBpbmNyZWFzZWQgcHJlY2lzaW9uIHBsdXMgZml2ZSByb3VuZGluZyBkaWdpdHMuXHJcbiAgICAgICAgciA9IGZpbmFsaXNlKG5hdHVyYWxFeHBvbmVudGlhbCh5LnRpbWVzKG5hdHVyYWxMb2dhcml0aG0oeCwgZSArIGspKSwgZSksIGUgKyA1LCAxKTtcclxuXHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIDE0IG5pbmVzIGZyb20gdGhlIDJuZCByb3VuZGluZyBkaWdpdCAodGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0IG1heSBiZSA0IG9yIDkpLlxyXG4gICAgICAgIGlmICgrZGlnaXRzVG9TdHJpbmcoci5kKS5zbGljZShwciArIDEsIHByICsgMTUpICsgMSA9PSAxZTE0KSB7XHJcbiAgICAgICAgICByID0gZmluYWxpc2UociwgcHIgKyAxLCAwKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICByLnMgPSBzO1xyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG4gICAgQ3Rvci5yb3VuZGluZyA9IHJtO1xyXG5cclxuICAgIHJldHVybiBmaW5hbGlzZShyLCBwciwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbCByb3VuZGVkIHRvIGBzZGAgc2lnbmlmaWNhbnQgZGlnaXRzXHJcbiAgICogdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogUmV0dXJuIGV4cG9uZW50aWFsIG5vdGF0aW9uIGlmIGBzZGAgaXMgbGVzcyB0aGFuIHRoZSBudW1iZXIgb2YgZGlnaXRzIG5lY2Vzc2FyeSB0byByZXByZXNlbnRcclxuICAgKiB0aGUgaW50ZWdlciBwYXJ0IG9mIHRoZSB2YWx1ZSBpbiBub3JtYWwgbm90YXRpb24uXHJcbiAgICpcclxuICAgKiBbc2RdIHtudW1iZXJ9IFNpZ25pZmljYW50IGRpZ2l0cy4gSW50ZWdlciwgMSB0byBNQVhfRElHSVRTIGluY2x1c2l2ZS5cclxuICAgKiBbcm1dIHtudW1iZXJ9IFJvdW5kaW5nIG1vZGUuIEludGVnZXIsIDAgdG8gOCBpbmNsdXNpdmUuXHJcbiAgICpcclxuICAgKi9cclxuICBQLnRvUHJlY2lzaW9uID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgdmFyIHN0cixcclxuICAgICAgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmIChzZCA9PT0gdm9pZCAwKSB7XHJcbiAgICAgIHN0ciA9IGZpbml0ZVRvU3RyaW5nKHgsIHguZSA8PSBDdG9yLnRvRXhwTmVnIHx8IHguZSA+PSBDdG9yLnRvRXhwUG9zKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xyXG5cclxuICAgICAgaWYgKHJtID09PSB2b2lkIDApIHJtID0gQ3Rvci5yb3VuZGluZztcclxuICAgICAgZWxzZSBjaGVja0ludDMyKHJtLCAwLCA4KTtcclxuXHJcbiAgICAgIHggPSBmaW5hbGlzZShuZXcgQ3Rvcih4KSwgc2QsIHJtKTtcclxuICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgc2QgPD0geC5lIHx8IHguZSA8PSBDdG9yLnRvRXhwTmVnLCBzZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/ICctJyArIHN0ciA6IHN0cjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHJvdW5kZWQgdG8gYSBtYXhpbXVtIG9mIGBzZGBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm1gLCBvciB0byBgcHJlY2lzaW9uYCBhbmQgYHJvdW5kaW5nYCByZXNwZWN0aXZlbHkgaWZcclxuICAgKiBvbWl0dGVkLlxyXG4gICAqXHJcbiAgICogW3NkXSB7bnVtYmVyfSBTaWduaWZpY2FudCBkaWdpdHMuIEludGVnZXIsIDEgdG8gTUFYX0RJR0lUUyBpbmNsdXNpdmUuXHJcbiAgICogW3JtXSB7bnVtYmVyfSBSb3VuZGluZyBtb2RlLiBJbnRlZ2VyLCAwIHRvIDggaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICogJ3RvU0QoKSBkaWdpdHMgb3V0IG9mIHJhbmdlOiB7c2R9J1xyXG4gICAqICd0b1NEKCkgZGlnaXRzIG5vdCBhbiBpbnRlZ2VyOiB7c2R9J1xyXG4gICAqICd0b1NEKCkgcm91bmRpbmcgbW9kZSBub3QgYW4gaW50ZWdlcjoge3JtfSdcclxuICAgKiAndG9TRCgpIHJvdW5kaW5nIG1vZGUgb3V0IG9mIHJhbmdlOiB7cm19J1xyXG4gICAqXHJcbiAgICovXHJcbiAgUC50b1NpZ25pZmljYW50RGlnaXRzID0gUC50b1NEID0gZnVuY3Rpb24gKHNkLCBybSkge1xyXG4gICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcjtcclxuXHJcbiAgICBpZiAoc2QgPT09IHZvaWQgMCkge1xyXG4gICAgICBzZCA9IEN0b3IucHJlY2lzaW9uO1xyXG4gICAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjaGVja0ludDMyKHNkLCAxLCBNQVhfRElHSVRTKTtcclxuXHJcbiAgICAgIGlmIChybSA9PT0gdm9pZCAwKSBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICAgIGVsc2UgY2hlY2tJbnQzMihybSwgMCwgOCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZpbmFsaXNlKG5ldyBDdG9yKHgpLCBzZCwgcm0pO1xyXG4gIH07XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIHN0cmluZyByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoaXMgRGVjaW1hbC5cclxuICAgKlxyXG4gICAqIFJldHVybiBleHBvbmVudGlhbCBub3RhdGlvbiBpZiB0aGlzIERlY2ltYWwgaGFzIGEgcG9zaXRpdmUgZXhwb25lbnQgZXF1YWwgdG8gb3IgZ3JlYXRlciB0aGFuXHJcbiAgICogYHRvRXhwUG9zYCwgb3IgYSBuZWdhdGl2ZSBleHBvbmVudCBlcXVhbCB0byBvciBsZXNzIHRoYW4gYHRvRXhwTmVnYC5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICB2YXIgeCA9IHRoaXMsXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICBzdHIgPSBmaW5pdGVUb1N0cmluZyh4LCB4LmUgPD0gQ3Rvci50b0V4cE5lZyB8fCB4LmUgPj0gQ3Rvci50b0V4cFBvcyk7XHJcblxyXG4gICAgcmV0dXJuIHguaXNOZWcoKSAmJiAheC5pc1plcm8oKSA/ICctJyArIHN0ciA6IHN0cjtcclxuICB9O1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsIHRydW5jYXRlZCB0byBhIHdob2xlIG51bWJlci5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudHJ1bmNhdGVkID0gUC50cnVuYyA9IGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiBmaW5hbGlzZShuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKSwgdGhpcy5lICsgMSwgMSk7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgc3RyaW5nIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhpcyBEZWNpbWFsLlxyXG4gICAqIFVubGlrZSBgdG9TdHJpbmdgLCBuZWdhdGl2ZSB6ZXJvIHdpbGwgaW5jbHVkZSB0aGUgbWludXMgc2lnbi5cclxuICAgKlxyXG4gICAqL1xyXG4gIFAudmFsdWVPZiA9IFAudG9KU09OID0gZnVuY3Rpb24gKCkge1xyXG4gICAgdmFyIHggPSB0aGlzLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCwgeC5lIDw9IEN0b3IudG9FeHBOZWcgfHwgeC5lID49IEN0b3IudG9FeHBQb3MpO1xyXG5cclxuICAgIHJldHVybiB4LmlzTmVnKCkgPyAnLScgKyBzdHIgOiBzdHI7XHJcbiAgfTtcclxuXHJcblxyXG4gIC8vIEhlbHBlciBmdW5jdGlvbnMgZm9yIERlY2ltYWwucHJvdG90eXBlIChQKSBhbmQvb3IgRGVjaW1hbCBtZXRob2RzLCBhbmQgdGhlaXIgY2FsbGVycy5cclxuXHJcblxyXG4gIC8qXHJcbiAgICogIGRpZ2l0c1RvU3RyaW5nICAgICAgICAgICBQLmN1YmVSb290LCBQLmxvZ2FyaXRobSwgUC5zcXVhcmVSb290LCBQLnRvRnJhY3Rpb24sIFAudG9Qb3dlcixcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIGZpbml0ZVRvU3RyaW5nLCBuYXR1cmFsRXhwb25lbnRpYWwsIG5hdHVyYWxMb2dhcml0aG1cclxuICAgKiAgY2hlY2tJbnQzMiAgICAgICAgICAgICAgIFAudG9EZWNpbWFsUGxhY2VzLCBQLnRvRXhwb25lbnRpYWwsIFAudG9GaXhlZCwgUC50b05lYXJlc3QsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLnRvUHJlY2lzaW9uLCBQLnRvU2lnbmlmaWNhbnREaWdpdHMsIHRvU3RyaW5nQmluYXJ5LCByYW5kb21cclxuICAgKiAgY2hlY2tSb3VuZGluZ0RpZ2l0cyAgICAgIFAubG9nYXJpdGhtLCBQLnRvUG93ZXIsIG5hdHVyYWxFeHBvbmVudGlhbCwgbmF0dXJhbExvZ2FyaXRobVxyXG4gICAqICBjb252ZXJ0QmFzZSAgICAgICAgICAgICAgdG9TdHJpbmdCaW5hcnksIHBhcnNlT3RoZXJcclxuICAgKiAgY29zICAgICAgICAgICAgICAgICAgICAgIFAuY29zXHJcbiAgICogIGRpdmlkZSAgICAgICAgICAgICAgICAgICBQLmF0YW5oLCBQLmN1YmVSb290LCBQLmRpdmlkZWRCeSwgUC5kaXZpZGVkVG9JbnRlZ2VyQnksXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLmxvZ2FyaXRobSwgUC5tb2R1bG8sIFAuc3F1YXJlUm9vdCwgUC50YW4sIFAudGFuaCwgUC50b0ZyYWN0aW9uLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50b05lYXJlc3QsIHRvU3RyaW5nQmluYXJ5LCBuYXR1cmFsRXhwb25lbnRpYWwsIG5hdHVyYWxMb2dhcml0aG0sXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0YXlsb3JTZXJpZXMsIGF0YW4yLCBwYXJzZU90aGVyXHJcbiAgICogIGZpbmFsaXNlICAgICAgICAgICAgICAgICBQLmFic29sdXRlVmFsdWUsIFAuYXRhbiwgUC5hdGFuaCwgUC5jZWlsLCBQLmNvcywgUC5jb3NoLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5jdWJlUm9vdCwgUC5kaXZpZGVkVG9JbnRlZ2VyQnksIFAuZmxvb3IsIFAubG9nYXJpdGhtLCBQLm1pbnVzLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC5tb2R1bG8sIFAubmVnYXRlZCwgUC5wbHVzLCBQLnJvdW5kLCBQLnNpbiwgUC5zaW5oLCBQLnNxdWFyZVJvb3QsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBQLnRhbiwgUC50aW1lcywgUC50b0RlY2ltYWxQbGFjZXMsIFAudG9FeHBvbmVudGlhbCwgUC50b0ZpeGVkLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50b05lYXJlc3QsIFAudG9Qb3dlciwgUC50b1ByZWNpc2lvbiwgUC50b1NpZ25pZmljYW50RGlnaXRzLFxyXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgUC50cnVuY2F0ZWQsIGRpdmlkZSwgZ2V0TG4xMCwgZ2V0UGksIG5hdHVyYWxFeHBvbmVudGlhbCxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdHVyYWxMb2dhcml0aG0sIGNlaWwsIGZsb29yLCByb3VuZCwgdHJ1bmNcclxuICAgKiAgZmluaXRlVG9TdHJpbmcgICAgICAgICAgIFAudG9FeHBvbmVudGlhbCwgUC50b0ZpeGVkLCBQLnRvUHJlY2lzaW9uLCBQLnRvU3RyaW5nLCBQLnZhbHVlT2YsXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICB0b1N0cmluZ0JpbmFyeVxyXG4gICAqICBnZXRCYXNlMTBFeHBvbmVudCAgICAgICAgUC5taW51cywgUC5wbHVzLCBQLnRpbWVzLCBwYXJzZU90aGVyXHJcbiAgICogIGdldExuMTAgICAgICAgICAgICAgICAgICBQLmxvZ2FyaXRobSwgbmF0dXJhbExvZ2FyaXRobVxyXG4gICAqICBnZXRQaSAgICAgICAgICAgICAgICAgICAgUC5hY29zLCBQLmFzaW4sIFAuYXRhbiwgdG9MZXNzVGhhbkhhbGZQaSwgYXRhbjJcclxuICAgKiAgZ2V0UHJlY2lzaW9uICAgICAgICAgICAgIFAucHJlY2lzaW9uLCBQLnRvRnJhY3Rpb25cclxuICAgKiAgZ2V0WmVyb1N0cmluZyAgICAgICAgICAgIGRpZ2l0c1RvU3RyaW5nLCBmaW5pdGVUb1N0cmluZ1xyXG4gICAqICBpbnRQb3cgICAgICAgICAgICAgICAgICAgUC50b1Bvd2VyLCBwYXJzZU90aGVyXHJcbiAgICogIGlzT2RkICAgICAgICAgICAgICAgICAgICB0b0xlc3NUaGFuSGFsZlBpXHJcbiAgICogIG1heE9yTWluICAgICAgICAgICAgICAgICBtYXgsIG1pblxyXG4gICAqICBuYXR1cmFsRXhwb25lbnRpYWwgICAgICAgUC5uYXR1cmFsRXhwb25lbnRpYWwsIFAudG9Qb3dlclxyXG4gICAqICBuYXR1cmFsTG9nYXJpdGhtICAgICAgICAgUC5hY29zaCwgUC5hc2luaCwgUC5hdGFuaCwgUC5sb2dhcml0aG0sIFAubmF0dXJhbExvZ2FyaXRobSxcclxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgIFAudG9Qb3dlciwgbmF0dXJhbEV4cG9uZW50aWFsXHJcbiAgICogIG5vbkZpbml0ZVRvU3RyaW5nICAgICAgICBmaW5pdGVUb1N0cmluZywgdG9TdHJpbmdCaW5hcnlcclxuICAgKiAgcGFyc2VEZWNpbWFsICAgICAgICAgICAgIERlY2ltYWxcclxuICAgKiAgcGFyc2VPdGhlciAgICAgICAgICAgICAgIERlY2ltYWxcclxuICAgKiAgc2luICAgICAgICAgICAgICAgICAgICAgIFAuc2luXHJcbiAgICogIHRheWxvclNlcmllcyAgICAgICAgICAgICBQLmNvc2gsIFAuc2luaCwgY29zLCBzaW5cclxuICAgKiAgdG9MZXNzVGhhbkhhbGZQaSAgICAgICAgIFAuY29zLCBQLnNpblxyXG4gICAqICB0b1N0cmluZ0JpbmFyeSAgICAgICAgICAgUC50b0JpbmFyeSwgUC50b0hleGFkZWNpbWFsLCBQLnRvT2N0YWxcclxuICAgKiAgdHJ1bmNhdGUgICAgICAgICAgICAgICAgIGludFBvd1xyXG4gICAqXHJcbiAgICogIFRocm93czogICAgICAgICAgICAgICAgICBQLmxvZ2FyaXRobSwgUC5wcmVjaXNpb24sIFAudG9GcmFjdGlvbiwgY2hlY2tJbnQzMiwgZ2V0TG4xMCwgZ2V0UGksXHJcbiAgICogICAgICAgICAgICAgICAgICAgICAgICAgICBuYXR1cmFsTG9nYXJpdGhtLCBjb25maWcsIHBhcnNlT3RoZXIsIHJhbmRvbSwgRGVjaW1hbFxyXG4gICAqL1xyXG5cclxuXHJcbiAgZnVuY3Rpb24gZGlnaXRzVG9TdHJpbmcoZCkge1xyXG4gICAgdmFyIGksIGssIHdzLFxyXG4gICAgICBpbmRleE9mTGFzdFdvcmQgPSBkLmxlbmd0aCAtIDEsXHJcbiAgICAgIHN0ciA9ICcnLFxyXG4gICAgICB3ID0gZFswXTtcclxuXHJcbiAgICBpZiAoaW5kZXhPZkxhc3RXb3JkID4gMCkge1xyXG4gICAgICBzdHIgKz0gdztcclxuICAgICAgZm9yIChpID0gMTsgaSA8IGluZGV4T2ZMYXN0V29yZDsgaSsrKSB7XHJcbiAgICAgICAgd3MgPSBkW2ldICsgJyc7XHJcbiAgICAgICAgayA9IExPR19CQVNFIC0gd3MubGVuZ3RoO1xyXG4gICAgICAgIGlmIChrKSBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcclxuICAgICAgICBzdHIgKz0gd3M7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHcgPSBkW2ldO1xyXG4gICAgICB3cyA9IHcgKyAnJztcclxuICAgICAgayA9IExPR19CQVNFIC0gd3MubGVuZ3RoO1xyXG4gICAgICBpZiAoaykgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XHJcbiAgICB9IGVsc2UgaWYgKHcgPT09IDApIHtcclxuICAgICAgcmV0dXJuICcwJztcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgemVyb3Mgb2YgbGFzdCB3LlxyXG4gICAgZm9yICg7IHcgJSAxMCA9PT0gMDspIHcgLz0gMTA7XHJcblxyXG4gICAgcmV0dXJuIHN0ciArIHc7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gY2hlY2tJbnQzMihpLCBtaW4sIG1heCkge1xyXG4gICAgaWYgKGkgIT09IH5+aSB8fCBpIDwgbWluIHx8IGkgPiBtYXgpIHtcclxuICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgaSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBDaGVjayA1IHJvdW5kaW5nIGRpZ2l0cyBpZiBgcmVwZWF0aW5nYCBpcyBudWxsLCA0IG90aGVyd2lzZS5cclxuICAgKiBgcmVwZWF0aW5nID09IG51bGxgIGlmIGNhbGxlciBpcyBgbG9nYCBvciBgcG93YCxcclxuICAgKiBgcmVwZWF0aW5nICE9IG51bGxgIGlmIGNhbGxlciBpcyBgbmF0dXJhbExvZ2FyaXRobWAgb3IgYG5hdHVyYWxFeHBvbmVudGlhbGAuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2hlY2tSb3VuZGluZ0RpZ2l0cyhkLCBpLCBybSwgcmVwZWF0aW5nKSB7XHJcbiAgICB2YXIgZGksIGssIHIsIHJkO1xyXG5cclxuICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBhcnJheSBkLlxyXG4gICAgZm9yIChrID0gZFswXTsgayA+PSAxMDsgayAvPSAxMCkgLS1pO1xyXG5cclxuICAgIC8vIElzIHRoZSByb3VuZGluZyBkaWdpdCBpbiB0aGUgZmlyc3Qgd29yZCBvZiBkP1xyXG4gICAgaWYgKC0taSA8IDApIHtcclxuICAgICAgaSArPSBMT0dfQkFTRTtcclxuICAgICAgZGkgPSAwO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgZGkgPSBNYXRoLmNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuICAgICAgaSAlPSBMT0dfQkFTRTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBpIGlzIHRoZSBpbmRleCAoMCAtIDYpIG9mIHRoZSByb3VuZGluZyBkaWdpdC5cclxuICAgIC8vIEUuZy4gaWYgd2l0aGluIHRoZSB3b3JkIDM0ODc1NjMgdGhlIGZpcnN0IHJvdW5kaW5nIGRpZ2l0IGlzIDUsXHJcbiAgICAvLyB0aGVuIGkgPSA0LCBrID0gMTAwMCwgcmQgPSAzNDg3NTYzICUgMTAwMCA9IDU2M1xyXG4gICAgayA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gaSk7XHJcbiAgICByZCA9IGRbZGldICUgayB8IDA7XHJcblxyXG4gICAgaWYgKHJlcGVhdGluZyA9PSBudWxsKSB7XHJcbiAgICAgIGlmIChpIDwgMykge1xyXG4gICAgICAgIGlmIChpID09IDApIHJkID0gcmQgLyAxMDAgfCAwO1xyXG4gICAgICAgIGVsc2UgaWYgKGkgPT0gMSkgcmQgPSByZCAvIDEwIHwgMDtcclxuICAgICAgICByID0gcm0gPCA0ICYmIHJkID09IDk5OTk5IHx8IHJtID4gMyAmJiByZCA9PSA0OTk5OSB8fCByZCA9PSA1MDAwMCB8fCByZCA9PSAwO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHIgPSAocm0gPCA0ICYmIHJkICsgMSA9PSBrIHx8IHJtID4gMyAmJiByZCArIDEgPT0gayAvIDIpICYmXHJcbiAgICAgICAgICAoZFtkaSArIDFdIC8gayAvIDEwMCB8IDApID09IG1hdGhwb3coMTAsIGkgLSAyKSAtIDEgfHxcclxuICAgICAgICAgICAgKHJkID09IGsgLyAyIHx8IHJkID09IDApICYmIChkW2RpICsgMV0gLyBrIC8gMTAwIHwgMCkgPT0gMDtcclxuICAgICAgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKGkgPCA0KSB7XHJcbiAgICAgICAgaWYgKGkgPT0gMCkgcmQgPSByZCAvIDEwMDAgfCAwO1xyXG4gICAgICAgIGVsc2UgaWYgKGkgPT0gMSkgcmQgPSByZCAvIDEwMCB8IDA7XHJcbiAgICAgICAgZWxzZSBpZiAoaSA9PSAyKSByZCA9IHJkIC8gMTAgfCAwO1xyXG4gICAgICAgIHIgPSAocmVwZWF0aW5nIHx8IHJtIDwgNCkgJiYgcmQgPT0gOTk5OSB8fCAhcmVwZWF0aW5nICYmIHJtID4gMyAmJiByZCA9PSA0OTk5O1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHIgPSAoKHJlcGVhdGluZyB8fCBybSA8IDQpICYmIHJkICsgMSA9PSBrIHx8XHJcbiAgICAgICAgKCFyZXBlYXRpbmcgJiYgcm0gPiAzKSAmJiByZCArIDEgPT0gayAvIDIpICYmXHJcbiAgICAgICAgICAoZFtkaSArIDFdIC8gayAvIDEwMDAgfCAwKSA9PSBtYXRocG93KDEwLCBpIC0gMykgLSAxO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ29udmVydCBzdHJpbmcgb2YgYGJhc2VJbmAgdG8gYW4gYXJyYXkgb2YgbnVtYmVycyBvZiBgYmFzZU91dGAuXHJcbiAgLy8gRWcuIGNvbnZlcnRCYXNlKCcyNTUnLCAxMCwgMTYpIHJldHVybnMgWzE1LCAxNV0uXHJcbiAgLy8gRWcuIGNvbnZlcnRCYXNlKCdmZicsIDE2LCAxMCkgcmV0dXJucyBbMiwgNSwgNV0uXHJcbiAgZnVuY3Rpb24gY29udmVydEJhc2Uoc3RyLCBiYXNlSW4sIGJhc2VPdXQpIHtcclxuICAgIHZhciBqLFxyXG4gICAgICBhcnIgPSBbMF0sXHJcbiAgICAgIGFyckwsXHJcbiAgICAgIGkgPSAwLFxyXG4gICAgICBzdHJMID0gc3RyLmxlbmd0aDtcclxuXHJcbiAgICBmb3IgKDsgaSA8IHN0ckw7KSB7XHJcbiAgICAgIGZvciAoYXJyTCA9IGFyci5sZW5ndGg7IGFyckwtLTspIGFyclthcnJMXSAqPSBiYXNlSW47XHJcbiAgICAgIGFyclswXSArPSBOVU1FUkFMUy5pbmRleE9mKHN0ci5jaGFyQXQoaSsrKSk7XHJcbiAgICAgIGZvciAoaiA9IDA7IGogPCBhcnIubGVuZ3RoOyBqKyspIHtcclxuICAgICAgICBpZiAoYXJyW2pdID4gYmFzZU91dCAtIDEpIHtcclxuICAgICAgICAgIGlmIChhcnJbaiArIDFdID09PSB2b2lkIDApIGFycltqICsgMV0gPSAwO1xyXG4gICAgICAgICAgYXJyW2ogKyAxXSArPSBhcnJbal0gLyBiYXNlT3V0IHwgMDtcclxuICAgICAgICAgIGFycltqXSAlPSBiYXNlT3V0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhcnIucmV2ZXJzZSgpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogY29zKHgpID0gMSAtIHheMi8yISArIHheNC80ISAtIC4uLlxyXG4gICAqIHx4fCA8IHBpLzJcclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNvc2luZShDdG9yLCB4KSB7XHJcbiAgICB2YXIgaywgbGVuLCB5O1xyXG5cclxuICAgIGlmICh4LmlzWmVybygpKSByZXR1cm4geDtcclxuXHJcbiAgICAvLyBBcmd1bWVudCByZWR1Y3Rpb246IGNvcyg0eCkgPSA4Kihjb3NeNCh4KSAtIGNvc14yKHgpKSArIDFcclxuICAgIC8vIGkuZS4gY29zKHgpID0gOCooY29zXjQoeC80KSAtIGNvc14yKHgvNCkpICsgMVxyXG5cclxuICAgIC8vIEVzdGltYXRlIHRoZSBvcHRpbXVtIG51bWJlciBvZiB0aW1lcyB0byB1c2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi5cclxuICAgIGxlbiA9IHguZC5sZW5ndGg7XHJcbiAgICBpZiAobGVuIDwgMzIpIHtcclxuICAgICAgayA9IE1hdGguY2VpbChsZW4gLyAzKTtcclxuICAgICAgeSA9ICgxIC8gdGlueVBvdyg0LCBrKSkudG9TdHJpbmcoKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGsgPSAxNjtcclxuICAgICAgeSA9ICcyLjMyODMwNjQzNjUzODY5NjI4OTA2MjVlLTEwJztcclxuICAgIH1cclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiArPSBrO1xyXG5cclxuICAgIHggPSB0YXlsb3JTZXJpZXMoQ3RvciwgMSwgeC50aW1lcyh5KSwgbmV3IEN0b3IoMSkpO1xyXG5cclxuICAgIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgICBmb3IgKHZhciBpID0gazsgaS0tOykge1xyXG4gICAgICB2YXIgY29zMnggPSB4LnRpbWVzKHgpO1xyXG4gICAgICB4ID0gY29zMngudGltZXMoY29zMngpLm1pbnVzKGNvczJ4KS50aW1lcyg4KS5wbHVzKDEpO1xyXG4gICAgfVxyXG5cclxuICAgIEN0b3IucHJlY2lzaW9uIC09IGs7XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBQZXJmb3JtIGRpdmlzaW9uIGluIHRoZSBzcGVjaWZpZWQgYmFzZS5cclxuICAgKi9cclxuICB2YXIgZGl2aWRlID0gKGZ1bmN0aW9uICgpIHtcclxuXHJcbiAgICAvLyBBc3N1bWVzIG5vbi16ZXJvIHggYW5kIGssIGFuZCBoZW5jZSBub24temVybyByZXN1bHQuXHJcbiAgICBmdW5jdGlvbiBtdWx0aXBseUludGVnZXIoeCwgaywgYmFzZSkge1xyXG4gICAgICB2YXIgdGVtcCxcclxuICAgICAgICBjYXJyeSA9IDAsXHJcbiAgICAgICAgaSA9IHgubGVuZ3RoO1xyXG5cclxuICAgICAgZm9yICh4ID0geC5zbGljZSgpOyBpLS07KSB7XHJcbiAgICAgICAgdGVtcCA9IHhbaV0gKiBrICsgY2Fycnk7XHJcbiAgICAgICAgeFtpXSA9IHRlbXAgJSBiYXNlIHwgMDtcclxuICAgICAgICBjYXJyeSA9IHRlbXAgLyBiYXNlIHwgMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGNhcnJ5KSB4LnVuc2hpZnQoY2FycnkpO1xyXG5cclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgZnVuY3Rpb24gY29tcGFyZShhLCBiLCBhTCwgYkwpIHtcclxuICAgICAgdmFyIGksIHI7XHJcblxyXG4gICAgICBpZiAoYUwgIT0gYkwpIHtcclxuICAgICAgICByID0gYUwgPiBiTCA/IDEgOiAtMTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBmb3IgKGkgPSByID0gMDsgaSA8IGFMOyBpKyspIHtcclxuICAgICAgICAgIGlmIChhW2ldICE9IGJbaV0pIHtcclxuICAgICAgICAgICAgciA9IGFbaV0gPiBiW2ldID8gMSA6IC0xO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiByO1xyXG4gICAgfVxyXG5cclxuICAgIGZ1bmN0aW9uIHN1YnRyYWN0KGEsIGIsIGFMLCBiYXNlKSB7XHJcbiAgICAgIHZhciBpID0gMDtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IGIgZnJvbSBhLlxyXG4gICAgICBmb3IgKDsgYUwtLTspIHtcclxuICAgICAgICBhW2FMXSAtPSBpO1xyXG4gICAgICAgIGkgPSBhW2FMXSA8IGJbYUxdID8gMSA6IDA7XHJcbiAgICAgICAgYVthTF0gPSBpICogYmFzZSArIGFbYUxdIC0gYlthTF07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFJlbW92ZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgIWFbMF0gJiYgYS5sZW5ndGggPiAxOykgYS5zaGlmdCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBmdW5jdGlvbiAoeCwgeSwgcHIsIHJtLCBkcCwgYmFzZSkge1xyXG4gICAgICB2YXIgY21wLCBlLCBpLCBrLCBsb2dCYXNlLCBtb3JlLCBwcm9kLCBwcm9kTCwgcSwgcWQsIHJlbSwgcmVtTCwgcmVtMCwgc2QsIHQsIHhpLCB4TCwgeWQwLFxyXG4gICAgICAgIHlMLCB5eixcclxuICAgICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgICBzaWduID0geC5zID09IHkucyA/IDEgOiAtMSxcclxuICAgICAgICB4ZCA9IHguZCxcclxuICAgICAgICB5ZCA9IHkuZDtcclxuXHJcbiAgICAgIC8vIEVpdGhlciBOYU4sIEluZmluaXR5IG9yIDA/XHJcbiAgICAgIGlmICgheGQgfHwgIXhkWzBdIHx8ICF5ZCB8fCAheWRbMF0pIHtcclxuXHJcbiAgICAgICAgcmV0dXJuIG5ldyBDdG9yKC8vIFJldHVybiBOYU4gaWYgZWl0aGVyIE5hTiwgb3IgYm90aCBJbmZpbml0eSBvciAwLlxyXG4gICAgICAgICAgIXgucyB8fCAheS5zIHx8ICh4ZCA/IHlkICYmIHhkWzBdID09IHlkWzBdIDogIXlkKSA/IE5hTiA6XHJcblxyXG4gICAgICAgICAgLy8gUmV0dXJuIMKxMCBpZiB4IGlzIDAgb3IgeSBpcyDCsUluZmluaXR5LCBvciByZXR1cm4gwrFJbmZpbml0eSBhcyB5IGlzIDAuXHJcbiAgICAgICAgICB4ZCAmJiB4ZFswXSA9PSAwIHx8ICF5ZCA/IHNpZ24gKiAwIDogc2lnbiAvIDApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAoYmFzZSkge1xyXG4gICAgICAgIGxvZ0Jhc2UgPSAxO1xyXG4gICAgICAgIGUgPSB4LmUgLSB5LmU7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgYmFzZSA9IEJBU0U7XHJcbiAgICAgICAgbG9nQmFzZSA9IExPR19CQVNFO1xyXG4gICAgICAgIGUgPSBtYXRoZmxvb3IoeC5lIC8gbG9nQmFzZSkgLSBtYXRoZmxvb3IoeS5lIC8gbG9nQmFzZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHlMID0geWQubGVuZ3RoO1xyXG4gICAgICB4TCA9IHhkLmxlbmd0aDtcclxuICAgICAgcSA9IG5ldyBDdG9yKHNpZ24pO1xyXG4gICAgICBxZCA9IHEuZCA9IFtdO1xyXG5cclxuICAgICAgLy8gUmVzdWx0IGV4cG9uZW50IG1heSBiZSBvbmUgbGVzcyB0aGFuIGUuXHJcbiAgICAgIC8vIFRoZSBkaWdpdCBhcnJheSBvZiBhIERlY2ltYWwgZnJvbSB0b1N0cmluZ0JpbmFyeSBtYXkgaGF2ZSB0cmFpbGluZyB6ZXJvcy5cclxuICAgICAgZm9yIChpID0gMDsgeWRbaV0gPT0gKHhkW2ldIHx8IDApOyBpKyspO1xyXG5cclxuICAgICAgaWYgKHlkW2ldID4gKHhkW2ldIHx8IDApKSBlLS07XHJcblxyXG4gICAgICBpZiAocHIgPT0gbnVsbCkge1xyXG4gICAgICAgIHNkID0gcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgICAgICBybSA9IEN0b3Iucm91bmRpbmc7XHJcbiAgICAgIH0gZWxzZSBpZiAoZHApIHtcclxuICAgICAgICBzZCA9IHByICsgKHguZSAtIHkuZSkgKyAxO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHNkID0gcHI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmIChzZCA8IDApIHtcclxuICAgICAgICBxZC5wdXNoKDEpO1xyXG4gICAgICAgIG1vcmUgPSB0cnVlO1xyXG4gICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAvLyBDb252ZXJ0IHByZWNpc2lvbiBpbiBudW1iZXIgb2YgYmFzZSAxMCBkaWdpdHMgdG8gYmFzZSAxZTcgZGlnaXRzLlxyXG4gICAgICAgIHNkID0gc2QgLyBsb2dCYXNlICsgMiB8IDA7XHJcbiAgICAgICAgaSA9IDA7XHJcblxyXG4gICAgICAgIC8vIGRpdmlzb3IgPCAxZTdcclxuICAgICAgICBpZiAoeUwgPT0gMSkge1xyXG4gICAgICAgICAgayA9IDA7XHJcbiAgICAgICAgICB5ZCA9IHlkWzBdO1xyXG4gICAgICAgICAgc2QrKztcclxuXHJcbiAgICAgICAgICAvLyBrIGlzIHRoZSBjYXJyeS5cclxuICAgICAgICAgIGZvciAoOyAoaSA8IHhMIHx8IGspICYmIHNkLS07IGkrKykge1xyXG4gICAgICAgICAgICB0ID0gayAqIGJhc2UgKyAoeGRbaV0gfHwgMCk7XHJcbiAgICAgICAgICAgIHFkW2ldID0gdCAvIHlkIHwgMDtcclxuICAgICAgICAgICAgayA9IHQgJSB5ZCB8IDA7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgbW9yZSA9IGsgfHwgaSA8IHhMO1xyXG5cclxuICAgICAgICAvLyBkaXZpc29yID49IDFlN1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gTm9ybWFsaXNlIHhkIGFuZCB5ZCBzbyBoaWdoZXN0IG9yZGVyIGRpZ2l0IG9mIHlkIGlzID49IGJhc2UvMlxyXG4gICAgICAgICAgayA9IGJhc2UgLyAoeWRbMF0gKyAxKSB8IDA7XHJcblxyXG4gICAgICAgICAgaWYgKGsgPiAxKSB7XHJcbiAgICAgICAgICAgIHlkID0gbXVsdGlwbHlJbnRlZ2VyKHlkLCBrLCBiYXNlKTtcclxuICAgICAgICAgICAgeGQgPSBtdWx0aXBseUludGVnZXIoeGQsIGssIGJhc2UpO1xyXG4gICAgICAgICAgICB5TCA9IHlkLmxlbmd0aDtcclxuICAgICAgICAgICAgeEwgPSB4ZC5sZW5ndGg7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgeGkgPSB5TDtcclxuICAgICAgICAgIHJlbSA9IHhkLnNsaWNlKDAsIHlMKTtcclxuICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgIC8vIEFkZCB6ZXJvcyB0byBtYWtlIHJlbWFpbmRlciBhcyBsb25nIGFzIGRpdmlzb3IuXHJcbiAgICAgICAgICBmb3IgKDsgcmVtTCA8IHlMOykgcmVtW3JlbUwrK10gPSAwO1xyXG5cclxuICAgICAgICAgIHl6ID0geWQuc2xpY2UoKTtcclxuICAgICAgICAgIHl6LnVuc2hpZnQoMCk7XHJcbiAgICAgICAgICB5ZDAgPSB5ZFswXTtcclxuXHJcbiAgICAgICAgICBpZiAoeWRbMV0gPj0gYmFzZSAvIDIpICsreWQwO1xyXG5cclxuICAgICAgICAgIGRvIHtcclxuICAgICAgICAgICAgayA9IDA7XHJcblxyXG4gICAgICAgICAgICAvLyBDb21wYXJlIGRpdmlzb3IgYW5kIHJlbWFpbmRlci5cclxuICAgICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAvLyBJZiBkaXZpc29yIDwgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICBpZiAoY21wIDwgMCkge1xyXG5cclxuICAgICAgICAgICAgICAvLyBDYWxjdWxhdGUgdHJpYWwgZGlnaXQsIGsuXHJcbiAgICAgICAgICAgICAgcmVtMCA9IHJlbVswXTtcclxuICAgICAgICAgICAgICBpZiAoeUwgIT0gcmVtTCkgcmVtMCA9IHJlbTAgKiBiYXNlICsgKHJlbVsxXSB8fCAwKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gayB3aWxsIGJlIGhvdyBtYW55IHRpbWVzIHRoZSBkaXZpc29yIGdvZXMgaW50byB0aGUgY3VycmVudCByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgayA9IHJlbTAgLyB5ZDAgfCAwO1xyXG5cclxuICAgICAgICAgICAgICAvLyAgQWxnb3JpdGhtOlxyXG4gICAgICAgICAgICAgIC8vICAxLiBwcm9kdWN0ID0gZGl2aXNvciAqIHRyaWFsIGRpZ2l0IChrKVxyXG4gICAgICAgICAgICAgIC8vICAyLiBpZiBwcm9kdWN0ID4gcmVtYWluZGVyOiBwcm9kdWN0IC09IGRpdmlzb3IsIGstLVxyXG4gICAgICAgICAgICAgIC8vICAzLiByZW1haW5kZXIgLT0gcHJvZHVjdFxyXG4gICAgICAgICAgICAgIC8vICA0LiBpZiBwcm9kdWN0IHdhcyA8IHJlbWFpbmRlciBhdCAyOlxyXG4gICAgICAgICAgICAgIC8vICAgIDUuIGNvbXBhcmUgbmV3IHJlbWFpbmRlciBhbmQgZGl2aXNvclxyXG4gICAgICAgICAgICAgIC8vICAgIDYuIElmIHJlbWFpbmRlciA+IGRpdmlzb3I6IHJlbWFpbmRlciAtPSBkaXZpc29yLCBrKytcclxuXHJcbiAgICAgICAgICAgICAgaWYgKGsgPiAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoayA+PSBiYXNlKSBrID0gYmFzZSAtIDE7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gcHJvZHVjdCA9IGRpdmlzb3IgKiB0cmlhbCBkaWdpdC5cclxuICAgICAgICAgICAgICAgIHByb2QgPSBtdWx0aXBseUludGVnZXIoeWQsIGssIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICAgIHJlbUwgPSByZW0ubGVuZ3RoO1xyXG5cclxuICAgICAgICAgICAgICAgIC8vIENvbXBhcmUgcHJvZHVjdCBhbmQgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgY21wID0gY29tcGFyZShwcm9kLCByZW0sIHByb2RMLCByZW1MKTtcclxuXHJcbiAgICAgICAgICAgICAgICAvLyBwcm9kdWN0ID4gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgaWYgKGNtcCA9PSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgIGstLTtcclxuXHJcbiAgICAgICAgICAgICAgICAgIC8vIFN1YnRyYWN0IGRpdmlzb3IgZnJvbSBwcm9kdWN0LlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChwcm9kLCB5TCA8IHByb2RMID8geXogOiB5ZCwgcHJvZEwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gY21wIGlzIC0xLlxyXG4gICAgICAgICAgICAgICAgLy8gSWYgayBpcyAwLCB0aGVyZSBpcyBubyBuZWVkIHRvIGNvbXBhcmUgeWQgYW5kIHJlbSBhZ2FpbiBiZWxvdywgc28gY2hhbmdlIGNtcCB0byAxXHJcbiAgICAgICAgICAgICAgICAvLyB0byBhdm9pZCBpdC4gSWYgayBpcyAxIHRoZXJlIGlzIGEgbmVlZCB0byBjb21wYXJlIHlkIGFuZCByZW0gYWdhaW4gYmVsb3cuXHJcbiAgICAgICAgICAgICAgICBpZiAoayA9PSAwKSBjbXAgPSBrID0gMTtcclxuICAgICAgICAgICAgICAgIHByb2QgPSB5ZC5zbGljZSgpO1xyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgcHJvZEwgPSBwcm9kLmxlbmd0aDtcclxuICAgICAgICAgICAgICBpZiAocHJvZEwgPCByZW1MKSBwcm9kLnVuc2hpZnQoMCk7XHJcblxyXG4gICAgICAgICAgICAgIC8vIFN1YnRyYWN0IHByb2R1Y3QgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgc3VidHJhY3QocmVtLCBwcm9kLCByZW1MLCBiYXNlKTtcclxuXHJcbiAgICAgICAgICAgICAgLy8gSWYgcHJvZHVjdCB3YXMgPCBwcmV2aW91cyByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgaWYgKGNtcCA9PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gQ29tcGFyZSBkaXZpc29yIGFuZCBuZXcgcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgY21wID0gY29tcGFyZSh5ZCwgcmVtLCB5TCwgcmVtTCk7XHJcblxyXG4gICAgICAgICAgICAgICAgLy8gSWYgZGl2aXNvciA8IG5ldyByZW1haW5kZXIsIHN1YnRyYWN0IGRpdmlzb3IgZnJvbSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgICAgICBpZiAoY21wIDwgMSkge1xyXG4gICAgICAgICAgICAgICAgICBrKys7XHJcblxyXG4gICAgICAgICAgICAgICAgICAvLyBTdWJ0cmFjdCBkaXZpc29yIGZyb20gcmVtYWluZGVyLlxyXG4gICAgICAgICAgICAgICAgICBzdWJ0cmFjdChyZW0sIHlMIDwgcmVtTCA/IHl6IDogeWQsIHJlbUwsIGJhc2UpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgICAgcmVtTCA9IHJlbS5sZW5ndGg7XHJcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoY21wID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgaysrO1xyXG4gICAgICAgICAgICAgIHJlbSA9IFswXTtcclxuICAgICAgICAgICAgfSAgICAvLyBpZiBjbXAgPT09IDEsIGsgd2lsbCBiZSAwXHJcblxyXG4gICAgICAgICAgICAvLyBBZGQgdGhlIG5leHQgZGlnaXQsIGssIHRvIHRoZSByZXN1bHQgYXJyYXkuXHJcbiAgICAgICAgICAgIHFkW2krK10gPSBrO1xyXG5cclxuICAgICAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1haW5kZXIuXHJcbiAgICAgICAgICAgIGlmIChjbXAgJiYgcmVtWzBdKSB7XHJcbiAgICAgICAgICAgICAgcmVtW3JlbUwrK10gPSB4ZFt4aV0gfHwgMDtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICByZW0gPSBbeGRbeGldXTtcclxuICAgICAgICAgICAgICByZW1MID0gMTtcclxuICAgICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIH0gd2hpbGUgKCh4aSsrIDwgeEwgfHwgcmVtWzBdICE9PSB2b2lkIDApICYmIHNkLS0pO1xyXG5cclxuICAgICAgICAgIG1vcmUgPSByZW1bMF0gIT09IHZvaWQgMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIExlYWRpbmcgemVybz9cclxuICAgICAgICBpZiAoIXFkWzBdKSBxZC5zaGlmdCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBsb2dCYXNlIGlzIDEgd2hlbiBkaXZpZGUgaXMgYmVpbmcgdXNlZCBmb3IgYmFzZSBjb252ZXJzaW9uLlxyXG4gICAgICBpZiAobG9nQmFzZSA9PSAxKSB7XHJcbiAgICAgICAgcS5lID0gZTtcclxuICAgICAgICBpbmV4YWN0ID0gbW9yZTtcclxuICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgLy8gVG8gY2FsY3VsYXRlIHEuZSwgZmlyc3QgZ2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHFkWzBdLlxyXG4gICAgICAgIGZvciAoaSA9IDEsIGsgPSBxZFswXTsgayA+PSAxMDsgayAvPSAxMCkgaSsrO1xyXG4gICAgICAgIHEuZSA9IGkgKyBlICogbG9nQmFzZSAtIDE7XHJcblxyXG4gICAgICAgIGZpbmFsaXNlKHEsIGRwID8gcHIgKyBxLmUgKyAxIDogcHIsIHJtLCBtb3JlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIHE7XHJcbiAgICB9O1xyXG4gIH0pKCk7XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJvdW5kIGB4YCB0byBgc2RgIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGBybWAuXHJcbiAgICogQ2hlY2sgZm9yIG92ZXIvdW5kZXItZmxvdy5cclxuICAgKi9cclxuICAgZnVuY3Rpb24gZmluYWxpc2UoeCwgc2QsIHJtLCBpc1RydW5jYXRlZCkge1xyXG4gICAgdmFyIGRpZ2l0cywgaSwgaiwgaywgcmQsIHJvdW5kVXAsIHcsIHhkLCB4ZGksXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIC8vIERvbid0IHJvdW5kIGlmIHNkIGlzIG51bGwgb3IgdW5kZWZpbmVkLlxyXG4gICAgb3V0OiBpZiAoc2QgIT0gbnVsbCkge1xyXG4gICAgICB4ZCA9IHguZDtcclxuXHJcbiAgICAgIC8vIEluZmluaXR5L05hTi5cclxuICAgICAgaWYgKCF4ZCkgcmV0dXJuIHg7XHJcblxyXG4gICAgICAvLyByZDogdGhlIHJvdW5kaW5nIGRpZ2l0LCBpLmUuIHRoZSBkaWdpdCBhZnRlciB0aGUgZGlnaXQgdGhhdCBtYXkgYmUgcm91bmRlZCB1cC5cclxuICAgICAgLy8gdzogdGhlIHdvcmQgb2YgeGQgY29udGFpbmluZyByZCwgYSBiYXNlIDFlNyBudW1iZXIuXHJcbiAgICAgIC8vIHhkaTogdGhlIGluZGV4IG9mIHcgd2l0aGluIHhkLlxyXG4gICAgICAvLyBkaWdpdHM6IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHcuXHJcbiAgICAgIC8vIGk6IHdoYXQgd291bGQgYmUgdGhlIGluZGV4IG9mIHJkIHdpdGhpbiB3IGlmIGFsbCB0aGUgbnVtYmVycyB3ZXJlIDcgZGlnaXRzIGxvbmcgKGkuZS4gaWZcclxuICAgICAgLy8gdGhleSBoYWQgbGVhZGluZyB6ZXJvcylcclxuICAgICAgLy8gajogaWYgPiAwLCB0aGUgYWN0dWFsIGluZGV4IG9mIHJkIHdpdGhpbiB3IChpZiA8IDAsIHJkIGlzIGEgbGVhZGluZyB6ZXJvKS5cclxuXHJcbiAgICAgIC8vIEdldCB0aGUgbGVuZ3RoIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBkaWdpdHMgYXJyYXkgeGQuXHJcbiAgICAgIGZvciAoZGlnaXRzID0gMSwgayA9IHhkWzBdOyBrID49IDEwOyBrIC89IDEwKSBkaWdpdHMrKztcclxuICAgICAgaSA9IHNkIC0gZGlnaXRzO1xyXG5cclxuICAgICAgLy8gSXMgdGhlIHJvdW5kaW5nIGRpZ2l0IGluIHRoZSBmaXJzdCB3b3JkIG9mIHhkP1xyXG4gICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICBpICs9IExPR19CQVNFO1xyXG4gICAgICAgIGogPSBzZDtcclxuICAgICAgICB3ID0geGRbeGRpID0gMF07XHJcblxyXG4gICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiB3LlxyXG4gICAgICAgIHJkID0gdyAvIG1hdGhwb3coMTAsIGRpZ2l0cyAtIGogLSAxKSAlIDEwIHwgMDtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4ZGkgPSBNYXRoLmNlaWwoKGkgKyAxKSAvIExPR19CQVNFKTtcclxuICAgICAgICBrID0geGQubGVuZ3RoO1xyXG4gICAgICAgIGlmICh4ZGkgPj0gaykge1xyXG4gICAgICAgICAgaWYgKGlzVHJ1bmNhdGVkKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBOZWVkZWQgYnkgYG5hdHVyYWxFeHBvbmVudGlhbGAsIGBuYXR1cmFsTG9nYXJpdGhtYCBhbmQgYHNxdWFyZVJvb3RgLlxyXG4gICAgICAgICAgICBmb3IgKDsgaysrIDw9IHhkaTspIHhkLnB1c2goMCk7XHJcbiAgICAgICAgICAgIHcgPSByZCA9IDA7XHJcbiAgICAgICAgICAgIGRpZ2l0cyA9IDE7XHJcbiAgICAgICAgICAgIGkgJT0gTE9HX0JBU0U7XHJcbiAgICAgICAgICAgIGogPSBpIC0gTE9HX0JBU0UgKyAxO1xyXG4gICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgYnJlYWsgb3V0O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB3ID0gayA9IHhkW3hkaV07XHJcblxyXG4gICAgICAgICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHcuXHJcbiAgICAgICAgICBmb3IgKGRpZ2l0cyA9IDE7IGsgPj0gMTA7IGsgLz0gMTApIGRpZ2l0cysrO1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIHcuXHJcbiAgICAgICAgICBpICU9IExPR19CQVNFO1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgaW5kZXggb2YgcmQgd2l0aGluIHcsIGFkanVzdGVkIGZvciBsZWFkaW5nIHplcm9zLlxyXG4gICAgICAgICAgLy8gVGhlIG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIHcgaXMgZ2l2ZW4gYnkgTE9HX0JBU0UgLSBkaWdpdHMuXHJcbiAgICAgICAgICBqID0gaSAtIExPR19CQVNFICsgZGlnaXRzO1xyXG5cclxuICAgICAgICAgIC8vIEdldCB0aGUgcm91bmRpbmcgZGlnaXQgYXQgaW5kZXggaiBvZiB3LlxyXG4gICAgICAgICAgcmQgPSBqIDwgMCA/IDAgOiB3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaiAtIDEpICUgMTAgfCAwO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gQXJlIHRoZXJlIGFueSBub24temVybyBkaWdpdHMgYWZ0ZXIgdGhlIHJvdW5kaW5nIGRpZ2l0P1xyXG4gICAgICBpc1RydW5jYXRlZCA9IGlzVHJ1bmNhdGVkIHx8IHNkIDwgMCB8fFxyXG4gICAgICAgIHhkW3hkaSArIDFdICE9PSB2b2lkIDAgfHwgKGogPCAwID8gdyA6IHcgJSBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSkpO1xyXG5cclxuICAgICAgLy8gVGhlIGV4cHJlc3Npb24gYHcgJSBtYXRocG93KDEwLCBkaWdpdHMgLSBqIC0gMSlgIHJldHVybnMgYWxsIHRoZSBkaWdpdHMgb2YgdyB0byB0aGUgcmlnaHRcclxuICAgICAgLy8gb2YgdGhlIGRpZ2l0IGF0IChsZWZ0LXRvLXJpZ2h0KSBpbmRleCBqLCBlLmcuIGlmIHcgaXMgOTA4NzE0IGFuZCBqIGlzIDIsIHRoZSBleHByZXNzaW9uXHJcbiAgICAgIC8vIHdpbGwgZ2l2ZSA3MTQuXHJcblxyXG4gICAgICByb3VuZFVwID0gcm0gPCA0XHJcbiAgICAgICAgPyAocmQgfHwgaXNUcnVuY2F0ZWQpICYmIChybSA9PSAwIHx8IHJtID09ICh4LnMgPCAwID8gMyA6IDIpKVxyXG4gICAgICAgIDogcmQgPiA1IHx8IHJkID09IDUgJiYgKHJtID09IDQgfHwgaXNUcnVuY2F0ZWQgfHwgcm0gPT0gNiAmJlxyXG5cclxuICAgICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGRpZ2l0IHRvIHRoZSBsZWZ0IG9mIHRoZSByb3VuZGluZyBkaWdpdCBpcyBvZGQuXHJcbiAgICAgICAgICAoKGkgPiAwID8gaiA+IDAgPyB3IC8gbWF0aHBvdygxMCwgZGlnaXRzIC0gaikgOiAwIDogeGRbeGRpIC0gMV0pICUgMTApICYgMSB8fFxyXG4gICAgICAgICAgICBybSA9PSAoeC5zIDwgMCA/IDggOiA3KSk7XHJcblxyXG4gICAgICBpZiAoc2QgPCAxIHx8ICF4ZFswXSkge1xyXG4gICAgICAgIHhkLmxlbmd0aCA9IDA7XHJcbiAgICAgICAgaWYgKHJvdW5kVXApIHtcclxuXHJcbiAgICAgICAgICAvLyBDb252ZXJ0IHNkIHRvIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgc2QgLT0geC5lICsgMTtcclxuXHJcbiAgICAgICAgICAvLyAxLCAwLjEsIDAuMDEsIDAuMDAxLCAwLjAwMDEgZXRjLlxyXG4gICAgICAgICAgeGRbMF0gPSBtYXRocG93KDEwLCAoTE9HX0JBU0UgLSBzZCAlIExPR19CQVNFKSAlIExPR19CQVNFKTtcclxuICAgICAgICAgIHguZSA9IC1zZCB8fCAwO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHhkWzBdID0geC5lID0gMDtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiB4O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBSZW1vdmUgZXhjZXNzIGRpZ2l0cy5cclxuICAgICAgaWYgKGkgPT0gMCkge1xyXG4gICAgICAgIHhkLmxlbmd0aCA9IHhkaTtcclxuICAgICAgICBrID0gMTtcclxuICAgICAgICB4ZGktLTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB4ZC5sZW5ndGggPSB4ZGkgKyAxO1xyXG4gICAgICAgIGsgPSBtYXRocG93KDEwLCBMT0dfQkFTRSAtIGkpO1xyXG5cclxuICAgICAgICAvLyBFLmcuIDU2NzAwIGJlY29tZXMgNTYwMDAgaWYgNyBpcyB0aGUgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgLy8gaiA+IDAgbWVhbnMgaSA+IG51bWJlciBvZiBsZWFkaW5nIHplcm9zIG9mIHcuXHJcbiAgICAgICAgeGRbeGRpXSA9IGogPiAwID8gKHcgLyBtYXRocG93KDEwLCBkaWdpdHMgLSBqKSAlIG1hdGhwb3coMTAsIGopIHwgMCkgKiBrIDogMDtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHJvdW5kVXApIHtcclxuICAgICAgICBmb3IgKDs7KSB7XHJcblxyXG4gICAgICAgICAgLy8gSXMgdGhlIGRpZ2l0IHRvIGJlIHJvdW5kZWQgdXAgaW4gdGhlIGZpcnN0IHdvcmQgb2YgeGQ/XHJcbiAgICAgICAgICBpZiAoeGRpID09IDApIHtcclxuXHJcbiAgICAgICAgICAgIC8vIGkgd2lsbCBiZSB0aGUgbGVuZ3RoIG9mIHhkWzBdIGJlZm9yZSBrIGlzIGFkZGVkLlxyXG4gICAgICAgICAgICBmb3IgKGkgPSAxLCBqID0geGRbMF07IGogPj0gMTA7IGogLz0gMTApIGkrKztcclxuICAgICAgICAgICAgaiA9IHhkWzBdICs9IGs7XHJcbiAgICAgICAgICAgIGZvciAoayA9IDE7IGogPj0gMTA7IGogLz0gMTApIGsrKztcclxuXHJcbiAgICAgICAgICAgIC8vIGlmIGkgIT0gayB0aGUgbGVuZ3RoIGhhcyBpbmNyZWFzZWQuXHJcbiAgICAgICAgICAgIGlmIChpICE9IGspIHtcclxuICAgICAgICAgICAgICB4LmUrKztcclxuICAgICAgICAgICAgICBpZiAoeGRbMF0gPT0gQkFTRSkgeGRbMF0gPSAxO1xyXG4gICAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHhkW3hkaV0gKz0gaztcclxuICAgICAgICAgICAgaWYgKHhkW3hkaV0gIT0gQkFTRSkgYnJlYWs7XHJcbiAgICAgICAgICAgIHhkW3hkaS0tXSA9IDA7XHJcbiAgICAgICAgICAgIGsgPSAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGkgPSB4ZC5sZW5ndGg7IHhkWy0taV0gPT09IDA7KSB4ZC5wb3AoKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoZXh0ZXJuYWwpIHtcclxuXHJcbiAgICAgIC8vIE92ZXJmbG93P1xyXG4gICAgICBpZiAoeC5lID4gQ3Rvci5tYXhFKSB7XHJcblxyXG4gICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgIHguZCA9IG51bGw7XHJcbiAgICAgICAgeC5lID0gTmFOO1xyXG5cclxuICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICB9IGVsc2UgaWYgKHguZSA8IEN0b3IubWluRSkge1xyXG5cclxuICAgICAgICAvLyBaZXJvLlxyXG4gICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgeC5kID0gWzBdO1xyXG4gICAgICAgIC8vIEN0b3IudW5kZXJmbG93ID0gdHJ1ZTtcclxuICAgICAgfSAvLyBlbHNlIEN0b3IudW5kZXJmbG93ID0gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuXHJcbiAgZnVuY3Rpb24gZmluaXRlVG9TdHJpbmcoeCwgaXNFeHAsIHNkKSB7XHJcbiAgICBpZiAoIXguaXNGaW5pdGUoKSkgcmV0dXJuIG5vbkZpbml0ZVRvU3RyaW5nKHgpO1xyXG4gICAgdmFyIGssXHJcbiAgICAgIGUgPSB4LmUsXHJcbiAgICAgIHN0ciA9IGRpZ2l0c1RvU3RyaW5nKHguZCksXHJcbiAgICAgIGxlbiA9IHN0ci5sZW5ndGg7XHJcblxyXG4gICAgaWYgKGlzRXhwKSB7XHJcbiAgICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHtcclxuICAgICAgICBzdHIgPSBzdHIuY2hhckF0KDApICsgJy4nICsgc3RyLnNsaWNlKDEpICsgZ2V0WmVyb1N0cmluZyhrKTtcclxuICAgICAgfSBlbHNlIGlmIChsZW4gPiAxKSB7XHJcbiAgICAgICAgc3RyID0gc3RyLmNoYXJBdCgwKSArICcuJyArIHN0ci5zbGljZSgxKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgc3RyID0gc3RyICsgKHguZSA8IDAgPyAnZScgOiAnZSsnKSArIHguZTtcclxuICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuICAgICAgc3RyID0gJzAuJyArIGdldFplcm9TdHJpbmcoLWUgLSAxKSArIHN0cjtcclxuICAgICAgaWYgKHNkICYmIChrID0gc2QgLSBsZW4pID4gMCkgc3RyICs9IGdldFplcm9TdHJpbmcoayk7XHJcbiAgICB9IGVsc2UgaWYgKGUgPj0gbGVuKSB7XHJcbiAgICAgIHN0ciArPSBnZXRaZXJvU3RyaW5nKGUgKyAxIC0gbGVuKTtcclxuICAgICAgaWYgKHNkICYmIChrID0gc2QgLSBlIC0gMSkgPiAwKSBzdHIgPSBzdHIgKyAnLicgKyBnZXRaZXJvU3RyaW5nKGspO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKChrID0gZSArIDEpIDwgbGVuKSBzdHIgPSBzdHIuc2xpY2UoMCwgaykgKyAnLicgKyBzdHIuc2xpY2Uoayk7XHJcbiAgICAgIGlmIChzZCAmJiAoayA9IHNkIC0gbGVuKSA+IDApIHtcclxuICAgICAgICBpZiAoZSArIDEgPT09IGxlbikgc3RyICs9ICcuJztcclxuICAgICAgICBzdHIgKz0gZ2V0WmVyb1N0cmluZyhrKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdHI7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ2FsY3VsYXRlIHRoZSBiYXNlIDEwIGV4cG9uZW50IGZyb20gdGhlIGJhc2UgMWU3IGV4cG9uZW50LlxyXG4gIGZ1bmN0aW9uIGdldEJhc2UxMEV4cG9uZW50KGRpZ2l0cywgZSkge1xyXG4gICAgdmFyIHcgPSBkaWdpdHNbMF07XHJcblxyXG4gICAgLy8gQWRkIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHRoZSBkaWdpdHMgYXJyYXkuXHJcbiAgICBmb3IgKCBlICo9IExPR19CQVNFOyB3ID49IDEwOyB3IC89IDEwKSBlKys7XHJcbiAgICByZXR1cm4gZTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBnZXRMbjEwKEN0b3IsIHNkLCBwcikge1xyXG4gICAgaWYgKHNkID4gTE4xMF9QUkVDSVNJT04pIHtcclxuXHJcbiAgICAgIC8vIFJlc2V0IGdsb2JhbCBzdGF0ZSBpbiBjYXNlIHRoZSBleGNlcHRpb24gaXMgY2F1Z2h0LlxyXG4gICAgICBleHRlcm5hbCA9IHRydWU7XHJcbiAgICAgIGlmIChwcikgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgICAgdGhyb3cgRXJyb3IocHJlY2lzaW9uTGltaXRFeGNlZWRlZCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoTE4xMCksIHNkLCAxLCB0cnVlKTtcclxuICB9XHJcblxyXG5cclxuICBmdW5jdGlvbiBnZXRQaShDdG9yLCBzZCwgcm0pIHtcclxuICAgIGlmIChzZCA+IFBJX1BSRUNJU0lPTikgdGhyb3cgRXJyb3IocHJlY2lzaW9uTGltaXRFeGNlZWRlZCk7XHJcbiAgICByZXR1cm4gZmluYWxpc2UobmV3IEN0b3IoUEkpLCBzZCwgcm0sIHRydWUpO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdldFByZWNpc2lvbihkaWdpdHMpIHtcclxuICAgIHZhciB3ID0gZGlnaXRzLmxlbmd0aCAtIDEsXHJcbiAgICAgIGxlbiA9IHcgKiBMT0dfQkFTRSArIDE7XHJcblxyXG4gICAgdyA9IGRpZ2l0c1t3XTtcclxuXHJcbiAgICAvLyBJZiBub24temVyby4uLlxyXG4gICAgaWYgKHcpIHtcclxuXHJcbiAgICAgIC8vIFN1YnRyYWN0IHRoZSBudW1iZXIgb2YgdHJhaWxpbmcgemVyb3Mgb2YgdGhlIGxhc3Qgd29yZC5cclxuICAgICAgZm9yICg7IHcgJSAxMCA9PSAwOyB3IC89IDEwKSBsZW4tLTtcclxuXHJcbiAgICAgIC8vIEFkZCB0aGUgbnVtYmVyIG9mIGRpZ2l0cyBvZiB0aGUgZmlyc3Qgd29yZC5cclxuICAgICAgZm9yICh3ID0gZGlnaXRzWzBdOyB3ID49IDEwOyB3IC89IDEwKSBsZW4rKztcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGVuO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGdldFplcm9TdHJpbmcoaykge1xyXG4gICAgdmFyIHpzID0gJyc7XHJcbiAgICBmb3IgKDsgay0tOykgenMgKz0gJzAnO1xyXG4gICAgcmV0dXJuIHpzO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHZhbHVlIG9mIERlY2ltYWwgYHhgIHRvIHRoZSBwb3dlciBgbmAsIHdoZXJlIGBuYCBpcyBhblxyXG4gICAqIGludGVnZXIgb2YgdHlwZSBudW1iZXIuXHJcbiAgICpcclxuICAgKiBJbXBsZW1lbnRzICdleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZycuIENhbGxlZCBieSBgcG93YCBhbmQgYHBhcnNlT3RoZXJgLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gaW50UG93KEN0b3IsIHgsIG4sIHByKSB7XHJcbiAgICB2YXIgaXNUcnVuY2F0ZWQsXHJcbiAgICAgIHIgPSBuZXcgQ3RvcigxKSxcclxuXHJcbiAgICAgIC8vIE1heCBuIG9mIDkwMDcxOTkyNTQ3NDA5OTEgdGFrZXMgNTMgbG9vcCBpdGVyYXRpb25zLlxyXG4gICAgICAvLyBNYXhpbXVtIGRpZ2l0cyBhcnJheSBsZW5ndGg7IGxlYXZlcyBbMjgsIDM0XSBndWFyZCBkaWdpdHMuXHJcbiAgICAgIGsgPSBNYXRoLmNlaWwocHIgLyBMT0dfQkFTRSArIDQpO1xyXG5cclxuICAgIGV4dGVybmFsID0gZmFsc2U7XHJcblxyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICBpZiAobiAlIDIpIHtcclxuICAgICAgICByID0gci50aW1lcyh4KTtcclxuICAgICAgICBpZiAodHJ1bmNhdGUoci5kLCBrKSkgaXNUcnVuY2F0ZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBuID0gbWF0aGZsb29yKG4gLyAyKTtcclxuICAgICAgaWYgKG4gPT09IDApIHtcclxuXHJcbiAgICAgICAgLy8gVG8gZW5zdXJlIGNvcnJlY3Qgcm91bmRpbmcgd2hlbiByLmQgaXMgdHJ1bmNhdGVkLCBpbmNyZW1lbnQgdGhlIGxhc3Qgd29yZCBpZiBpdCBpcyB6ZXJvLlxyXG4gICAgICAgIG4gPSByLmQubGVuZ3RoIC0gMTtcclxuICAgICAgICBpZiAoaXNUcnVuY2F0ZWQgJiYgci5kW25dID09PSAwKSArK3IuZFtuXTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgeCA9IHgudGltZXMoeCk7XHJcbiAgICAgIHRydW5jYXRlKHguZCwgayk7XHJcbiAgICB9XHJcblxyXG4gICAgZXh0ZXJuYWwgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiByO1xyXG4gIH1cclxuXHJcblxyXG4gIGZ1bmN0aW9uIGlzT2RkKG4pIHtcclxuICAgIHJldHVybiBuLmRbbi5kLmxlbmd0aCAtIDFdICYgMTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIEhhbmRsZSBgbWF4YCAoYG5gIGlzIC0xKSBhbmQgYG1pbmAgKGBuYCBpcyAxKS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBtYXhPck1pbihDdG9yLCBhcmdzLCBuKSB7XHJcbiAgICB2YXIgaywgeSxcclxuICAgICAgeCA9IG5ldyBDdG9yKGFyZ3NbMF0pLFxyXG4gICAgICBpID0gMDtcclxuXHJcbiAgICBmb3IgKDsgKytpIDwgYXJncy5sZW5ndGg7KSB7XHJcbiAgICAgIHkgPSBuZXcgQ3RvcihhcmdzW2ldKTtcclxuXHJcbiAgICAgIC8vIE5hTj9cclxuICAgICAgaWYgKCF5LnMpIHtcclxuICAgICAgICB4ID0geTtcclxuICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgayA9IHguY21wKHkpO1xyXG5cclxuICAgICAgaWYgKGsgPT09IG4gfHwgayA9PT0gMCAmJiB4LnMgPT09IG4pIHtcclxuICAgICAgICB4ID0geTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4O1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgZXhwb25lbnRpYWwgb2YgYHhgIHJvdW5kZWQgdG8gYHNkYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cy5cclxuICAgKlxyXG4gICAqIFRheWxvci9NYWNsYXVyaW4gc2VyaWVzLlxyXG4gICAqXHJcbiAgICogZXhwKHgpID0geF4wLzAhICsgeF4xLzEhICsgeF4yLzIhICsgeF4zLzMhICsgLi4uXHJcbiAgICpcclxuICAgKiBBcmd1bWVudCByZWR1Y3Rpb246XHJcbiAgICogICBSZXBlYXQgeCA9IHggLyAzMiwgayArPSA1LCB1bnRpbCB8eHwgPCAwLjFcclxuICAgKiAgIGV4cCh4KSA9IGV4cCh4IC8gMl5rKV4oMl5rKVxyXG4gICAqXHJcbiAgICogUHJldmlvdXNseSwgdGhlIGFyZ3VtZW50IHdhcyBpbml0aWFsbHkgcmVkdWNlZCBieVxyXG4gICAqIGV4cCh4KSA9IGV4cChyKSAqIDEwXmsgIHdoZXJlIHIgPSB4IC0gayAqIGxuMTAsIGsgPSBmbG9vcih4IC8gbG4xMClcclxuICAgKiB0byBmaXJzdCBwdXQgciBpbiB0aGUgcmFuZ2UgWzAsIGxuMTBdLCBiZWZvcmUgZGl2aWRpbmcgYnkgMzIgdW50aWwgfHh8IDwgMC4xLCBidXQgdGhpcyB3YXNcclxuICAgKiBmb3VuZCB0byBiZSBzbG93ZXIgdGhhbiBqdXN0IGRpdmlkaW5nIHJlcGVhdGVkbHkgYnkgMzIgYXMgYWJvdmUuXHJcbiAgICpcclxuICAgKiBNYXggaW50ZWdlciBhcmd1bWVudDogZXhwKCcyMDcyMzI2NTgzNjk0NjQxMycpID0gNi4zZSs5MDAwMDAwMDAwMDAwMDAwXHJcbiAgICogTWluIGludGVnZXIgYXJndW1lbnQ6IGV4cCgnLTIwNzIzMjY1ODM2OTQ2NDExJykgPSAxLjJlLTkwMDAwMDAwMDAwMDAwMDBcclxuICAgKiAoTWF0aCBvYmplY3QgaW50ZWdlciBtaW4vbWF4OiBNYXRoLmV4cCg3MDkpID0gOC4yZSszMDcsIE1hdGguZXhwKC03NDUpID0gNWUtMzI0KVxyXG4gICAqXHJcbiAgICogIGV4cChJbmZpbml0eSkgID0gSW5maW5pdHlcclxuICAgKiAgZXhwKC1JbmZpbml0eSkgPSAwXHJcbiAgICogIGV4cChOYU4pICAgICAgID0gTmFOXHJcbiAgICogIGV4cCjCsTApICAgICAgICA9IDFcclxuICAgKlxyXG4gICAqICBleHAoeCkgaXMgbm9uLXRlcm1pbmF0aW5nIGZvciBhbnkgZmluaXRlLCBub24temVybyB4LlxyXG4gICAqXHJcbiAgICogIFRoZSByZXN1bHQgd2lsbCBhbHdheXMgYmUgY29ycmVjdGx5IHJvdW5kZWQuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBuYXR1cmFsRXhwb25lbnRpYWwoeCwgc2QpIHtcclxuICAgIHZhciBkZW5vbWluYXRvciwgZ3VhcmQsIGosIHBvdywgc3VtLCB0LCB3cHIsXHJcbiAgICAgIHJlcCA9IDAsXHJcbiAgICAgIGkgPSAwLFxyXG4gICAgICBrID0gMCxcclxuICAgICAgQ3RvciA9IHguY29uc3RydWN0b3IsXHJcbiAgICAgIHJtID0gQ3Rvci5yb3VuZGluZyxcclxuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbjtcclxuXHJcbiAgICAvLyAwL05hTi9JbmZpbml0eT9cclxuICAgIGlmICgheC5kIHx8ICF4LmRbMF0gfHwgeC5lID4gMTcpIHtcclxuXHJcbiAgICAgIHJldHVybiBuZXcgQ3Rvcih4LmRcclxuICAgICAgICA/ICF4LmRbMF0gPyAxIDogeC5zIDwgMCA/IDAgOiAxIC8gMFxyXG4gICAgICAgIDogeC5zID8geC5zIDwgMCA/IDAgOiB4IDogMCAvIDApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICAgIGV4dGVybmFsID0gZmFsc2U7XHJcbiAgICAgIHdwciA9IHByO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgd3ByID0gc2Q7XHJcbiAgICB9XHJcblxyXG4gICAgdCA9IG5ldyBDdG9yKDAuMDMxMjUpO1xyXG5cclxuICAgIC8vIHdoaWxlIGFicyh4KSA+PSAwLjFcclxuICAgIHdoaWxlICh4LmUgPiAtMikge1xyXG5cclxuICAgICAgLy8geCA9IHggLyAyXjVcclxuICAgICAgeCA9IHgudGltZXModCk7XHJcbiAgICAgIGsgKz0gNTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBVc2UgMiAqIGxvZzEwKDJeaykgKyA1IChlbXBpcmljYWxseSBkZXJpdmVkKSB0byBlc3RpbWF0ZSB0aGUgaW5jcmVhc2UgaW4gcHJlY2lzaW9uXHJcbiAgICAvLyBuZWNlc3NhcnkgdG8gZW5zdXJlIHRoZSBmaXJzdCA0IHJvdW5kaW5nIGRpZ2l0cyBhcmUgY29ycmVjdC5cclxuICAgIGd1YXJkID0gTWF0aC5sb2cobWF0aHBvdygyLCBrKSkgLyBNYXRoLkxOMTAgKiAyICsgNSB8IDA7XHJcbiAgICB3cHIgKz0gZ3VhcmQ7XHJcbiAgICBkZW5vbWluYXRvciA9IHBvdyA9IHN1bSA9IG5ldyBDdG9yKDEpO1xyXG4gICAgQ3Rvci5wcmVjaXNpb24gPSB3cHI7XHJcblxyXG4gICAgZm9yICg7Oykge1xyXG4gICAgICBwb3cgPSBmaW5hbGlzZShwb3cudGltZXMoeCksIHdwciwgMSk7XHJcbiAgICAgIGRlbm9taW5hdG9yID0gZGVub21pbmF0b3IudGltZXMoKytpKTtcclxuICAgICAgdCA9IHN1bS5wbHVzKGRpdmlkZShwb3csIGRlbm9taW5hdG9yLCB3cHIsIDEpKTtcclxuXHJcbiAgICAgIGlmIChkaWdpdHNUb1N0cmluZyh0LmQpLnNsaWNlKDAsIHdwcikgPT09IGRpZ2l0c1RvU3RyaW5nKHN1bS5kKS5zbGljZSgwLCB3cHIpKSB7XHJcbiAgICAgICAgaiA9IGs7XHJcbiAgICAgICAgd2hpbGUgKGotLSkgc3VtID0gZmluYWxpc2Uoc3VtLnRpbWVzKHN1bSksIHdwciwgMSk7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgZmlyc3QgNCByb3VuZGluZyBkaWdpdHMgYXJlIFs0OV05OTkuXHJcbiAgICAgICAgLy8gSWYgc28sIHJlcGVhdCB0aGUgc3VtbWF0aW9uIHdpdGggYSBoaWdoZXIgcHJlY2lzaW9uLCBvdGhlcndpc2VcclxuICAgICAgICAvLyBlLmcuIHdpdGggcHJlY2lzaW9uOiAxOCwgcm91bmRpbmc6IDFcclxuICAgICAgICAvLyBleHAoMTguNDA0MjcyNDYyNTk1MDM0MDgzNTY3NzkzOTE5ODQzNzYxKSA9IDk4MzcyNTYwLjEyMjk5OTk5OTkgKHNob3VsZCBiZSA5ODM3MjU2MC4xMjMpXHJcbiAgICAgICAgLy8gYHdwciAtIGd1YXJkYCBpcyB0aGUgaW5kZXggb2YgZmlyc3Qgcm91bmRpbmcgZGlnaXQuXHJcbiAgICAgICAgaWYgKHNkID09IG51bGwpIHtcclxuXHJcbiAgICAgICAgICBpZiAocmVwIDwgMyAmJiBjaGVja1JvdW5kaW5nRGlnaXRzKHN1bS5kLCB3cHIgLSBndWFyZCwgcm0sIHJlcCkpIHtcclxuICAgICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSB3cHIgKz0gMTA7XHJcbiAgICAgICAgICAgIGRlbm9taW5hdG9yID0gcG93ID0gdCA9IG5ldyBDdG9yKDEpO1xyXG4gICAgICAgICAgICBpID0gMDtcclxuICAgICAgICAgICAgcmVwKys7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmluYWxpc2Uoc3VtLCBDdG9yLnByZWNpc2lvbiA9IHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzdW0gPSB0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGB4YCByb3VuZGVkIHRvIGBzZGAgc2lnbmlmaWNhbnRcclxuICAgKiBkaWdpdHMuXHJcbiAgICpcclxuICAgKiAgbG4oLW4pICAgICAgICA9IE5hTlxyXG4gICAqICBsbigwKSAgICAgICAgID0gLUluZmluaXR5XHJcbiAgICogIGxuKC0wKSAgICAgICAgPSAtSW5maW5pdHlcclxuICAgKiAgbG4oMSkgICAgICAgICA9IDBcclxuICAgKiAgbG4oSW5maW5pdHkpICA9IEluZmluaXR5XHJcbiAgICogIGxuKC1JbmZpbml0eSkgPSBOYU5cclxuICAgKiAgbG4oTmFOKSAgICAgICA9IE5hTlxyXG4gICAqXHJcbiAgICogIGxuKG4pIChuICE9IDEpIGlzIG5vbi10ZXJtaW5hdGluZy5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG5hdHVyYWxMb2dhcml0aG0oeSwgc2QpIHtcclxuICAgIHZhciBjLCBjMCwgZGVub21pbmF0b3IsIGUsIG51bWVyYXRvciwgcmVwLCBzdW0sIHQsIHdwciwgeDEsIHgyLFxyXG4gICAgICBuID0gMSxcclxuICAgICAgZ3VhcmQgPSAxMCxcclxuICAgICAgeCA9IHksXHJcbiAgICAgIHhkID0geC5kLFxyXG4gICAgICBDdG9yID0geC5jb25zdHJ1Y3RvcixcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nLFxyXG4gICAgICBwciA9IEN0b3IucHJlY2lzaW9uO1xyXG5cclxuICAgIC8vIElzIHggbmVnYXRpdmUgb3IgSW5maW5pdHksIE5hTiwgMCBvciAxP1xyXG4gICAgaWYgKHgucyA8IDAgfHwgIXhkIHx8ICF4ZFswXSB8fCAheC5lICYmIHhkWzBdID09IDEgJiYgeGQubGVuZ3RoID09IDEpIHtcclxuICAgICAgcmV0dXJuIG5ldyBDdG9yKHhkICYmICF4ZFswXSA/IC0xIC8gMCA6IHgucyAhPSAxID8gTmFOIDogeGQgPyAwIDogeCk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKHNkID09IG51bGwpIHtcclxuICAgICAgZXh0ZXJuYWwgPSBmYWxzZTtcclxuICAgICAgd3ByID0gcHI7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB3cHIgPSBzZDtcclxuICAgIH1cclxuXHJcbiAgICBDdG9yLnByZWNpc2lvbiA9IHdwciArPSBndWFyZDtcclxuICAgIGMgPSBkaWdpdHNUb1N0cmluZyh4ZCk7XHJcbiAgICBjMCA9IGMuY2hhckF0KDApO1xyXG5cclxuICAgIGlmIChNYXRoLmFicyhlID0geC5lKSA8IDEuNWUxNSkge1xyXG5cclxuICAgICAgLy8gQXJndW1lbnQgcmVkdWN0aW9uLlxyXG4gICAgICAvLyBUaGUgc2VyaWVzIGNvbnZlcmdlcyBmYXN0ZXIgdGhlIGNsb3NlciB0aGUgYXJndW1lbnQgaXMgdG8gMSwgc28gdXNpbmdcclxuICAgICAgLy8gbG4oYV5iKSA9IGIgKiBsbihhKSwgICBsbihhKSA9IGxuKGFeYikgLyBiXHJcbiAgICAgIC8vIG11bHRpcGx5IHRoZSBhcmd1bWVudCBieSBpdHNlbGYgdW50aWwgdGhlIGxlYWRpbmcgZGlnaXRzIG9mIHRoZSBzaWduaWZpY2FuZCBhcmUgNywgOCwgOSxcclxuICAgICAgLy8gMTAsIDExLCAxMiBvciAxMywgcmVjb3JkaW5nIHRoZSBudW1iZXIgb2YgbXVsdGlwbGljYXRpb25zIHNvIHRoZSBzdW0gb2YgdGhlIHNlcmllcyBjYW5cclxuICAgICAgLy8gbGF0ZXIgYmUgZGl2aWRlZCBieSB0aGlzIG51bWJlciwgdGhlbiBzZXBhcmF0ZSBvdXQgdGhlIHBvd2VyIG9mIDEwIHVzaW5nXHJcbiAgICAgIC8vIGxuKGEqMTBeYikgPSBsbihhKSArIGIqbG4oMTApLlxyXG5cclxuICAgICAgLy8gbWF4IG4gaXMgMjEgKGdpdmVzIDAuOSwgMS4wIG9yIDEuMSkgKDllMTUgLyAyMSA9IDQuMmUxNCkuXHJcbiAgICAgIC8vd2hpbGUgKGMwIDwgOSAmJiBjMCAhPSAxIHx8IGMwID09IDEgJiYgYy5jaGFyQXQoMSkgPiAxKSB7XHJcbiAgICAgIC8vIG1heCBuIGlzIDYgKGdpdmVzIDAuNyAtIDEuMylcclxuICAgICAgd2hpbGUgKGMwIDwgNyAmJiBjMCAhPSAxIHx8IGMwID09IDEgJiYgYy5jaGFyQXQoMSkgPiAzKSB7XHJcbiAgICAgICAgeCA9IHgudGltZXMoeSk7XHJcbiAgICAgICAgYyA9IGRpZ2l0c1RvU3RyaW5nKHguZCk7XHJcbiAgICAgICAgYzAgPSBjLmNoYXJBdCgwKTtcclxuICAgICAgICBuKys7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGUgPSB4LmU7XHJcblxyXG4gICAgICBpZiAoYzAgPiAxKSB7XHJcbiAgICAgICAgeCA9IG5ldyBDdG9yKCcwLicgKyBjKTtcclxuICAgICAgICBlKys7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgeCA9IG5ldyBDdG9yKGMwICsgJy4nICsgYy5zbGljZSgxKSk7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBUaGUgYXJndW1lbnQgcmVkdWN0aW9uIG1ldGhvZCBhYm92ZSBtYXkgcmVzdWx0IGluIG92ZXJmbG93IGlmIHRoZSBhcmd1bWVudCB5IGlzIGEgbWFzc2l2ZVxyXG4gICAgICAvLyBudW1iZXIgd2l0aCBleHBvbmVudCA+PSAxNTAwMDAwMDAwMDAwMDAwICg5ZTE1IC8gNiA9IDEuNWUxNSksIHNvIGluc3RlYWQgcmVjYWxsIHRoaXNcclxuICAgICAgLy8gZnVuY3Rpb24gdXNpbmcgbG4oeCoxMF5lKSA9IGxuKHgpICsgZSpsbigxMCkuXHJcbiAgICAgIHQgPSBnZXRMbjEwKEN0b3IsIHdwciArIDIsIHByKS50aW1lcyhlICsgJycpO1xyXG4gICAgICB4ID0gbmF0dXJhbExvZ2FyaXRobShuZXcgQ3RvcihjMCArICcuJyArIGMuc2xpY2UoMSkpLCB3cHIgLSBndWFyZCkucGx1cyh0KTtcclxuICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuXHJcbiAgICAgIHJldHVybiBzZCA9PSBudWxsID8gZmluYWxpc2UoeCwgcHIsIHJtLCBleHRlcm5hbCA9IHRydWUpIDogeDtcclxuICAgIH1cclxuXHJcbiAgICAvLyB4MSBpcyB4IHJlZHVjZWQgdG8gYSB2YWx1ZSBuZWFyIDEuXHJcbiAgICB4MSA9IHg7XHJcblxyXG4gICAgLy8gVGF5bG9yIHNlcmllcy5cclxuICAgIC8vIGxuKHkpID0gbG4oKDEgKyB4KS8oMSAtIHgpKSA9IDIoeCArIHheMy8zICsgeF41LzUgKyB4XjcvNyArIC4uLilcclxuICAgIC8vIHdoZXJlIHggPSAoeSAtIDEpLyh5ICsgMSkgICAgKHx4fCA8IDEpXHJcbiAgICBzdW0gPSBudW1lcmF0b3IgPSB4ID0gZGl2aWRlKHgubWludXMoMSksIHgucGx1cygxKSwgd3ByLCAxKTtcclxuICAgIHgyID0gZmluYWxpc2UoeC50aW1lcyh4KSwgd3ByLCAxKTtcclxuICAgIGRlbm9taW5hdG9yID0gMztcclxuXHJcbiAgICBmb3IgKDs7KSB7XHJcbiAgICAgIG51bWVyYXRvciA9IGZpbmFsaXNlKG51bWVyYXRvci50aW1lcyh4MiksIHdwciwgMSk7XHJcbiAgICAgIHQgPSBzdW0ucGx1cyhkaXZpZGUobnVtZXJhdG9yLCBuZXcgQ3RvcihkZW5vbWluYXRvciksIHdwciwgMSkpO1xyXG5cclxuICAgICAgaWYgKGRpZ2l0c1RvU3RyaW5nKHQuZCkuc2xpY2UoMCwgd3ByKSA9PT0gZGlnaXRzVG9TdHJpbmcoc3VtLmQpLnNsaWNlKDAsIHdwcikpIHtcclxuICAgICAgICBzdW0gPSBzdW0udGltZXMoMik7XHJcblxyXG4gICAgICAgIC8vIFJldmVyc2UgdGhlIGFyZ3VtZW50IHJlZHVjdGlvbi4gQ2hlY2sgdGhhdCBlIGlzIG5vdCAwIGJlY2F1c2UsIGJlc2lkZXMgcHJldmVudGluZyBhblxyXG4gICAgICAgIC8vIHVubmVjZXNzYXJ5IGNhbGN1bGF0aW9uLCAtMCArIDAgPSArMCBhbmQgdG8gZW5zdXJlIGNvcnJlY3Qgcm91bmRpbmcgLTAgbmVlZHMgdG8gc3RheSAtMC5cclxuICAgICAgICBpZiAoZSAhPT0gMCkgc3VtID0gc3VtLnBsdXMoZ2V0TG4xMChDdG9yLCB3cHIgKyAyLCBwcikudGltZXMoZSArICcnKSk7XHJcbiAgICAgICAgc3VtID0gZGl2aWRlKHN1bSwgbmV3IEN0b3IobiksIHdwciwgMSk7XHJcblxyXG4gICAgICAgIC8vIElzIHJtID4gMyBhbmQgdGhlIGZpcnN0IDQgcm91bmRpbmcgZGlnaXRzIDQ5OTksIG9yIHJtIDwgNCAob3IgdGhlIHN1bW1hdGlvbiBoYXNcclxuICAgICAgICAvLyBiZWVuIHJlcGVhdGVkIHByZXZpb3VzbHkpIGFuZCB0aGUgZmlyc3QgNCByb3VuZGluZyBkaWdpdHMgOTk5OT9cclxuICAgICAgICAvLyBJZiBzbywgcmVzdGFydCB0aGUgc3VtbWF0aW9uIHdpdGggYSBoaWdoZXIgcHJlY2lzaW9uLCBvdGhlcndpc2VcclxuICAgICAgICAvLyBlLmcuIHdpdGggcHJlY2lzaW9uOiAxMiwgcm91bmRpbmc6IDFcclxuICAgICAgICAvLyBsbigxMzU1MjAwMjguNjEyNjA5MTcxNDI2NTM4MTUzMykgPSAxOC43MjQ2Mjk5OTk5IHdoZW4gaXQgc2hvdWxkIGJlIDE4LjcyNDYzLlxyXG4gICAgICAgIC8vIGB3cHIgLSBndWFyZGAgaXMgdGhlIGluZGV4IG9mIGZpcnN0IHJvdW5kaW5nIGRpZ2l0LlxyXG4gICAgICAgIGlmIChzZCA9PSBudWxsKSB7XHJcbiAgICAgICAgICBpZiAoY2hlY2tSb3VuZGluZ0RpZ2l0cyhzdW0uZCwgd3ByIC0gZ3VhcmQsIHJtLCByZXApKSB7XHJcbiAgICAgICAgICAgIEN0b3IucHJlY2lzaW9uID0gd3ByICs9IGd1YXJkO1xyXG4gICAgICAgICAgICB0ID0gbnVtZXJhdG9yID0geCA9IGRpdmlkZSh4MS5taW51cygxKSwgeDEucGx1cygxKSwgd3ByLCAxKTtcclxuICAgICAgICAgICAgeDIgPSBmaW5hbGlzZSh4LnRpbWVzKHgpLCB3cHIsIDEpO1xyXG4gICAgICAgICAgICBkZW5vbWluYXRvciA9IHJlcCA9IDE7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gZmluYWxpc2Uoc3VtLCBDdG9yLnByZWNpc2lvbiA9IHByLCBybSwgZXh0ZXJuYWwgPSB0cnVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgQ3Rvci5wcmVjaXNpb24gPSBwcjtcclxuICAgICAgICAgIHJldHVybiBzdW07XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzdW0gPSB0O1xyXG4gICAgICBkZW5vbWluYXRvciArPSAyO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcblxyXG4gIC8vIMKxSW5maW5pdHksIE5hTi5cclxuICBmdW5jdGlvbiBub25GaW5pdGVUb1N0cmluZyh4KSB7XHJcbiAgICAvLyBVbnNpZ25lZC5cclxuICAgIHJldHVybiBTdHJpbmcoeC5zICogeC5zIC8gMCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBQYXJzZSB0aGUgdmFsdWUgb2YgYSBuZXcgRGVjaW1hbCBgeGAgZnJvbSBzdHJpbmcgYHN0cmAuXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcGFyc2VEZWNpbWFsKHgsIHN0cikge1xyXG4gICAgdmFyIGUsIGksIGxlbjtcclxuXHJcbiAgICAvLyBUT0RPIEJpZ0ludCBzdHI6IG5vIG5lZWQgdG8gY2hlY2sgZm9yIGRlY2ltYWwgcG9pbnQsIGV4cG9uZW50aWFsIGZvcm0gb3IgbGVhZGluZyB6ZXJvcy5cclxuXHJcbiAgICAvLyBEZWNpbWFsIHBvaW50P1xyXG4gICAgaWYgKChlID0gc3RyLmluZGV4T2YoJy4nKSkgPiAtMSkgc3RyID0gc3RyLnJlcGxhY2UoJy4nLCAnJyk7XHJcblxyXG4gICAgLy8gRXhwb25lbnRpYWwgZm9ybT9cclxuICAgIGlmICgoaSA9IHN0ci5zZWFyY2goL2UvaSkpID4gMCkge1xyXG5cclxuICAgICAgLy8gRGV0ZXJtaW5lIGV4cG9uZW50LlxyXG4gICAgICBpZiAoZSA8IDApIGUgPSBpO1xyXG4gICAgICBlICs9ICtzdHIuc2xpY2UoaSArIDEpO1xyXG4gICAgICBzdHIgPSBzdHIuc3Vic3RyaW5nKDAsIGkpO1xyXG4gICAgfSBlbHNlIGlmIChlIDwgMCkge1xyXG5cclxuICAgICAgLy8gSW50ZWdlci5cclxuICAgICAgZSA9IHN0ci5sZW5ndGg7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIGxlYWRpbmcgemVyb3MuXHJcbiAgICBmb3IgKGkgPSAwOyBzdHIuY2hhckNvZGVBdChpKSA9PT0gNDg7IGkrKyk7XHJcblxyXG4gICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChsZW4gPSBzdHIubGVuZ3RoOyBzdHIuY2hhckNvZGVBdChsZW4gLSAxKSA9PT0gNDg7IC0tbGVuKTtcclxuICAgIHN0ciA9IHN0ci5zbGljZShpLCBsZW4pO1xyXG5cclxuICAgIGlmIChzdHIpIHtcclxuICAgICAgbGVuIC09IGk7XHJcbiAgICAgIHguZSA9IGUgPSBlIC0gaSAtIDE7XHJcbiAgICAgIHguZCA9IFtdO1xyXG5cclxuICAgICAgLy8gVHJhbnNmb3JtIGJhc2VcclxuXHJcbiAgICAgIC8vIGUgaXMgdGhlIGJhc2UgMTAgZXhwb25lbnQuXHJcbiAgICAgIC8vIGkgaXMgd2hlcmUgdG8gc2xpY2Ugc3RyIHRvIGdldCB0aGUgZmlyc3Qgd29yZCBvZiB0aGUgZGlnaXRzIGFycmF5LlxyXG4gICAgICBpID0gKGUgKyAxKSAlIExPR19CQVNFO1xyXG4gICAgICBpZiAoZSA8IDApIGkgKz0gTE9HX0JBU0U7XHJcblxyXG4gICAgICBpZiAoaSA8IGxlbikge1xyXG4gICAgICAgIGlmIChpKSB4LmQucHVzaCgrc3RyLnNsaWNlKDAsIGkpKTtcclxuICAgICAgICBmb3IgKGxlbiAtPSBMT0dfQkFTRTsgaSA8IGxlbjspIHguZC5wdXNoKCtzdHIuc2xpY2UoaSwgaSArPSBMT0dfQkFTRSkpO1xyXG4gICAgICAgIHN0ciA9IHN0ci5zbGljZShpKTtcclxuICAgICAgICBpID0gTE9HX0JBU0UgLSBzdHIubGVuZ3RoO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGkgLT0gbGVuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBmb3IgKDsgaS0tOykgc3RyICs9ICcwJztcclxuICAgICAgeC5kLnB1c2goK3N0cik7XHJcblxyXG4gICAgICBpZiAoZXh0ZXJuYWwpIHtcclxuXHJcbiAgICAgICAgLy8gT3ZlcmZsb3c/XHJcbiAgICAgICAgaWYgKHguZSA+IHguY29uc3RydWN0b3IubWF4RSkge1xyXG5cclxuICAgICAgICAgIC8vIEluZmluaXR5LlxyXG4gICAgICAgICAgeC5kID0gbnVsbDtcclxuICAgICAgICAgIHguZSA9IE5hTjtcclxuXHJcbiAgICAgICAgLy8gVW5kZXJmbG93P1xyXG4gICAgICAgIH0gZWxzZSBpZiAoeC5lIDwgeC5jb25zdHJ1Y3Rvci5taW5FKSB7XHJcblxyXG4gICAgICAgICAgLy8gWmVyby5cclxuICAgICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgICB4LmQgPSBbMF07XHJcbiAgICAgICAgICAvLyB4LmNvbnN0cnVjdG9yLnVuZGVyZmxvdyA9IHRydWU7XHJcbiAgICAgICAgfSAvLyBlbHNlIHguY29uc3RydWN0b3IudW5kZXJmbG93ID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH0gZWxzZSB7XHJcblxyXG4gICAgICAvLyBaZXJvLlxyXG4gICAgICB4LmUgPSAwO1xyXG4gICAgICB4LmQgPSBbMF07XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBQYXJzZSB0aGUgdmFsdWUgb2YgYSBuZXcgRGVjaW1hbCBgeGAgZnJvbSBhIHN0cmluZyBgc3RyYCwgd2hpY2ggaXMgbm90IGEgZGVjaW1hbCB2YWx1ZS5cclxuICAgKi9cclxuICBmdW5jdGlvbiBwYXJzZU90aGVyKHgsIHN0cikge1xyXG4gICAgdmFyIGJhc2UsIEN0b3IsIGRpdmlzb3IsIGksIGlzRmxvYXQsIGxlbiwgcCwgeGQsIHhlO1xyXG5cclxuICAgIGlmIChzdHIuaW5kZXhPZignXycpID4gLTEpIHtcclxuICAgICAgc3RyID0gc3RyLnJlcGxhY2UoLyhcXGQpXyg/PVxcZCkvZywgJyQxJyk7XHJcbiAgICAgIGlmIChpc0RlY2ltYWwudGVzdChzdHIpKSByZXR1cm4gcGFyc2VEZWNpbWFsKHgsIHN0cik7XHJcbiAgICB9IGVsc2UgaWYgKHN0ciA9PT0gJ0luZmluaXR5JyB8fCBzdHIgPT09ICdOYU4nKSB7XHJcbiAgICAgIGlmICghK3N0cikgeC5zID0gTmFOO1xyXG4gICAgICB4LmUgPSBOYU47XHJcbiAgICAgIHguZCA9IG51bGw7XHJcbiAgICAgIHJldHVybiB4O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChpc0hleC50ZXN0KHN0cikpICB7XHJcbiAgICAgIGJhc2UgPSAxNjtcclxuICAgICAgc3RyID0gc3RyLnRvTG93ZXJDYXNlKCk7XHJcbiAgICB9IGVsc2UgaWYgKGlzQmluYXJ5LnRlc3Qoc3RyKSkgIHtcclxuICAgICAgYmFzZSA9IDI7XHJcbiAgICB9IGVsc2UgaWYgKGlzT2N0YWwudGVzdChzdHIpKSAge1xyXG4gICAgICBiYXNlID0gODtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHN0cik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSXMgdGhlcmUgYSBiaW5hcnkgZXhwb25lbnQgcGFydD9cclxuICAgIGkgPSBzdHIuc2VhcmNoKC9wL2kpO1xyXG5cclxuICAgIGlmIChpID4gMCkge1xyXG4gICAgICBwID0gK3N0ci5zbGljZShpICsgMSk7XHJcbiAgICAgIHN0ciA9IHN0ci5zdWJzdHJpbmcoMiwgaSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzdHIgPSBzdHIuc2xpY2UoMik7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ29udmVydCBgc3RyYCBhcyBhbiBpbnRlZ2VyIHRoZW4gZGl2aWRlIHRoZSByZXN1bHQgYnkgYGJhc2VgIHJhaXNlZCB0byBhIHBvd2VyIHN1Y2ggdGhhdCB0aGVcclxuICAgIC8vIGZyYWN0aW9uIHBhcnQgd2lsbCBiZSByZXN0b3JlZC5cclxuICAgIGkgPSBzdHIuaW5kZXhPZignLicpO1xyXG4gICAgaXNGbG9hdCA9IGkgPj0gMDtcclxuICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yO1xyXG5cclxuICAgIGlmIChpc0Zsb2F0KSB7XHJcbiAgICAgIHN0ciA9IHN0ci5yZXBsYWNlKCcuJywgJycpO1xyXG4gICAgICBsZW4gPSBzdHIubGVuZ3RoO1xyXG4gICAgICBpID0gbGVuIC0gaTtcclxuXHJcbiAgICAgIC8vIGxvZ1sxMF0oMTYpID0gMS4yMDQxLi4uICwgbG9nWzEwXSg4OCkgPSAxLjk0NDQuLi4uXHJcbiAgICAgIGRpdmlzb3IgPSBpbnRQb3coQ3RvciwgbmV3IEN0b3IoYmFzZSksIGksIGkgKiAyKTtcclxuICAgIH1cclxuXHJcbiAgICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgYmFzZSwgQkFTRSk7XHJcbiAgICB4ZSA9IHhkLmxlbmd0aCAtIDE7XHJcblxyXG4gICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgZm9yIChpID0geGU7IHhkW2ldID09PSAwOyAtLWkpIHhkLnBvcCgpO1xyXG4gICAgaWYgKGkgPCAwKSByZXR1cm4gbmV3IEN0b3IoeC5zICogMCk7XHJcbiAgICB4LmUgPSBnZXRCYXNlMTBFeHBvbmVudCh4ZCwgeGUpO1xyXG4gICAgeC5kID0geGQ7XHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICAgIC8vIEF0IHdoYXQgcHJlY2lzaW9uIHRvIHBlcmZvcm0gdGhlIGRpdmlzaW9uIHRvIGVuc3VyZSBleGFjdCBjb252ZXJzaW9uP1xyXG4gICAgLy8gbWF4RGVjaW1hbEludGVnZXJQYXJ0RGlnaXRDb3VudCA9IGNlaWwobG9nWzEwXShiKSAqIG90aGVyQmFzZUludGVnZXJQYXJ0RGlnaXRDb3VudClcclxuICAgIC8vIGxvZ1sxMF0oMikgPSAwLjMwMTAzLCBsb2dbMTBdKDgpID0gMC45MDMwOSwgbG9nWzEwXSgxNikgPSAxLjIwNDEyXHJcbiAgICAvLyBFLmcuIGNlaWwoMS4yICogMykgPSA0LCBzbyB1cCB0byA0IGRlY2ltYWwgZGlnaXRzIGFyZSBuZWVkZWQgdG8gcmVwcmVzZW50IDMgaGV4IGludCBkaWdpdHMuXHJcbiAgICAvLyBtYXhEZWNpbWFsRnJhY3Rpb25QYXJ0RGlnaXRDb3VudCA9IHtIZXg6NHxPY3Q6M3xCaW46MX0gKiBvdGhlckJhc2VGcmFjdGlvblBhcnREaWdpdENvdW50XHJcbiAgICAvLyBUaGVyZWZvcmUgdXNpbmcgNCAqIHRoZSBudW1iZXIgb2YgZGlnaXRzIG9mIHN0ciB3aWxsIGFsd2F5cyBiZSBlbm91Z2guXHJcbiAgICBpZiAoaXNGbG9hdCkgeCA9IGRpdmlkZSh4LCBkaXZpc29yLCBsZW4gKiA0KTtcclxuXHJcbiAgICAvLyBNdWx0aXBseSBieSB0aGUgYmluYXJ5IGV4cG9uZW50IHBhcnQgaWYgcHJlc2VudC5cclxuICAgIGlmIChwKSB4ID0geC50aW1lcyhNYXRoLmFicyhwKSA8IDU0ID8gbWF0aHBvdygyLCBwKSA6IERlY2ltYWwucG93KDIsIHApKTtcclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4geDtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIHNpbih4KSA9IHggLSB4XjMvMyEgKyB4XjUvNSEgLSAuLi5cclxuICAgKiB8eHwgPCBwaS8yXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBzaW5lKEN0b3IsIHgpIHtcclxuICAgIHZhciBrLFxyXG4gICAgICBsZW4gPSB4LmQubGVuZ3RoO1xyXG5cclxuICAgIGlmIChsZW4gPCAzKSB7XHJcbiAgICAgIHJldHVybiB4LmlzWmVybygpID8geCA6IHRheWxvclNlcmllcyhDdG9yLCAyLCB4LCB4KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBcmd1bWVudCByZWR1Y3Rpb246IHNpbig1eCkgPSAxNipzaW5eNSh4KSAtIDIwKnNpbl4zKHgpICsgNSpzaW4oeClcclxuICAgIC8vIGkuZS4gc2luKHgpID0gMTYqc2luXjUoeC81KSAtIDIwKnNpbl4zKHgvNSkgKyA1KnNpbih4LzUpXHJcbiAgICAvLyBhbmQgIHNpbih4KSA9IHNpbih4LzUpKDUgKyBzaW5eMih4LzUpKDE2c2luXjIoeC81KSAtIDIwKSlcclxuXHJcbiAgICAvLyBFc3RpbWF0ZSB0aGUgb3B0aW11bSBudW1iZXIgb2YgdGltZXMgdG8gdXNlIHRoZSBhcmd1bWVudCByZWR1Y3Rpb24uXHJcbiAgICBrID0gMS40ICogTWF0aC5zcXJ0KGxlbik7XHJcbiAgICBrID0gayA+IDE2ID8gMTYgOiBrIHwgMDtcclxuXHJcbiAgICB4ID0geC50aW1lcygxIC8gdGlueVBvdyg1LCBrKSk7XHJcbiAgICB4ID0gdGF5bG9yU2VyaWVzKEN0b3IsIDIsIHgsIHgpO1xyXG5cclxuICAgIC8vIFJldmVyc2UgYXJndW1lbnQgcmVkdWN0aW9uXHJcbiAgICB2YXIgc2luMl94LFxyXG4gICAgICBkNSA9IG5ldyBDdG9yKDUpLFxyXG4gICAgICBkMTYgPSBuZXcgQ3RvcigxNiksXHJcbiAgICAgIGQyMCA9IG5ldyBDdG9yKDIwKTtcclxuICAgIGZvciAoOyBrLS07KSB7XHJcbiAgICAgIHNpbjJfeCA9IHgudGltZXMoeCk7XHJcbiAgICAgIHggPSB4LnRpbWVzKGQ1LnBsdXMoc2luMl94LnRpbWVzKGQxNi50aW1lcyhzaW4yX3gpLm1pbnVzKGQyMCkpKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHg7XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gQ2FsY3VsYXRlIFRheWxvciBzZXJpZXMgZm9yIGBjb3NgLCBgY29zaGAsIGBzaW5gIGFuZCBgc2luaGAuXHJcbiAgZnVuY3Rpb24gdGF5bG9yU2VyaWVzKEN0b3IsIG4sIHgsIHksIGlzSHlwZXJib2xpYykge1xyXG4gICAgdmFyIGosIHQsIHUsIHgyLFxyXG4gICAgICBpID0gMSxcclxuICAgICAgcHIgPSBDdG9yLnByZWNpc2lvbixcclxuICAgICAgayA9IE1hdGguY2VpbChwciAvIExPR19CQVNFKTtcclxuXHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgeDIgPSB4LnRpbWVzKHgpO1xyXG4gICAgdSA9IG5ldyBDdG9yKHkpO1xyXG5cclxuICAgIGZvciAoOzspIHtcclxuICAgICAgdCA9IGRpdmlkZSh1LnRpbWVzKHgyKSwgbmV3IEN0b3IobisrICogbisrKSwgcHIsIDEpO1xyXG4gICAgICB1ID0gaXNIeXBlcmJvbGljID8geS5wbHVzKHQpIDogeS5taW51cyh0KTtcclxuICAgICAgeSA9IGRpdmlkZSh0LnRpbWVzKHgyKSwgbmV3IEN0b3IobisrICogbisrKSwgcHIsIDEpO1xyXG4gICAgICB0ID0gdS5wbHVzKHkpO1xyXG5cclxuICAgICAgaWYgKHQuZFtrXSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgICAgZm9yIChqID0gazsgdC5kW2pdID09PSB1LmRbal0gJiYgai0tOyk7XHJcbiAgICAgICAgaWYgKGogPT0gLTEpIGJyZWFrO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBqID0gdTtcclxuICAgICAgdSA9IHk7XHJcbiAgICAgIHkgPSB0O1xyXG4gICAgICB0ID0gajtcclxuICAgICAgaSsrO1xyXG4gICAgfVxyXG5cclxuICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuICAgIHQuZC5sZW5ndGggPSBrICsgMTtcclxuXHJcbiAgICByZXR1cm4gdDtcclxuICB9XHJcblxyXG5cclxuICAvLyBFeHBvbmVudCBlIG11c3QgYmUgcG9zaXRpdmUgYW5kIG5vbi16ZXJvLlxyXG4gIGZ1bmN0aW9uIHRpbnlQb3coYiwgZSkge1xyXG4gICAgdmFyIG4gPSBiO1xyXG4gICAgd2hpbGUgKC0tZSkgbiAqPSBiO1xyXG4gICAgcmV0dXJuIG47XHJcbiAgfVxyXG5cclxuXHJcbiAgLy8gUmV0dXJuIHRoZSBhYnNvbHV0ZSB2YWx1ZSBvZiBgeGAgcmVkdWNlZCB0byBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gaGFsZiBwaS5cclxuICBmdW5jdGlvbiB0b0xlc3NUaGFuSGFsZlBpKEN0b3IsIHgpIHtcclxuICAgIHZhciB0LFxyXG4gICAgICBpc05lZyA9IHgucyA8IDAsXHJcbiAgICAgIHBpID0gZ2V0UGkoQ3RvciwgQ3Rvci5wcmVjaXNpb24sIDEpLFxyXG4gICAgICBoYWxmUGkgPSBwaS50aW1lcygwLjUpO1xyXG5cclxuICAgIHggPSB4LmFicygpO1xyXG5cclxuICAgIGlmICh4Lmx0ZShoYWxmUGkpKSB7XHJcbiAgICAgIHF1YWRyYW50ID0gaXNOZWcgPyA0IDogMTtcclxuICAgICAgcmV0dXJuIHg7XHJcbiAgICB9XHJcblxyXG4gICAgdCA9IHguZGl2VG9JbnQocGkpO1xyXG5cclxuICAgIGlmICh0LmlzWmVybygpKSB7XHJcbiAgICAgIHF1YWRyYW50ID0gaXNOZWcgPyAzIDogMjtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHggPSB4Lm1pbnVzKHQudGltZXMocGkpKTtcclxuXHJcbiAgICAgIC8vIDAgPD0geCA8IHBpXHJcbiAgICAgIGlmICh4Lmx0ZShoYWxmUGkpKSB7XHJcbiAgICAgICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IChpc05lZyA/IDIgOiAzKSA6IChpc05lZyA/IDQgOiAxKTtcclxuICAgICAgICByZXR1cm4geDtcclxuICAgICAgfVxyXG5cclxuICAgICAgcXVhZHJhbnQgPSBpc09kZCh0KSA/IChpc05lZyA/IDEgOiA0KSA6IChpc05lZyA/IDMgOiAyKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4geC5taW51cyhwaSkuYWJzKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gdGhlIHZhbHVlIG9mIERlY2ltYWwgYHhgIGFzIGEgc3RyaW5nIGluIGJhc2UgYGJhc2VPdXRgLlxyXG4gICAqXHJcbiAgICogSWYgdGhlIG9wdGlvbmFsIGBzZGAgYXJndW1lbnQgaXMgcHJlc2VudCBpbmNsdWRlIGEgYmluYXJ5IGV4cG9uZW50IHN1ZmZpeC5cclxuICAgKi9cclxuICBmdW5jdGlvbiB0b1N0cmluZ0JpbmFyeSh4LCBiYXNlT3V0LCBzZCwgcm0pIHtcclxuICAgIHZhciBiYXNlLCBlLCBpLCBrLCBsZW4sIHJvdW5kVXAsIHN0ciwgeGQsIHksXHJcbiAgICAgIEN0b3IgPSB4LmNvbnN0cnVjdG9yLFxyXG4gICAgICBpc0V4cCA9IHNkICE9PSB2b2lkIDA7XHJcblxyXG4gICAgaWYgKGlzRXhwKSB7XHJcbiAgICAgIGNoZWNrSW50MzIoc2QsIDEsIE1BWF9ESUdJVFMpO1xyXG4gICAgICBpZiAocm0gPT09IHZvaWQgMCkgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgICBlbHNlIGNoZWNrSW50MzIocm0sIDAsIDgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2QgPSBDdG9yLnByZWNpc2lvbjtcclxuICAgICAgcm0gPSBDdG9yLnJvdW5kaW5nO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICgheC5pc0Zpbml0ZSgpKSB7XHJcbiAgICAgIHN0ciA9IG5vbkZpbml0ZVRvU3RyaW5nKHgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3RyID0gZmluaXRlVG9TdHJpbmcoeCk7XHJcbiAgICAgIGkgPSBzdHIuaW5kZXhPZignLicpO1xyXG5cclxuICAgICAgLy8gVXNlIGV4cG9uZW50aWFsIG5vdGF0aW9uIGFjY29yZGluZyB0byBgdG9FeHBQb3NgIGFuZCBgdG9FeHBOZWdgPyBObywgYnV0IGlmIHJlcXVpcmVkOlxyXG4gICAgICAvLyBtYXhCaW5hcnlFeHBvbmVudCA9IGZsb29yKChkZWNpbWFsRXhwb25lbnQgKyAxKSAqIGxvZ1syXSgxMCkpXHJcbiAgICAgIC8vIG1pbkJpbmFyeUV4cG9uZW50ID0gZmxvb3IoZGVjaW1hbEV4cG9uZW50ICogbG9nWzJdKDEwKSlcclxuICAgICAgLy8gbG9nWzJdKDEwKSA9IDMuMzIxOTI4MDk0ODg3MzYyMzQ3ODcwMzE5NDI5NDg5MzkwMTc1ODY0XHJcblxyXG4gICAgICBpZiAoaXNFeHApIHtcclxuICAgICAgICBiYXNlID0gMjtcclxuICAgICAgICBpZiAoYmFzZU91dCA9PSAxNikge1xyXG4gICAgICAgICAgc2QgPSBzZCAqIDQgLSAzO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoYmFzZU91dCA9PSA4KSB7XHJcbiAgICAgICAgICBzZCA9IHNkICogMyAtIDI7XHJcbiAgICAgICAgfVxyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGJhc2UgPSBiYXNlT3V0O1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBDb252ZXJ0IHRoZSBudW1iZXIgYXMgYW4gaW50ZWdlciB0aGVuIGRpdmlkZSB0aGUgcmVzdWx0IGJ5IGl0cyBiYXNlIHJhaXNlZCB0byBhIHBvd2VyIHN1Y2hcclxuICAgICAgLy8gdGhhdCB0aGUgZnJhY3Rpb24gcGFydCB3aWxsIGJlIHJlc3RvcmVkLlxyXG5cclxuICAgICAgLy8gTm9uLWludGVnZXIuXHJcbiAgICAgIGlmIChpID49IDApIHtcclxuICAgICAgICBzdHIgPSBzdHIucmVwbGFjZSgnLicsICcnKTtcclxuICAgICAgICB5ID0gbmV3IEN0b3IoMSk7XHJcbiAgICAgICAgeS5lID0gc3RyLmxlbmd0aCAtIGk7XHJcbiAgICAgICAgeS5kID0gY29udmVydEJhc2UoZmluaXRlVG9TdHJpbmcoeSksIDEwLCBiYXNlKTtcclxuICAgICAgICB5LmUgPSB5LmQubGVuZ3RoO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB4ZCA9IGNvbnZlcnRCYXNlKHN0ciwgMTAsIGJhc2UpO1xyXG4gICAgICBlID0gbGVuID0geGQubGVuZ3RoO1xyXG5cclxuICAgICAgLy8gUmVtb3ZlIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKDsgeGRbLS1sZW5dID09IDA7KSB4ZC5wb3AoKTtcclxuXHJcbiAgICAgIGlmICgheGRbMF0pIHtcclxuICAgICAgICBzdHIgPSBpc0V4cCA/ICcwcCswJyA6ICcwJztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBpZiAoaSA8IDApIHtcclxuICAgICAgICAgIGUtLTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeCA9IG5ldyBDdG9yKHgpO1xyXG4gICAgICAgICAgeC5kID0geGQ7XHJcbiAgICAgICAgICB4LmUgPSBlO1xyXG4gICAgICAgICAgeCA9IGRpdmlkZSh4LCB5LCBzZCwgcm0sIDAsIGJhc2UpO1xyXG4gICAgICAgICAgeGQgPSB4LmQ7XHJcbiAgICAgICAgICBlID0geC5lO1xyXG4gICAgICAgICAgcm91bmRVcCA9IGluZXhhY3Q7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBUaGUgcm91bmRpbmcgZGlnaXQsIGkuZS4gdGhlIGRpZ2l0IGFmdGVyIHRoZSBkaWdpdCB0aGF0IG1heSBiZSByb3VuZGVkIHVwLlxyXG4gICAgICAgIGkgPSB4ZFtzZF07XHJcbiAgICAgICAgayA9IGJhc2UgLyAyO1xyXG4gICAgICAgIHJvdW5kVXAgPSByb3VuZFVwIHx8IHhkW3NkICsgMV0gIT09IHZvaWQgMDtcclxuXHJcbiAgICAgICAgcm91bmRVcCA9IHJtIDwgNFxyXG4gICAgICAgICAgPyAoaSAhPT0gdm9pZCAwIHx8IHJvdW5kVXApICYmIChybSA9PT0gMCB8fCBybSA9PT0gKHgucyA8IDAgPyAzIDogMikpXHJcbiAgICAgICAgICA6IGkgPiBrIHx8IGkgPT09IGsgJiYgKHJtID09PSA0IHx8IHJvdW5kVXAgfHwgcm0gPT09IDYgJiYgeGRbc2QgLSAxXSAmIDEgfHxcclxuICAgICAgICAgICAgcm0gPT09ICh4LnMgPCAwID8gOCA6IDcpKTtcclxuXHJcbiAgICAgICAgeGQubGVuZ3RoID0gc2Q7XHJcblxyXG4gICAgICAgIGlmIChyb3VuZFVwKSB7XHJcblxyXG4gICAgICAgICAgLy8gUm91bmRpbmcgdXAgbWF5IG1lYW4gdGhlIHByZXZpb3VzIGRpZ2l0IGhhcyB0byBiZSByb3VuZGVkIHVwIGFuZCBzbyBvbi5cclxuICAgICAgICAgIGZvciAoOyArK3hkWy0tc2RdID4gYmFzZSAtIDE7KSB7XHJcbiAgICAgICAgICAgIHhkW3NkXSA9IDA7XHJcbiAgICAgICAgICAgIGlmICghc2QpIHtcclxuICAgICAgICAgICAgICArK2U7XHJcbiAgICAgICAgICAgICAgeGQudW5zaGlmdCgxKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIHRyYWlsaW5nIHplcm9zLlxyXG4gICAgICAgIGZvciAobGVuID0geGQubGVuZ3RoOyAheGRbbGVuIC0gMV07IC0tbGVuKTtcclxuXHJcbiAgICAgICAgLy8gRS5nLiBbNCwgMTEsIDE1XSBiZWNvbWVzIDRiZi5cclxuICAgICAgICBmb3IgKGkgPSAwLCBzdHIgPSAnJzsgaSA8IGxlbjsgaSsrKSBzdHIgKz0gTlVNRVJBTFMuY2hhckF0KHhkW2ldKTtcclxuXHJcbiAgICAgICAgLy8gQWRkIGJpbmFyeSBleHBvbmVudCBzdWZmaXg/XHJcbiAgICAgICAgaWYgKGlzRXhwKSB7XHJcbiAgICAgICAgICBpZiAobGVuID4gMSkge1xyXG4gICAgICAgICAgICBpZiAoYmFzZU91dCA9PSAxNiB8fCBiYXNlT3V0ID09IDgpIHtcclxuICAgICAgICAgICAgICBpID0gYmFzZU91dCA9PSAxNiA/IDQgOiAzO1xyXG4gICAgICAgICAgICAgIGZvciAoLS1sZW47IGxlbiAlIGk7IGxlbisrKSBzdHIgKz0gJzAnO1xyXG4gICAgICAgICAgICAgIHhkID0gY29udmVydEJhc2Uoc3RyLCBiYXNlLCBiYXNlT3V0KTtcclxuICAgICAgICAgICAgICBmb3IgKGxlbiA9IHhkLmxlbmd0aDsgIXhkW2xlbiAtIDFdOyAtLWxlbik7XHJcblxyXG4gICAgICAgICAgICAgIC8vIHhkWzBdIHdpbGwgYWx3YXlzIGJlIGJlIDFcclxuICAgICAgICAgICAgICBmb3IgKGkgPSAxLCBzdHIgPSAnMS4nOyBpIDwgbGVuOyBpKyspIHN0ciArPSBOVU1FUkFMUy5jaGFyQXQoeGRbaV0pO1xyXG4gICAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICAgIHN0ciA9IHN0ci5jaGFyQXQoMCkgKyAnLicgKyBzdHIuc2xpY2UoMSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICBzdHIgPSAgc3RyICsgKGUgPCAwID8gJ3AnIDogJ3ArJykgKyBlO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoZSA8IDApIHtcclxuICAgICAgICAgIGZvciAoOyArK2U7KSBzdHIgPSAnMCcgKyBzdHI7XHJcbiAgICAgICAgICBzdHIgPSAnMC4nICsgc3RyO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoKytlID4gbGVuKSBmb3IgKGUgLT0gbGVuOyBlLS0gOykgc3RyICs9ICcwJztcclxuICAgICAgICAgIGVsc2UgaWYgKGUgPCBsZW4pIHN0ciA9IHN0ci5zbGljZSgwLCBlKSArICcuJyArIHN0ci5zbGljZShlKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHN0ciA9IChiYXNlT3V0ID09IDE2ID8gJzB4JyA6IGJhc2VPdXQgPT0gMiA/ICcwYicgOiBiYXNlT3V0ID09IDggPyAnMG8nIDogJycpICsgc3RyO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB4LnMgPCAwID8gJy0nICsgc3RyIDogc3RyO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIERvZXMgbm90IHN0cmlwIHRyYWlsaW5nIHplcm9zLlxyXG4gIGZ1bmN0aW9uIHRydW5jYXRlKGFyciwgbGVuKSB7XHJcbiAgICBpZiAoYXJyLmxlbmd0aCA+IGxlbikge1xyXG4gICAgICBhcnIubGVuZ3RoID0gbGVuO1xyXG4gICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG5cclxuICAvLyBEZWNpbWFsIG1ldGhvZHNcclxuXHJcblxyXG4gIC8qXHJcbiAgICogIGFic1xyXG4gICAqICBhY29zXHJcbiAgICogIGFjb3NoXHJcbiAgICogIGFkZFxyXG4gICAqICBhc2luXHJcbiAgICogIGFzaW5oXHJcbiAgICogIGF0YW5cclxuICAgKiAgYXRhbmhcclxuICAgKiAgYXRhbjJcclxuICAgKiAgY2JydFxyXG4gICAqICBjZWlsXHJcbiAgICogIGNsYW1wXHJcbiAgICogIGNsb25lXHJcbiAgICogIGNvbmZpZ1xyXG4gICAqICBjb3NcclxuICAgKiAgY29zaFxyXG4gICAqICBkaXZcclxuICAgKiAgZXhwXHJcbiAgICogIGZsb29yXHJcbiAgICogIGh5cG90XHJcbiAgICogIGxuXHJcbiAgICogIGxvZ1xyXG4gICAqICBsb2cyXHJcbiAgICogIGxvZzEwXHJcbiAgICogIG1heFxyXG4gICAqICBtaW5cclxuICAgKiAgbW9kXHJcbiAgICogIG11bFxyXG4gICAqICBwb3dcclxuICAgKiAgcmFuZG9tXHJcbiAgICogIHJvdW5kXHJcbiAgICogIHNldFxyXG4gICAqICBzaWduXHJcbiAgICogIHNpblxyXG4gICAqICBzaW5oXHJcbiAgICogIHNxcnRcclxuICAgKiAgc3ViXHJcbiAgICogIHN1bVxyXG4gICAqICB0YW5cclxuICAgKiAgdGFuaFxyXG4gICAqICB0cnVuY1xyXG4gICAqL1xyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYWJzb2x1dGUgdmFsdWUgb2YgYHhgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFicyh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuYWJzKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYXJjY29zaW5lIGluIHJhZGlhbnMgb2YgYHhgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFjb3MoeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmFjb3MoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBpbnZlcnNlIG9mIHRoZSBoeXBlcmJvbGljIGNvc2luZSBvZiBgeGAsIHJvdW5kZWQgdG9cclxuICAgKiBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYWNvc2goeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmFjb3NoKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3VtIG9mIGB4YCBhbmQgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICogeSB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGFkZCh4LCB5KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkucGx1cyh5KTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmNzaW5lIGluIHJhZGlhbnMgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBhc2luKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5hc2luKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIGB4YCwgcm91bmRlZCB0b1xyXG4gICAqIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBhc2luaCh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuYXNpbmgoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IGluIHJhZGlhbnMgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBhdGFuKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5hdGFuKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaW52ZXJzZSBvZiB0aGUgaHlwZXJib2xpYyB0YW5nZW50IG9mIGB4YCwgcm91bmRlZCB0b1xyXG4gICAqIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBhdGFuaCh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuYXRhbmgoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBhcmN0YW5nZW50IGluIHJhZGlhbnMgb2YgYHkveGAgaW4gdGhlIHJhbmdlIC1waSB0byBwaVxyXG4gICAqIChpbmNsdXNpdmUpLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiBEb21haW46IFstSW5maW5pdHksIEluZmluaXR5XVxyXG4gICAqIFJhbmdlOiBbLXBpLCBwaV1cclxuICAgKlxyXG4gICAqIHkge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9IFRoZSB5LWNvb3JkaW5hdGUuXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH0gVGhlIHgtY29vcmRpbmF0ZS5cclxuICAgKlxyXG4gICAqIGF0YW4yKMKxMCwgLTApICAgICAgICAgICAgICAgPSDCsXBpXHJcbiAgICogYXRhbjIowrEwLCArMCkgICAgICAgICAgICAgICA9IMKxMFxyXG4gICAqIGF0YW4yKMKxMCwgLXgpICAgICAgICAgICAgICAgPSDCsXBpIGZvciB4ID4gMFxyXG4gICAqIGF0YW4yKMKxMCwgeCkgICAgICAgICAgICAgICAgPSDCsTAgZm9yIHggPiAwXHJcbiAgICogYXRhbjIoLXksIMKxMCkgICAgICAgICAgICAgICA9IC1waS8yIGZvciB5ID4gMFxyXG4gICAqIGF0YW4yKHksIMKxMCkgICAgICAgICAgICAgICAgPSBwaS8yIGZvciB5ID4gMFxyXG4gICAqIGF0YW4yKMKxeSwgLUluZmluaXR5KSAgICAgICAgPSDCsXBpIGZvciBmaW5pdGUgeSA+IDBcclxuICAgKiBhdGFuMijCsXksICtJbmZpbml0eSkgICAgICAgID0gwrEwIGZvciBmaW5pdGUgeSA+IDBcclxuICAgKiBhdGFuMijCsUluZmluaXR5LCB4KSAgICAgICAgID0gwrFwaS8yIGZvciBmaW5pdGUgeFxyXG4gICAqIGF0YW4yKMKxSW5maW5pdHksIC1JbmZpbml0eSkgPSDCsTMqcGkvNFxyXG4gICAqIGF0YW4yKMKxSW5maW5pdHksICtJbmZpbml0eSkgPSDCsXBpLzRcclxuICAgKiBhdGFuMihOYU4sIHgpID0gTmFOXHJcbiAgICogYXRhbjIoeSwgTmFOKSA9IE5hTlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gYXRhbjIoeSwgeCkge1xyXG4gICAgeSA9IG5ldyB0aGlzKHkpO1xyXG4gICAgeCA9IG5ldyB0aGlzKHgpO1xyXG4gICAgdmFyIHIsXHJcbiAgICAgIHByID0gdGhpcy5wcmVjaXNpb24sXHJcbiAgICAgIHJtID0gdGhpcy5yb3VuZGluZyxcclxuICAgICAgd3ByID0gcHIgKyA0O1xyXG5cclxuICAgIC8vIEVpdGhlciBOYU5cclxuICAgIGlmICgheS5zIHx8ICF4LnMpIHtcclxuICAgICAgciA9IG5ldyB0aGlzKE5hTik7XHJcblxyXG4gICAgLy8gQm90aCDCsUluZmluaXR5XHJcbiAgICB9IGVsc2UgaWYgKCF5LmQgJiYgIXguZCkge1xyXG4gICAgICByID0gZ2V0UGkodGhpcywgd3ByLCAxKS50aW1lcyh4LnMgPiAwID8gMC4yNSA6IDAuNzUpO1xyXG4gICAgICByLnMgPSB5LnM7XHJcblxyXG4gICAgLy8geCBpcyDCsUluZmluaXR5IG9yIHkgaXMgwrEwXHJcbiAgICB9IGVsc2UgaWYgKCF4LmQgfHwgeS5pc1plcm8oKSkge1xyXG4gICAgICByID0geC5zIDwgMCA/IGdldFBpKHRoaXMsIHByLCBybSkgOiBuZXcgdGhpcygwKTtcclxuICAgICAgci5zID0geS5zO1xyXG5cclxuICAgIC8vIHkgaXMgwrFJbmZpbml0eSBvciB4IGlzIMKxMFxyXG4gICAgfSBlbHNlIGlmICgheS5kIHx8IHguaXNaZXJvKCkpIHtcclxuICAgICAgciA9IGdldFBpKHRoaXMsIHdwciwgMSkudGltZXMoMC41KTtcclxuICAgICAgci5zID0geS5zO1xyXG5cclxuICAgIC8vIEJvdGggbm9uLXplcm8gYW5kIGZpbml0ZVxyXG4gICAgfSBlbHNlIGlmICh4LnMgPCAwKSB7XHJcbiAgICAgIHRoaXMucHJlY2lzaW9uID0gd3ByO1xyXG4gICAgICB0aGlzLnJvdW5kaW5nID0gMTtcclxuICAgICAgciA9IHRoaXMuYXRhbihkaXZpZGUoeSwgeCwgd3ByLCAxKSk7XHJcbiAgICAgIHggPSBnZXRQaSh0aGlzLCB3cHIsIDEpO1xyXG4gICAgICB0aGlzLnByZWNpc2lvbiA9IHByO1xyXG4gICAgICB0aGlzLnJvdW5kaW5nID0gcm07XHJcbiAgICAgIHIgPSB5LnMgPCAwID8gci5taW51cyh4KSA6IHIucGx1cyh4KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHIgPSB0aGlzLmF0YW4oZGl2aWRlKHksIHgsIHdwciwgMSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGN1YmUgcm9vdCBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnRcclxuICAgKiBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNicnQoeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmNicnQoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCByb3VuZGVkIHRvIGFuIGludGVnZXIgdXNpbmcgYFJPVU5EX0NFSUxgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGNlaWwoeCkge1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgMik7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgY2xhbXBlZCB0byB0aGUgcmFuZ2UgZGVsaW5lYXRlZCBieSBgbWluYCBhbmQgYG1heGAuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gICAqIG1pbiB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKiBtYXgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBjbGFtcCh4LCBtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmNsYW1wKG1pbiwgbWF4KTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIENvbmZpZ3VyZSBnbG9iYWwgc2V0dGluZ3MgZm9yIGEgRGVjaW1hbCBjb25zdHJ1Y3Rvci5cclxuICAgKlxyXG4gICAqIGBvYmpgIGlzIGFuIG9iamVjdCB3aXRoIG9uZSBvciBtb3JlIG9mIHRoZSBmb2xsb3dpbmcgcHJvcGVydGllcyxcclxuICAgKlxyXG4gICAqICAgcHJlY2lzaW9uICB7bnVtYmVyfVxyXG4gICAqICAgcm91bmRpbmcgICB7bnVtYmVyfVxyXG4gICAqICAgdG9FeHBOZWcgICB7bnVtYmVyfVxyXG4gICAqICAgdG9FeHBQb3MgICB7bnVtYmVyfVxyXG4gICAqICAgbWF4RSAgICAgICB7bnVtYmVyfVxyXG4gICAqICAgbWluRSAgICAgICB7bnVtYmVyfVxyXG4gICAqICAgbW9kdWxvICAgICB7bnVtYmVyfVxyXG4gICAqICAgY3J5cHRvICAgICB7Ym9vbGVhbnxudW1iZXJ9XHJcbiAgICogICBkZWZhdWx0cyAgIHt0cnVlfVxyXG4gICAqXHJcbiAgICogRS5nLiBEZWNpbWFsLmNvbmZpZyh7IHByZWNpc2lvbjogMjAsIHJvdW5kaW5nOiA0IH0pXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBjb25maWcob2JqKSB7XHJcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JykgdGhyb3cgRXJyb3IoZGVjaW1hbEVycm9yICsgJ09iamVjdCBleHBlY3RlZCcpO1xyXG4gICAgdmFyIGksIHAsIHYsXHJcbiAgICAgIHVzZURlZmF1bHRzID0gb2JqLmRlZmF1bHRzID09PSB0cnVlLFxyXG4gICAgICBwcyA9IFtcclxuICAgICAgICAncHJlY2lzaW9uJywgMSwgTUFYX0RJR0lUUyxcclxuICAgICAgICAncm91bmRpbmcnLCAwLCA4LFxyXG4gICAgICAgICd0b0V4cE5lZycsIC1FWFBfTElNSVQsIDAsXHJcbiAgICAgICAgJ3RvRXhwUG9zJywgMCwgRVhQX0xJTUlULFxyXG4gICAgICAgICdtYXhFJywgMCwgRVhQX0xJTUlULFxyXG4gICAgICAgICdtaW5FJywgLUVYUF9MSU1JVCwgMCxcclxuICAgICAgICAnbW9kdWxvJywgMCwgOVxyXG4gICAgICBdO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBwcy5sZW5ndGg7IGkgKz0gMykge1xyXG4gICAgICBpZiAocCA9IHBzW2ldLCB1c2VEZWZhdWx0cykgdGhpc1twXSA9IERFRkFVTFRTW3BdO1xyXG4gICAgICBpZiAoKHYgPSBvYmpbcF0pICE9PSB2b2lkIDApIHtcclxuICAgICAgICBpZiAobWF0aGZsb29yKHYpID09PSB2ICYmIHYgPj0gcHNbaSArIDFdICYmIHYgPD0gcHNbaSArIDJdKSB0aGlzW3BdID0gdjtcclxuICAgICAgICBlbHNlIHRocm93IEVycm9yKGludmFsaWRBcmd1bWVudCArIHAgKyAnOiAnICsgdik7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBpZiAocCA9ICdjcnlwdG8nLCB1c2VEZWZhdWx0cykgdGhpc1twXSA9IERFRkFVTFRTW3BdO1xyXG4gICAgaWYgKCh2ID0gb2JqW3BdKSAhPT0gdm9pZCAwKSB7XHJcbiAgICAgIGlmICh2ID09PSB0cnVlIHx8IHYgPT09IGZhbHNlIHx8IHYgPT09IDAgfHwgdiA9PT0gMSkge1xyXG4gICAgICAgIGlmICh2KSB7XHJcbiAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0byAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8gJiZcclxuICAgICAgICAgICAgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMgfHwgY3J5cHRvLnJhbmRvbUJ5dGVzKSkge1xyXG4gICAgICAgICAgICB0aGlzW3BdID0gdHJ1ZTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRocm93IEVycm9yKGNyeXB0b1VuYXZhaWxhYmxlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpc1twXSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICB0aHJvdyBFcnJvcihpbnZhbGlkQXJndW1lbnQgKyBwICsgJzogJyArIHYpO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHRoaXM7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgY29zaW5lIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBjb3MoeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmNvcygpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgY29zaW5lIG9mIGB4YCwgcm91bmRlZCB0byBwcmVjaXNpb25cclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY29zaCh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuY29zaCgpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogQ3JlYXRlIGFuZCByZXR1cm4gYSBEZWNpbWFsIGNvbnN0cnVjdG9yIHdpdGggdGhlIHNhbWUgY29uZmlndXJhdGlvbiBwcm9wZXJ0aWVzIGFzIHRoaXMgRGVjaW1hbFxyXG4gICAqIGNvbnN0cnVjdG9yLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gY2xvbmUob2JqKSB7XHJcbiAgICB2YXIgaSwgcCwgcHM7XHJcblxyXG4gICAgLypcclxuICAgICAqIFRoZSBEZWNpbWFsIGNvbnN0cnVjdG9yIGFuZCBleHBvcnRlZCBmdW5jdGlvbi5cclxuICAgICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIGluc3RhbmNlLlxyXG4gICAgICpcclxuICAgICAqIHYge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9IEEgbnVtZXJpYyB2YWx1ZS5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIERlY2ltYWwodikge1xyXG4gICAgICB2YXIgZSwgaSwgdCxcclxuICAgICAgICB4ID0gdGhpcztcclxuXHJcbiAgICAgIC8vIERlY2ltYWwgY2FsbGVkIHdpdGhvdXQgbmV3LlxyXG4gICAgICBpZiAoISh4IGluc3RhbmNlb2YgRGVjaW1hbCkpIHJldHVybiBuZXcgRGVjaW1hbCh2KTtcclxuXHJcbiAgICAgIC8vIFJldGFpbiBhIHJlZmVyZW5jZSB0byB0aGlzIERlY2ltYWwgY29uc3RydWN0b3IsIGFuZCBzaGFkb3cgRGVjaW1hbC5wcm90b3R5cGUuY29uc3RydWN0b3JcclxuICAgICAgLy8gd2hpY2ggcG9pbnRzIHRvIE9iamVjdC5cclxuICAgICAgeC5jb25zdHJ1Y3RvciA9IERlY2ltYWw7XHJcblxyXG4gICAgICBpZiAoaXNEZWNpbWFsSW5zdGFuY2UodikpIHtcclxuICAgICAgICB4LnMgPSB2LnM7XHJcblxyXG4gICAgICAgIGlmIChleHRlcm5hbCkge1xyXG4gICAgICAgICAgaWYgKCF2LmQgfHwgdi5lID4gRGVjaW1hbC5tYXhFKSB7XHJcblxyXG4gICAgICAgICAgICAvLyBJbmZpbml0eS5cclxuICAgICAgICAgICAgeC5lID0gTmFOO1xyXG4gICAgICAgICAgICB4LmQgPSBudWxsO1xyXG4gICAgICAgICAgfSBlbHNlIGlmICh2LmUgPCBEZWNpbWFsLm1pbkUpIHtcclxuXHJcbiAgICAgICAgICAgIC8vIFplcm8uXHJcbiAgICAgICAgICAgIHguZSA9IDA7XHJcbiAgICAgICAgICAgIHguZCA9IFswXTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgICAgeC5kID0gdi5kLnNsaWNlKCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHguZSA9IHYuZTtcclxuICAgICAgICAgIHguZCA9IHYuZCA/IHYuZC5zbGljZSgpIDogdi5kO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICB0ID0gdHlwZW9mIHY7XHJcblxyXG4gICAgICBpZiAodCA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICBpZiAodiA9PT0gMCkge1xyXG4gICAgICAgICAgeC5zID0gMSAvIHYgPCAwID8gLTEgOiAxO1xyXG4gICAgICAgICAgeC5lID0gMDtcclxuICAgICAgICAgIHguZCA9IFswXTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIGlmICh2IDwgMCkge1xyXG4gICAgICAgICAgdiA9IC12O1xyXG4gICAgICAgICAgeC5zID0gLTE7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHgucyA9IDE7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBGYXN0IHBhdGggZm9yIHNtYWxsIGludGVnZXJzLlxyXG4gICAgICAgIGlmICh2ID09PSB+fnYgJiYgdiA8IDFlNykge1xyXG4gICAgICAgICAgZm9yIChlID0gMCwgaSA9IHY7IGkgPj0gMTA7IGkgLz0gMTApIGUrKztcclxuXHJcbiAgICAgICAgICBpZiAoZXh0ZXJuYWwpIHtcclxuICAgICAgICAgICAgaWYgKGUgPiBEZWNpbWFsLm1heEUpIHtcclxuICAgICAgICAgICAgICB4LmUgPSBOYU47XHJcbiAgICAgICAgICAgICAgeC5kID0gbnVsbDtcclxuICAgICAgICAgICAgfSBlbHNlIGlmIChlIDwgRGVjaW1hbC5taW5FKSB7XHJcbiAgICAgICAgICAgICAgeC5lID0gMDtcclxuICAgICAgICAgICAgICB4LmQgPSBbMF07XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgeC5lID0gZTtcclxuICAgICAgICAgICAgICB4LmQgPSBbdl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHguZSA9IGU7XHJcbiAgICAgICAgICAgIHguZCA9IFt2XTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBJbmZpbml0eSBvciBOYU4/XHJcbiAgICAgICAgaWYgKHYgKiAwICE9PSAwKSB7XHJcbiAgICAgICAgICBpZiAoIXYpIHgucyA9IE5hTjtcclxuICAgICAgICAgIHguZSA9IE5hTjtcclxuICAgICAgICAgIHguZCA9IG51bGw7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gcGFyc2VEZWNpbWFsKHgsIHYudG9TdHJpbmcoKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICh0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIGlmICgoaSA9IHYuY2hhckNvZGVBdCgwKSkgPT09IDQ1KSB7ICAvLyBtaW51cyBzaWduXHJcbiAgICAgICAgICB2ID0gdi5zbGljZSgxKTtcclxuICAgICAgICAgIHgucyA9IC0xO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICBpZiAoaSA9PT0gNDMpIHYgPSB2LnNsaWNlKDEpOyAgLy8gcGx1cyBzaWduXHJcbiAgICAgICAgICB4LnMgPSAxO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgcmV0dXJuIGlzRGVjaW1hbC50ZXN0KHYpID8gcGFyc2VEZWNpbWFsKHgsIHYpIDogcGFyc2VPdGhlcih4LCB2KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKHQgPT09ICdiaWdpbnQnKSB7XHJcbiAgICAgICAgaWYgKHYgPCAwKSB7XHJcbiAgICAgICAgICB2ID0gLXY7XHJcbiAgICAgICAgICB4LnMgPSAtMTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgeC5zID0gMTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBwYXJzZURlY2ltYWwoeCwgdi50b1N0cmluZygpKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdGhyb3cgRXJyb3IoaW52YWxpZEFyZ3VtZW50ICsgdik7XHJcbiAgICB9XHJcblxyXG4gICAgRGVjaW1hbC5wcm90b3R5cGUgPSBQO1xyXG5cclxuICAgIERlY2ltYWwuUk9VTkRfVVAgPSAwO1xyXG4gICAgRGVjaW1hbC5ST1VORF9ET1dOID0gMTtcclxuICAgIERlY2ltYWwuUk9VTkRfQ0VJTCA9IDI7XHJcbiAgICBEZWNpbWFsLlJPVU5EX0ZMT09SID0gMztcclxuICAgIERlY2ltYWwuUk9VTkRfSEFMRl9VUCA9IDQ7XHJcbiAgICBEZWNpbWFsLlJPVU5EX0hBTEZfRE9XTiA9IDU7XHJcbiAgICBEZWNpbWFsLlJPVU5EX0hBTEZfRVZFTiA9IDY7XHJcbiAgICBEZWNpbWFsLlJPVU5EX0hBTEZfQ0VJTCA9IDc7XHJcbiAgICBEZWNpbWFsLlJPVU5EX0hBTEZfRkxPT1IgPSA4O1xyXG4gICAgRGVjaW1hbC5FVUNMSUQgPSA5O1xyXG5cclxuICAgIERlY2ltYWwuY29uZmlnID0gRGVjaW1hbC5zZXQgPSBjb25maWc7XHJcbiAgICBEZWNpbWFsLmNsb25lID0gY2xvbmU7XHJcbiAgICBEZWNpbWFsLmlzRGVjaW1hbCA9IGlzRGVjaW1hbEluc3RhbmNlO1xyXG5cclxuICAgIERlY2ltYWwuYWJzID0gYWJzO1xyXG4gICAgRGVjaW1hbC5hY29zID0gYWNvcztcclxuICAgIERlY2ltYWwuYWNvc2ggPSBhY29zaDsgICAgICAgIC8vIEVTNlxyXG4gICAgRGVjaW1hbC5hZGQgPSBhZGQ7XHJcbiAgICBEZWNpbWFsLmFzaW4gPSBhc2luO1xyXG4gICAgRGVjaW1hbC5hc2luaCA9IGFzaW5oOyAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLmF0YW4gPSBhdGFuO1xyXG4gICAgRGVjaW1hbC5hdGFuaCA9IGF0YW5oOyAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLmF0YW4yID0gYXRhbjI7XHJcbiAgICBEZWNpbWFsLmNicnQgPSBjYnJ0OyAgICAgICAgICAvLyBFUzZcclxuICAgIERlY2ltYWwuY2VpbCA9IGNlaWw7XHJcbiAgICBEZWNpbWFsLmNsYW1wID0gY2xhbXA7XHJcbiAgICBEZWNpbWFsLmNvcyA9IGNvcztcclxuICAgIERlY2ltYWwuY29zaCA9IGNvc2g7ICAgICAgICAgIC8vIEVTNlxyXG4gICAgRGVjaW1hbC5kaXYgPSBkaXY7XHJcbiAgICBEZWNpbWFsLmV4cCA9IGV4cDtcclxuICAgIERlY2ltYWwuZmxvb3IgPSBmbG9vcjtcclxuICAgIERlY2ltYWwuaHlwb3QgPSBoeXBvdDsgICAgICAgIC8vIEVTNlxyXG4gICAgRGVjaW1hbC5sbiA9IGxuO1xyXG4gICAgRGVjaW1hbC5sb2cgPSBsb2c7XHJcbiAgICBEZWNpbWFsLmxvZzEwID0gbG9nMTA7ICAgICAgICAvLyBFUzZcclxuICAgIERlY2ltYWwubG9nMiA9IGxvZzI7ICAgICAgICAgIC8vIEVTNlxyXG4gICAgRGVjaW1hbC5tYXggPSBtYXg7XHJcbiAgICBEZWNpbWFsLm1pbiA9IG1pbjtcclxuICAgIERlY2ltYWwubW9kID0gbW9kO1xyXG4gICAgRGVjaW1hbC5tdWwgPSBtdWw7XHJcbiAgICBEZWNpbWFsLnBvdyA9IHBvdztcclxuICAgIERlY2ltYWwucmFuZG9tID0gcmFuZG9tO1xyXG4gICAgRGVjaW1hbC5yb3VuZCA9IHJvdW5kO1xyXG4gICAgRGVjaW1hbC5zaWduID0gc2lnbjsgICAgICAgICAgLy8gRVM2XHJcbiAgICBEZWNpbWFsLnNpbiA9IHNpbjtcclxuICAgIERlY2ltYWwuc2luaCA9IHNpbmg7ICAgICAgICAgIC8vIEVTNlxyXG4gICAgRGVjaW1hbC5zcXJ0ID0gc3FydDtcclxuICAgIERlY2ltYWwuc3ViID0gc3ViO1xyXG4gICAgRGVjaW1hbC5zdW0gPSBzdW07XHJcbiAgICBEZWNpbWFsLnRhbiA9IHRhbjtcclxuICAgIERlY2ltYWwudGFuaCA9IHRhbmg7ICAgICAgICAgIC8vIEVTNlxyXG4gICAgRGVjaW1hbC50cnVuYyA9IHRydW5jOyAgICAgICAgLy8gRVM2XHJcblxyXG4gICAgaWYgKG9iaiA9PT0gdm9pZCAwKSBvYmogPSB7fTtcclxuICAgIGlmIChvYmopIHtcclxuICAgICAgaWYgKG9iai5kZWZhdWx0cyAhPT0gdHJ1ZSkge1xyXG4gICAgICAgIHBzID0gWydwcmVjaXNpb24nLCAncm91bmRpbmcnLCAndG9FeHBOZWcnLCAndG9FeHBQb3MnLCAnbWF4RScsICdtaW5FJywgJ21vZHVsbycsICdjcnlwdG8nXTtcclxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcHMubGVuZ3RoOykgaWYgKCFvYmouaGFzT3duUHJvcGVydHkocCA9IHBzW2krK10pKSBvYmpbcF0gPSB0aGlzW3BdO1xyXG4gICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgRGVjaW1hbC5jb25maWcob2JqKTtcclxuXHJcbiAgICByZXR1cm4gRGVjaW1hbDtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBkaXZpZGVkIGJ5IGB5YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gICAqIHkge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBkaXYoeCwgeSkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmRpdih5KTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBuYXR1cmFsIGV4cG9uZW50aWFsIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBUaGUgcG93ZXIgdG8gd2hpY2ggdG8gcmFpc2UgdGhlIGJhc2Ugb2YgdGhlIG5hdHVyYWwgbG9nLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZXhwKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5leHAoKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCByb3VuZCB0byBhbiBpbnRlZ2VyIHVzaW5nIGBST1VORF9GTE9PUmAuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gZmxvb3IoeCkge1xyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHggPSBuZXcgdGhpcyh4KSwgeC5lICsgMSwgMyk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgdGhlIHN1bSBvZiB0aGUgc3F1YXJlcyBvZiB0aGUgYXJndW1lbnRzLFxyXG4gICAqIHJvdW5kZWQgdG8gYHByZWNpc2lvbmAgc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIGh5cG90KGEsIGIsIC4uLikgPSBzcXJ0KGFeMiArIGJeMiArIC4uLilcclxuICAgKlxyXG4gICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGh5cG90KCkge1xyXG4gICAgdmFyIGksIG4sXHJcbiAgICAgIHQgPSBuZXcgdGhpcygwKTtcclxuXHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG5cclxuICAgIGZvciAoaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOykge1xyXG4gICAgICBuID0gbmV3IHRoaXMoYXJndW1lbnRzW2krK10pO1xyXG4gICAgICBpZiAoIW4uZCkge1xyXG4gICAgICAgIGlmIChuLnMpIHtcclxuICAgICAgICAgIGV4dGVybmFsID0gdHJ1ZTtcclxuICAgICAgICAgIHJldHVybiBuZXcgdGhpcygxIC8gMCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHQgPSBuO1xyXG4gICAgICB9IGVsc2UgaWYgKHQuZCkge1xyXG4gICAgICAgIHQgPSB0LnBsdXMobi50aW1lcyhuKSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIHQuc3FydCgpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIHRydWUgaWYgb2JqZWN0IGlzIGEgRGVjaW1hbCBpbnN0YW5jZSAod2hlcmUgRGVjaW1hbCBpcyBhbnkgRGVjaW1hbCBjb25zdHJ1Y3RvciksXHJcbiAgICogb3RoZXJ3aXNlIHJldHVybiBmYWxzZS5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGlzRGVjaW1hbEluc3RhbmNlKG9iaikge1xyXG4gICAgcmV0dXJuIG9iaiBpbnN0YW5jZW9mIERlY2ltYWwgfHwgb2JqICYmIG9iai50b1N0cmluZ1RhZyA9PT0gdGFnIHx8IGZhbHNlO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG5hdHVyYWwgbG9nYXJpdGhtIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfVxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbG4oeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmxuKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgbG9nIG9mIGB4YCB0byB0aGUgYmFzZSBgeWAsIG9yIHRvIGJhc2UgMTAgaWYgbm8gYmFzZVxyXG4gICAqIGlzIHNwZWNpZmllZCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogbG9nW3ldKHgpXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBUaGUgYXJndW1lbnQgb2YgdGhlIGxvZ2FyaXRobS5cclxuICAgKiB5IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBUaGUgYmFzZSBvZiB0aGUgbG9nYXJpdGhtLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gbG9nKHgsIHkpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5sb2coeSk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgYmFzZSAyIGxvZ2FyaXRobSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGxvZzIoeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLmxvZygyKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBiYXNlIDEwIGxvZ2FyaXRobSBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIGxvZzEwKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5sb2coMTApO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIG1heGltdW0gb2YgdGhlIGFyZ3VtZW50cy5cclxuICAgKlxyXG4gICAqIGFyZ3VtZW50cyB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG1heCgpIHtcclxuICAgIHJldHVybiBtYXhPck1pbih0aGlzLCBhcmd1bWVudHMsIC0xKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSBtaW5pbXVtIG9mIHRoZSBhcmd1bWVudHMuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBtaW4oKSB7XHJcbiAgICByZXR1cm4gbWF4T3JNaW4odGhpcywgYXJndW1lbnRzLCAxKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCBtb2R1bG8gYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICogeSB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG1vZCh4LCB5KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkubW9kKHkpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIG11bHRpcGxpZWQgYnkgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICogeSB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIG11bCh4LCB5KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkubXVsKHkpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIHJhaXNlZCB0byB0aGUgcG93ZXIgYHlgLCByb3VuZGVkIHRvIHByZWNpc2lvblxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBUaGUgYmFzZS5cclxuICAgKiB5IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBUaGUgZXhwb25lbnQuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBwb3coeCwgeSkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLnBvdyh5KTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybnMgYSBuZXcgRGVjaW1hbCB3aXRoIGEgcmFuZG9tIHZhbHVlIGVxdWFsIHRvIG9yIGdyZWF0ZXIgdGhhbiAwIGFuZCBsZXNzIHRoYW4gMSwgYW5kIHdpdGhcclxuICAgKiBgc2RgLCBvciBgRGVjaW1hbC5wcmVjaXNpb25gIGlmIGBzZGAgaXMgb21pdHRlZCwgc2lnbmlmaWNhbnQgZGlnaXRzIChvciBsZXNzIGlmIHRyYWlsaW5nIHplcm9zXHJcbiAgICogYXJlIHByb2R1Y2VkKS5cclxuICAgKlxyXG4gICAqIFtzZF0ge251bWJlcn0gU2lnbmlmaWNhbnQgZGlnaXRzLiBJbnRlZ2VyLCAwIHRvIE1BWF9ESUdJVFMgaW5jbHVzaXZlLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gcmFuZG9tKHNkKSB7XHJcbiAgICB2YXIgZCwgZSwgaywgbixcclxuICAgICAgaSA9IDAsXHJcbiAgICAgIHIgPSBuZXcgdGhpcygxKSxcclxuICAgICAgcmQgPSBbXTtcclxuXHJcbiAgICBpZiAoc2QgPT09IHZvaWQgMCkgc2QgPSB0aGlzLnByZWNpc2lvbjtcclxuICAgIGVsc2UgY2hlY2tJbnQzMihzZCwgMSwgTUFYX0RJR0lUUyk7XHJcblxyXG4gICAgayA9IE1hdGguY2VpbChzZCAvIExPR19CQVNFKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuY3J5cHRvKSB7XHJcbiAgICAgIGZvciAoOyBpIDwgazspIHJkW2krK10gPSBNYXRoLnJhbmRvbSgpICogMWU3IHwgMDtcclxuXHJcbiAgICAvLyBCcm93c2VycyBzdXBwb3J0aW5nIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuXHJcbiAgICB9IGVsc2UgaWYgKGNyeXB0by5nZXRSYW5kb21WYWx1ZXMpIHtcclxuICAgICAgZCA9IGNyeXB0by5nZXRSYW5kb21WYWx1ZXMobmV3IFVpbnQzMkFycmF5KGspKTtcclxuXHJcbiAgICAgIGZvciAoOyBpIDwgazspIHtcclxuICAgICAgICBuID0gZFtpXTtcclxuXHJcbiAgICAgICAgLy8gMCA8PSBuIDwgNDI5NDk2NzI5NlxyXG4gICAgICAgIC8vIFByb2JhYmlsaXR5IG4gPj0gNC4yOWU5LCBpcyA0OTY3Mjk2IC8gNDI5NDk2NzI5NiA9IDAuMDAxMTYgKDEgaW4gODY1KS5cclxuICAgICAgICBpZiAobiA+PSA0LjI5ZTkpIHtcclxuICAgICAgICAgIGRbaV0gPSBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKG5ldyBVaW50MzJBcnJheSgxKSlbMF07XHJcbiAgICAgICAgfSBlbHNlIHtcclxuXHJcbiAgICAgICAgICAvLyAwIDw9IG4gPD0gNDI4OTk5OTk5OVxyXG4gICAgICAgICAgLy8gMCA8PSAobiAlIDFlNykgPD0gOTk5OTk5OVxyXG4gICAgICAgICAgcmRbaSsrXSA9IG4gJSAxZTc7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgLy8gTm9kZS5qcyBzdXBwb3J0aW5nIGNyeXB0by5yYW5kb21CeXRlcy5cclxuICAgIH0gZWxzZSBpZiAoY3J5cHRvLnJhbmRvbUJ5dGVzKSB7XHJcblxyXG4gICAgICAvLyBidWZmZXJcclxuICAgICAgZCA9IGNyeXB0by5yYW5kb21CeXRlcyhrICo9IDQpO1xyXG5cclxuICAgICAgZm9yICg7IGkgPCBrOykge1xyXG5cclxuICAgICAgICAvLyAwIDw9IG4gPCAyMTQ3NDgzNjQ4XHJcbiAgICAgICAgbiA9IGRbaV0gKyAoZFtpICsgMV0gPDwgOCkgKyAoZFtpICsgMl0gPDwgMTYpICsgKChkW2kgKyAzXSAmIDB4N2YpIDw8IDI0KTtcclxuXHJcbiAgICAgICAgLy8gUHJvYmFiaWxpdHkgbiA+PSAyLjE0ZTksIGlzIDc0ODM2NDggLyAyMTQ3NDgzNjQ4ID0gMC4wMDM1ICgxIGluIDI4NikuXHJcbiAgICAgICAgaWYgKG4gPj0gMi4xNGU5KSB7XHJcbiAgICAgICAgICBjcnlwdG8ucmFuZG9tQnl0ZXMoNCkuY29weShkLCBpKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG5cclxuICAgICAgICAgIC8vIDAgPD0gbiA8PSAyMTM5OTk5OTk5XHJcbiAgICAgICAgICAvLyAwIDw9IChuICUgMWU3KSA8PSA5OTk5OTk5XHJcbiAgICAgICAgICByZC5wdXNoKG4gJSAxZTcpO1xyXG4gICAgICAgICAgaSArPSA0O1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgaSA9IGsgLyA0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhyb3cgRXJyb3IoY3J5cHRvVW5hdmFpbGFibGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGsgPSByZFstLWldO1xyXG4gICAgc2QgJT0gTE9HX0JBU0U7XHJcblxyXG4gICAgLy8gQ29udmVydCB0cmFpbGluZyBkaWdpdHMgdG8gemVyb3MgYWNjb3JkaW5nIHRvIHNkLlxyXG4gICAgaWYgKGsgJiYgc2QpIHtcclxuICAgICAgbiA9IG1hdGhwb3coMTAsIExPR19CQVNFIC0gc2QpO1xyXG4gICAgICByZFtpXSA9IChrIC8gbiB8IDApICogbjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgd29yZHMgd2hpY2ggYXJlIHplcm8uXHJcbiAgICBmb3IgKDsgcmRbaV0gPT09IDA7IGktLSkgcmQucG9wKCk7XHJcblxyXG4gICAgLy8gWmVybz9cclxuICAgIGlmIChpIDwgMCkge1xyXG4gICAgICBlID0gMDtcclxuICAgICAgcmQgPSBbMF07XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBlID0gLTE7XHJcblxyXG4gICAgICAvLyBSZW1vdmUgbGVhZGluZyB3b3JkcyB3aGljaCBhcmUgemVybyBhbmQgYWRqdXN0IGV4cG9uZW50IGFjY29yZGluZ2x5LlxyXG4gICAgICBmb3IgKDsgcmRbMF0gPT09IDA7IGUgLT0gTE9HX0JBU0UpIHJkLnNoaWZ0KCk7XHJcblxyXG4gICAgICAvLyBDb3VudCB0aGUgZGlnaXRzIG9mIHRoZSBmaXJzdCB3b3JkIG9mIHJkIHRvIGRldGVybWluZSBsZWFkaW5nIHplcm9zLlxyXG4gICAgICBmb3IgKGsgPSAxLCBuID0gcmRbMF07IG4gPj0gMTA7IG4gLz0gMTApIGsrKztcclxuXHJcbiAgICAgIC8vIEFkanVzdCB0aGUgZXhwb25lbnQgZm9yIGxlYWRpbmcgemVyb3Mgb2YgdGhlIGZpcnN0IHdvcmQgb2YgcmQuXHJcbiAgICAgIGlmIChrIDwgTE9HX0JBU0UpIGUgLT0gTE9HX0JBU0UgLSBrO1xyXG4gICAgfVxyXG5cclxuICAgIHIuZSA9IGU7XHJcbiAgICByLmQgPSByZDtcclxuXHJcbiAgICByZXR1cm4gcjtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIGB4YCByb3VuZGVkIHRvIGFuIGludGVnZXIgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogVG8gZW11bGF0ZSBgTWF0aC5yb3VuZGAsIHNldCByb3VuZGluZyB0byA3IChST1VORF9IQUxGX0NFSUwpLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHJvdW5kKHgpIHtcclxuICAgIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIHRoaXMucm91bmRpbmcpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuXHJcbiAgICogICAxICAgIGlmIHggPiAwLFxyXG4gICAqICAtMSAgICBpZiB4IDwgMCxcclxuICAgKiAgIDAgICAgaWYgeCBpcyAwLFxyXG4gICAqICAtMCAgICBpZiB4IGlzIC0wLFxyXG4gICAqICAgTmFOICBvdGhlcndpc2VcclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBzaWduKHgpIHtcclxuICAgIHggPSBuZXcgdGhpcyh4KTtcclxuICAgIHJldHVybiB4LmQgPyAoeC5kWzBdID8geC5zIDogMCAqIHgucykgOiB4LnMgfHwgTmFOO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHNpbmUgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9IEEgdmFsdWUgaW4gcmFkaWFucy5cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHNpbih4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuc2luKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgaHlwZXJib2xpYyBzaW5lIG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYFxyXG4gICAqIHNpZ25pZmljYW50IGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBzaW5oKHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5zaW5oKCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyB0aGUgc3F1YXJlIHJvb3Qgb2YgYHhgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50XHJcbiAgICogZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBzcXJ0KHgpIHtcclxuICAgIHJldHVybiBuZXcgdGhpcyh4KS5zcXJ0KCk7XHJcbiAgfVxyXG5cclxuXHJcbiAgLypcclxuICAgKiBSZXR1cm4gYSBuZXcgRGVjaW1hbCB3aG9zZSB2YWx1ZSBpcyBgeGAgbWludXMgYHlgLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gIHNpZ25pZmljYW50IGRpZ2l0c1xyXG4gICAqIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIHgge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICogeSB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHN1Yih4LCB5KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkuc3ViKHkpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIHN1bSBvZiB0aGUgYXJndW1lbnRzLCByb3VuZGVkIHRvIGBwcmVjaXNpb25gXHJcbiAgICogc2lnbmlmaWNhbnQgZGlnaXRzIHVzaW5nIHJvdW5kaW5nIG1vZGUgYHJvdW5kaW5nYC5cclxuICAgKlxyXG4gICAqIE9ubHkgdGhlIHJlc3VsdCBpcyByb3VuZGVkLCBub3QgdGhlIGludGVybWVkaWF0ZSBjYWxjdWxhdGlvbnMuXHJcbiAgICpcclxuICAgKiBhcmd1bWVudHMge251bWJlcnxzdHJpbmd8YmlnaW50fERlY2ltYWx9XHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiBzdW0oKSB7XHJcbiAgICB2YXIgaSA9IDAsXHJcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHMsXHJcbiAgICAgIHggPSBuZXcgdGhpcyhhcmdzW2ldKTtcclxuXHJcbiAgICBleHRlcm5hbCA9IGZhbHNlO1xyXG4gICAgZm9yICg7IHgucyAmJiArK2kgPCBhcmdzLmxlbmd0aDspIHggPSB4LnBsdXMoYXJnc1tpXSk7XHJcbiAgICBleHRlcm5hbCA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIGZpbmFsaXNlKHgsIHRoaXMucHJlY2lzaW9uLCB0aGlzLnJvdW5kaW5nKTtcclxuICB9XHJcblxyXG5cclxuICAvKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWNpbWFsIHdob3NlIHZhbHVlIGlzIHRoZSB0YW5nZW50IG9mIGB4YCwgcm91bmRlZCB0byBgcHJlY2lzaW9uYCBzaWduaWZpY2FudFxyXG4gICAqIGRpZ2l0cyB1c2luZyByb3VuZGluZyBtb2RlIGByb3VuZGluZ2AuXHJcbiAgICpcclxuICAgKiB4IHtudW1iZXJ8c3RyaW5nfGJpZ2ludHxEZWNpbWFsfSBBIHZhbHVlIGluIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKi9cclxuICBmdW5jdGlvbiB0YW4oeCkge1xyXG4gICAgcmV0dXJuIG5ldyB0aGlzKHgpLnRhbigpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgdGhlIGh5cGVyYm9saWMgdGFuZ2VudCBvZiBgeGAsIHJvdW5kZWQgdG8gYHByZWNpc2lvbmBcclxuICAgKiBzaWduaWZpY2FudCBkaWdpdHMgdXNpbmcgcm91bmRpbmcgbW9kZSBgcm91bmRpbmdgLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH0gQSB2YWx1ZSBpbiByYWRpYW5zLlxyXG4gICAqXHJcbiAgICovXHJcbiAgZnVuY3Rpb24gdGFuaCh4KSB7XHJcbiAgICByZXR1cm4gbmV3IHRoaXMoeCkudGFuaCgpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8qXHJcbiAgICogUmV0dXJuIGEgbmV3IERlY2ltYWwgd2hvc2UgdmFsdWUgaXMgYHhgIHRydW5jYXRlZCB0byBhbiBpbnRlZ2VyLlxyXG4gICAqXHJcbiAgICogeCB7bnVtYmVyfHN0cmluZ3xiaWdpbnR8RGVjaW1hbH1cclxuICAgKlxyXG4gICAqL1xyXG4gIGZ1bmN0aW9uIHRydW5jKHgpIHtcclxuICAgIHJldHVybiBmaW5hbGlzZSh4ID0gbmV3IHRoaXMoeCksIHguZSArIDEsIDEpO1xyXG4gIH1cclxuXHJcblxyXG4gIC8vIENyZWF0ZSBhbmQgY29uZmlndXJlIGluaXRpYWwgRGVjaW1hbCBjb25zdHJ1Y3Rvci5cclxuICBEZWNpbWFsID0gY2xvbmUoREVGQVVMVFMpO1xyXG4gIERlY2ltYWwucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gRGVjaW1hbDtcclxuICBEZWNpbWFsWydkZWZhdWx0J10gPSBEZWNpbWFsLkRlY2ltYWwgPSBEZWNpbWFsO1xyXG5cclxuICAvLyBDcmVhdGUgdGhlIGludGVybmFsIGNvbnN0YW50cyBmcm9tIHRoZWlyIHN0cmluZyB2YWx1ZXMuXHJcbiAgTE4xMCA9IG5ldyBEZWNpbWFsKExOMTApO1xyXG4gIFBJID0gbmV3IERlY2ltYWwoUEkpO1xyXG5cclxuXHJcbiAgLy8gRXhwb3J0LlxyXG5cclxuXHJcbiAgLy8gQU1ELlxyXG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgcmV0dXJuIERlY2ltYWw7XHJcbiAgICB9KTtcclxuXHJcbiAgLy8gTm9kZSBhbmQgb3RoZXIgZW52aXJvbm1lbnRzIHRoYXQgc3VwcG9ydCBtb2R1bGUuZXhwb3J0cy5cclxuICB9IGVsc2UgaWYgKHR5cGVvZiBtb2R1bGUgIT0gJ3VuZGVmaW5lZCcgJiYgbW9kdWxlLmV4cG9ydHMpIHtcclxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PSAnc3ltYm9sJykge1xyXG4gICAgICBQW1N5bWJvbFsnZm9yJ10oJ25vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tJyldID0gUC50b1N0cmluZztcclxuICAgICAgUFtTeW1ib2wudG9TdHJpbmdUYWddID0gJ0RlY2ltYWwnO1xyXG4gICAgfVxyXG5cclxuICAgIG1vZHVsZS5leHBvcnRzID0gRGVjaW1hbDtcclxuXHJcbiAgLy8gQnJvd3Nlci5cclxuICB9IGVsc2Uge1xyXG4gICAgaWYgKCFnbG9iYWxTY29wZSkge1xyXG4gICAgICBnbG9iYWxTY29wZSA9IHR5cGVvZiBzZWxmICE9ICd1bmRlZmluZWQnICYmIHNlbGYgJiYgc2VsZi5zZWxmID09IHNlbGYgPyBzZWxmIDogd2luZG93O1xyXG4gICAgfVxyXG5cclxuICAgIG5vQ29uZmxpY3QgPSBnbG9iYWxTY29wZS5EZWNpbWFsO1xyXG4gICAgRGVjaW1hbC5ub0NvbmZsaWN0ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICBnbG9iYWxTY29wZS5EZWNpbWFsID0gbm9Db25mbGljdDtcclxuICAgICAgcmV0dXJuIERlY2ltYWw7XHJcbiAgICB9O1xyXG5cclxuICAgIGdsb2JhbFNjb3BlLkRlY2ltYWwgPSBEZWNpbWFsO1xyXG4gIH1cclxufSkodGhpcyk7XHJcbiJdLCJuYW1lcyI6WyJnbG9iYWxTY29wZSIsIkVYUF9MSU1JVCIsIk1BWF9ESUdJVFMiLCJOVU1FUkFMUyIsIkxOMTAiLCJQSSIsIkRFRkFVTFRTIiwicHJlY2lzaW9uIiwicm91bmRpbmciLCJtb2R1bG8iLCJ0b0V4cE5lZyIsInRvRXhwUG9zIiwibWluRSIsIm1heEUiLCJjcnlwdG8iLCJEZWNpbWFsIiwiaW5leGFjdCIsIm5vQ29uZmxpY3QiLCJxdWFkcmFudCIsImV4dGVybmFsIiwiZGVjaW1hbEVycm9yIiwiaW52YWxpZEFyZ3VtZW50IiwicHJlY2lzaW9uTGltaXRFeGNlZWRlZCIsImNyeXB0b1VuYXZhaWxhYmxlIiwidGFnIiwibWF0aGZsb29yIiwiTWF0aCIsImZsb29yIiwibWF0aHBvdyIsInBvdyIsImlzQmluYXJ5IiwiaXNIZXgiLCJpc09jdGFsIiwiaXNEZWNpbWFsIiwiQkFTRSIsIkxPR19CQVNFIiwiTUFYX1NBRkVfSU5URUdFUiIsIkxOMTBfUFJFQ0lTSU9OIiwibGVuZ3RoIiwiUElfUFJFQ0lTSU9OIiwiUCIsInRvU3RyaW5nVGFnIiwiYWJzb2x1dGVWYWx1ZSIsImFicyIsIngiLCJjb25zdHJ1Y3RvciIsInMiLCJmaW5hbGlzZSIsImNlaWwiLCJlIiwiY2xhbXBlZFRvIiwiY2xhbXAiLCJtaW4iLCJtYXgiLCJrIiwiQ3RvciIsIk5hTiIsImd0IiwiRXJyb3IiLCJjbXAiLCJjb21wYXJlZFRvIiwieSIsImkiLCJqIiwieGRMIiwieWRMIiwieGQiLCJkIiwieWQiLCJ4cyIsInlzIiwiY29zaW5lIiwiY29zIiwicHIiLCJybSIsInNkIiwidG9MZXNzVGhhbkhhbGZQaSIsIm5lZyIsImN1YmVSb290IiwiY2JydCIsIm0iLCJuIiwiciIsInJlcCIsInQiLCJ0MyIsInQzcGx1c3giLCJpc0Zpbml0ZSIsImlzWmVybyIsImRpZ2l0c1RvU3RyaW5nIiwidG9FeHBvbmVudGlhbCIsInNsaWNlIiwiaW5kZXhPZiIsInRvU3RyaW5nIiwidGltZXMiLCJwbHVzIiwiZGl2aWRlIiwiZXEiLCJjaGFyQXQiLCJkZWNpbWFsUGxhY2VzIiwiZHAiLCJ3IiwiZGl2aWRlZEJ5IiwiZGl2IiwiZGl2aWRlZFRvSW50ZWdlckJ5IiwiZGl2VG9JbnQiLCJlcXVhbHMiLCJncmVhdGVyVGhhbiIsImdyZWF0ZXJUaGFuT3JFcXVhbFRvIiwiZ3RlIiwiaHlwZXJib2xpY0Nvc2luZSIsImNvc2giLCJsZW4iLCJvbmUiLCJ0aW55UG93IiwidGF5bG9yU2VyaWVzIiwiY29zaDJfeCIsImQ4IiwibWludXMiLCJoeXBlcmJvbGljU2luZSIsInNpbmgiLCJzcXJ0Iiwic2luaDJfeCIsImQ1IiwiZDE2IiwiZDIwIiwiaHlwZXJib2xpY1RhbmdlbnQiLCJ0YW5oIiwiaW52ZXJzZUNvc2luZSIsImFjb3MiLCJpc05lZyIsImdldFBpIiwiYXRhbiIsImludmVyc2VIeXBlcmJvbGljQ29zaW5lIiwiYWNvc2giLCJsdGUiLCJsbiIsImludmVyc2VIeXBlcmJvbGljU2luZSIsImFzaW5oIiwiaW52ZXJzZUh5cGVyYm9saWNUYW5nZW50IiwiYXRhbmgiLCJ3cHIiLCJ4c2QiLCJpbnZlcnNlU2luZSIsImFzaW4iLCJoYWxmUGkiLCJpbnZlcnNlVGFuZ2VudCIsInB4IiwieDIiLCJpc0ludGVnZXIiLCJpc0ludCIsImlzTmFOIiwiaXNOZWdhdGl2ZSIsImlzUG9zaXRpdmUiLCJpc1BvcyIsImxlc3NUaGFuIiwibHQiLCJsZXNzVGhhbk9yRXF1YWxUbyIsImxvZ2FyaXRobSIsImxvZyIsImJhc2UiLCJpc0Jhc2UxMCIsImRlbm9taW5hdG9yIiwiaW5mIiwibnVtIiwiYXJnIiwiZ3VhcmQiLCJuYXR1cmFsTG9nYXJpdGhtIiwiZ2V0TG4xMCIsImNoZWNrUm91bmRpbmdEaWdpdHMiLCJzdWIiLCJ4ZSIsInhMVHkiLCJyZXZlcnNlIiwicHVzaCIsInBvcCIsInNoaWZ0IiwiZ2V0QmFzZTEwRXhwb25lbnQiLCJtb2QiLCJxIiwibmF0dXJhbEV4cG9uZW50aWFsIiwiZXhwIiwibmVnYXRlZCIsImFkZCIsImNhcnJ5IiwidW5zaGlmdCIsInoiLCJnZXRQcmVjaXNpb24iLCJyb3VuZCIsInNpbmUiLCJzaW4iLCJzcXVhcmVSb290IiwidGFuZ2VudCIsInRhbiIsIm11bCIsInJMIiwidG9CaW5hcnkiLCJ0b1N0cmluZ0JpbmFyeSIsInRvRGVjaW1hbFBsYWNlcyIsInRvRFAiLCJjaGVja0ludDMyIiwic3RyIiwiZmluaXRlVG9TdHJpbmciLCJ0b0ZpeGVkIiwidG9GcmFjdGlvbiIsIm1heEQiLCJkMCIsImQxIiwiZDIiLCJuMCIsIm4xIiwidG9IZXhhZGVjaW1hbCIsInRvSGV4IiwidG9OZWFyZXN0IiwidG9OdW1iZXIiLCJ0b09jdGFsIiwidG9Qb3dlciIsInluIiwiaW50UG93IiwidG9QcmVjaXNpb24iLCJ0b1NpZ25pZmljYW50RGlnaXRzIiwidG9TRCIsInRydW5jYXRlZCIsInRydW5jIiwidmFsdWVPZiIsInRvSlNPTiIsIndzIiwiaW5kZXhPZkxhc3RXb3JkIiwiZ2V0WmVyb1N0cmluZyIsInJlcGVhdGluZyIsImRpIiwicmQiLCJjb252ZXJ0QmFzZSIsImJhc2VJbiIsImJhc2VPdXQiLCJhcnIiLCJhcnJMIiwic3RyTCIsImNvczJ4IiwibXVsdGlwbHlJbnRlZ2VyIiwidGVtcCIsImNvbXBhcmUiLCJhIiwiYiIsImFMIiwiYkwiLCJzdWJ0cmFjdCIsImxvZ0Jhc2UiLCJtb3JlIiwicHJvZCIsInByb2RMIiwicWQiLCJyZW0iLCJyZW1MIiwicmVtMCIsInhpIiwieEwiLCJ5ZDAiLCJ5TCIsInl6Iiwic2lnbiIsImlzVHJ1bmNhdGVkIiwiZGlnaXRzIiwicm91bmRVcCIsInhkaSIsIm91dCIsImlzRXhwIiwibm9uRmluaXRlVG9TdHJpbmciLCJ6cyIsInRydW5jYXRlIiwiaXNPZGQiLCJtYXhPck1pbiIsImFyZ3MiLCJzdW0iLCJjIiwiYzAiLCJudW1lcmF0b3IiLCJ4MSIsIlN0cmluZyIsInBhcnNlRGVjaW1hbCIsInJlcGxhY2UiLCJzZWFyY2giLCJzdWJzdHJpbmciLCJjaGFyQ29kZUF0IiwicGFyc2VPdGhlciIsImRpdmlzb3IiLCJpc0Zsb2F0IiwicCIsInRlc3QiLCJ0b0xvd2VyQ2FzZSIsInNpbjJfeCIsImlzSHlwZXJib2xpYyIsInUiLCJwaSIsImF0YW4yIiwiY29uZmlnIiwib2JqIiwidiIsInVzZURlZmF1bHRzIiwiZGVmYXVsdHMiLCJwcyIsImdldFJhbmRvbVZhbHVlcyIsInJhbmRvbUJ5dGVzIiwiY2xvbmUiLCJpc0RlY2ltYWxJbnN0YW5jZSIsInByb3RvdHlwZSIsIlJPVU5EX1VQIiwiUk9VTkRfRE9XTiIsIlJPVU5EX0NFSUwiLCJST1VORF9GTE9PUiIsIlJPVU5EX0hBTEZfVVAiLCJST1VORF9IQUxGX0RPV04iLCJST1VORF9IQUxGX0VWRU4iLCJST1VORF9IQUxGX0NFSUwiLCJST1VORF9IQUxGX0ZMT09SIiwiRVVDTElEIiwic2V0IiwiaHlwb3QiLCJsb2cxMCIsImxvZzIiLCJyYW5kb20iLCJoYXNPd25Qcm9wZXJ0eSIsImFyZ3VtZW50cyIsIlVpbnQzMkFycmF5IiwiY29weSIsImRlZmluZSIsImFtZCIsIm1vZHVsZSIsImV4cG9ydHMiLCJTeW1ib2wiLCJpdGVyYXRvciIsInNlbGYiLCJ3aW5kb3ciXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/decimal.js/decimal.js\n");

/***/ })

};
;